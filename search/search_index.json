{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LibreTiny","text":"<p>(formerly LibreTuya)</p>     <p>  </p>  <p>PlatformIO development platform for BK7231, RTL8710 and LN882H IoT chips.</p> <p>The main goal of this project is to provide a usable build environment for IoT developers. While also providing vendor SDKs as PlatformIO cores, the project focuses on developing working Arduino-compatible cores for supported families. The cores are inspired by Espressif's official core for ESP32, which should make it easier to port/run existing ESP apps on less-common, unsupported IoT modules.</p> <p>There's an ESPHome port based on LibreTiny, which supports BK7231 and RTL8710B chips.</p> <p>Note: this project is work-in-progress.</p>"},{"location":"#getting-started","title":"\u2b50 Getting started \u2b50","text":""},{"location":"#license","title":"License","text":"<p>See LICENSE. Project is licensed under MIT License.</p> <p>Parts of the code may come from third parties, vendor SDKs or other open-source projects. Most of these files are marked with appropriate copyright/author/license notices.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"","text":"<ul> <li>Home</li> <li>\ud83d\ude0a Getting started<ul> <li>\u27a1\ufe0f Info on accessing GPIOs</li> </ul> </li>  <li>\ud83d\udcfa Cloudcutter &amp; ESPHome video guide</li> <li>\ud83d\udca1 ESPHome setup guide</li> <li>\ud83d\uded6 ESPHome Hassio Add-On</li>  <li>\ud83d\udcf2 Flashing/dumping guide</li> <li>\ud83d\udd0c How to flash/enter download mode?</li>  <li>\ud83d\udcbb Chips, boards, features<ul> <li>All boards</li> </ul> </li>  <li>\ud83c\udf6a Chip family docs &amp; info<ul> <li>Beken BK72xx<ul> <li>Finding encryption keys</li> </ul> </li> <li>Realtek Ameba - info</li> <li>Realtek AmebaZ<ul> <li>Debugging</li> <li>Exception decoder</li> </ul> </li> <li>Lightning LN882x</li> </ul> </li> <li>\ud83d\udd27 LT Configuration</li> <li>\ud83e\uddd1 Programmer's manual<ul> <li>\u26a0\ufe0f Migration guide</li> <li>\ud83d\udd0b PlatformIO Examples</li> <li>\ud83d\udcd6 LibreTiny API<ul> <li>C API</li> <li>C++ API</li> </ul> </li> <li>\ud83d\udcda Arduino Libraries<ul> <li>SoftwareSerial</li> <li>WiFi</li>  <li>Flash</li> <li>IPv6Address</li> <li>MD5</li> <li>mDNS</li> <li>Update</li> <li>WiFiClient</li> <li>WiFiClientSecure</li> <li>WiFiServer</li> <li>WiFiUDP</li>  <li>HTTPClient</li> <li>StreamString</li> <li>WebServer</li> <li>WiFiMulti</li>  <li>External compatible libraries</li> </ul> </li> <li>Full documentation<ul> <li>Classes</li> <li>Functions</li> <li>Macros</li> <li>File list</li> </ul> </li> </ul> </li> <li>\ud83d\udc77 Contributor's manual (WIP)<ul> <li>Porting new families</li> <li>API functions guide</li> <li>C standard library</li> <li>\ud83d\udcc1 Project structure</li> <li>\u2708\ufe0f OTA format<ul> <li>uf2ota.py tool</li> <li>uf2ota.h library</li> </ul> </li> <li>\ud83d\udcd3 TODO</li> </ul> </li>  <li>\ud83d\udd17 Resources</li> </ul>"},{"location":"boards/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Generic - BK7231N (Tuya QFN32)</li> <li>Generic - BK7231T (Tuya QFN32)</li> <li>Generic - BK7252</li> <li>Generic - LN882HKI</li> <li>Generic - RTL8710BN (2M/468k)</li> <li>Generic - RTL8710BN (2M/788k)</li> <li>Generic - RTL8710BX (4M/980k)</li> <li>Generic - RTL8720CF (2M/992k)</li> <li>AFW121T</li> <li>BW12</li> <li>BW15</li> <li>CB1S</li> <li>CB2L</li> <li>CB2S</li> <li>CB3L</li> <li>CB3S</li> <li>CB3SE</li> <li>CBLC5</li> <li>CBU</li> <li>WB2L-M1</li> <li>WA2</li> <li>WB1S</li> <li>WB2L</li> <li>WB2S</li> <li>WB3L</li> <li>WB3S</li> <li>WBLC5</li> <li>WR1</li> <li>WR1E</li> <li>WR2</li> <li>WR2E</li> <li>WR3</li> <li>WR3E</li> <li>WR3N</li> <li>WR2L</li> <li>WR2LE</li> <li>WR3L</li> <li>WR3LE</li> <li>LSC LMA35 N</li> <li>LSC LMA35 T</li> <li>LN-02</li> <li>WB02A</li> <li>WL2S</li> <li>T102-V1.1</li> <li>T112-V1.1</li> <li>T103-V1.0</li> </ul>"},{"location":"boards/afw121t/","title":"AFW121T","text":"<p>by 99iot(Shenzhen)co.,ltd</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> <li>Vendor datasheet</li> </ul>    Parameter Value     Board code <code>afw121t</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 1 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/afw121t/#usage","title":"Usage","text":"<p>Board code: <code>afw121t</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:afw121t]\nplatform = libretiny\nboard = afw121t\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: afw121t\n</code></pre>"},{"location":"boards/afw121t/#pinout","title":"Pinout","text":""},{"location":"boards/afw121t/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/afw121t/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 1 MiB / 1,048,576 B / 0x100000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 468 KiB / 0x75000 0x080000   OTA2 Image 0x080000 468 KiB / 0x75000 0x0F5000   Key-Value Store 0x0F5000 16 KiB / 0x4000 0x0F9000   User Data 0x0F9000 28 KiB / 0x7000 0x100000   (reserved) 0x100000 1020 KiB / 0xFF000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/bw12/","title":"BW12","text":"<p>by Ai-Thinker Co., Ltd.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> <li>Vendor datasheet</li> </ul>    Parameter Value     Board code <code>bw12</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ARI3-BW1X"},{"location":"boards/bw12/#usage","title":"Usage","text":"<p>Board code: <code>bw12</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:bw12]\nplatform = libretiny\nboard = bw12\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: bw12\n</code></pre>"},{"location":"boards/bw12/#pinout","title":"Pinout","text":""},{"location":"boards/bw12/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/bw12/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 468 KiB / 0x75000 0x080000   OTA2 Image 0x080000 468 KiB / 0x75000 0x0F5000   Key-Value Store 0x0F5000 32 KiB / 0x8000 0x0FD000   User Data 0x0FD000 1 MiB / 0x102000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/bw15/","title":"BW15","text":"<p>by Ai-Thinker Co., Ltd.</p> <p>Product page</p> <ul> <li>General info</li> <li>Vendor datasheet</li> </ul>    Parameter Value     Board code <code>bw15</code>   MCU RTL8720CF   Manufacturer Realtek   Series AmebaZ2   Frequency 100 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 8x PWM, 3x UART   Wi-Fi 802.11 b/g/n   BLE v4.2   FCC ID 2AXVG-BW15"},{"location":"boards/bw15/#usage","title":"Usage","text":"<p>Board code: <code>bw15</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:bw15]\nplatform = libretiny\nboard = bw15\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: bw15\n</code></pre>"},{"location":"boards/bw15/#pinout","title":"Pinout","text":""},{"location":"boards/bw15/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00 RX1   PWM0 SWCLK, TCK   PA01 TX1   PWM1 SWDIO, TMS   PA02 RX1 SCL0 CS0 PWM2 TDO   PA03 TX1 SDA0 SCK0 PWM3 TDI   PA04   MOSI0 PWM4 tRST   PA13 RX0   PWM7    PA14 TX0   PWM2    PA15 RX2 SCL0 CS0 PWM3    PA16 TX2 SDA0 SCK0 PWM4    PA17    PWM5    PA18    PWM6    PA19  SCL0 MOSI0 PWM7    PA20  SDA0 MISO0 PWM0"},{"location":"boards/bw15/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Partition Table 0x000000 4 KiB / 0x1000 0x001000   System Data 0x001000 4 KiB / 0x1000 0x002000   Calibration 0x002000 4 KiB / 0x1000 0x003000   (reserved) 0x003000 4 KiB / 0x1000 0x004000   Boot Image 0x004000 32 KiB / 0x8000 0x00C000   OTA1 Image 0x00C000 992 KiB / 0xF8000 0x104000   OTA2 Image 0x104000 992 KiB / 0xF8000 0x1FC000   Key-Value Store 0x1FC000 16 KiB / 0x4000 0x200000"},{"location":"boards/cb1s/","title":"CB1S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb1s</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/cb1s/#usage","title":"Usage","text":"<p>Board code: <code>cb1s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb1s]\nplatform = libretiny\nboard = cb1s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb1s\n</code></pre>"},{"location":"boards/cb1s/#pinout","title":"Pinout","text":""},{"location":"boards/cb1s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/cb1s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb2l/","title":"CB2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb2l</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB2L"},{"location":"boards/cb2l/#usage","title":"Usage","text":"<p>Board code: <code>cb2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb2l]\nplatform = libretiny\nboard = cb2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb2l\n</code></pre>"},{"location":"boards/cb2l/#pinout","title":"Pinout","text":""},{"location":"boards/cb2l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2       P6    PWM0    P7    PWM1    P8    PWM2    P10 RX1       P11 TX1       P21        P24    PWM4    P26    PWM5"},{"location":"boards/cb2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb2s/","title":"CB2S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb2s</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB2S"},{"location":"boards/cb2s/#usage","title":"Usage","text":"<p>Board code: <code>cb2s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb2s]\nplatform = libretiny\nboard = cb2s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb2s\n</code></pre>"},{"location":"boards/cb2s/#pinout","title":"Pinout","text":""},{"location":"boards/cb2s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P10 RX1       P11 TX1       P21  SDA1      P23, ADC3        P24    PWM4    P26    PWM5"},{"location":"boards/cb2s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3l/","title":"CB3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb3l</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 12x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3L"},{"location":"boards/cb3l/#usage","title":"Usage","text":"<p>Board code: <code>cb3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3l]\nplatform = libretiny\nboard = cb3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb3l\n</code></pre>"},{"location":"boards/cb3l/#pinout","title":"Pinout","text":""},{"location":"boards/cb3l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2       P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14        P21        P23, ADC3        P24    PWM4    P26    PWM5"},{"location":"boards/cb3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3s/","title":"CB3S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb3s</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3S"},{"location":"boards/cb3s/#usage","title":"Usage","text":"<p>Board code: <code>cb3s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3s]\nplatform = libretiny\nboard = cb3s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb3s\n</code></pre>"},{"location":"boards/cb3s/#pinout","title":"Pinout","text":""},{"location":"boards/cb3s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2       P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14        P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/cb3s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3se/","title":"CB3SE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cb3se</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3SE"},{"location":"boards/cb3se/#usage","title":"Usage","text":"<p>Board code: <code>cb3se</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3se]\nplatform = libretiny\nboard = cb3se\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cb3se\n</code></pre>"},{"location":"boards/cb3se/#pinout","title":"Pinout","text":""},{"location":"boards/cb3se/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14   SCK     P15   CS     P16   MOSI     P17   MISO     P20        P22        P23, ADC3        P24    PWM4    P26    PWM5"},{"location":"boards/cb3se/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cblc5/","title":"CBLC5 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cblc5</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 8x GPIO, 3x PWM, 2x UART   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/cblc5/#usage","title":"Usage","text":"<p>Board code: <code>cblc5</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cblc5]\nplatform = libretiny\nboard = cblc5\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cblc5\n</code></pre>"},{"location":"boards/cblc5/#pinout","title":"Pinout","text":""},{"location":"boards/cblc5/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P10 RX1       P11 TX1       P21        P24    PWM4    P26    PWM5"},{"location":"boards/cblc5/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cbu/","title":"CBU Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>cbu</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 19x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CBU"},{"location":"boards/cbu/#usage","title":"Usage","text":"<p>Board code: <code>cbu</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cbu]\nplatform = libretiny\nboard = cbu\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: cbu\n</code></pre>"},{"location":"boards/cbu/#pinout","title":"Pinout","text":""},{"location":"boards/cbu/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14   SCK     P15   CS     P16   MOSI     P17   MISO     P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5    P28"},{"location":"boards/cbu/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7231n-qfn32-tuya/","title":"Generic - BK7231N (Tuya QFN32)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7231n-qfn32-tuya</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 19x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/generic-bk7231n-qfn32-tuya/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7231n-qfn32-tuya</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7231n-qfn32-tuya]\nplatform = libretiny\nboard = generic-bk7231n-qfn32-tuya\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: generic-bk7231n-qfn32-tuya\n</code></pre>"},{"location":"boards/generic-bk7231n-qfn32-tuya/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14   SCK     P15   CS     P16   MOSI     P17   MISO     P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5    P28"},{"location":"boards/generic-bk7231n-qfn32-tuya/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7231t-qfn32-tuya/","title":"Generic - BK7231T (Tuya QFN32)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7231t-qfn32-tuya</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 19x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2"},{"location":"boards/generic-bk7231t-qfn32-tuya/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7231t-qfn32-tuya</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7231t-qfn32-tuya]\nplatform = libretiny\nboard = generic-bk7231t-qfn32-tuya\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: generic-bk7231t-qfn32-tuya\n</code></pre>"},{"location":"boards/generic-bk7231t-qfn32-tuya/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14   SCK     P15   CS     P16   MOSI     P17   MISO     P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5    P28"},{"location":"boards/generic-bk7231t-qfn32-tuya/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7252/","title":"Generic - BK7252","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7252</code>   MCU BK7252   Manufacturer Beken   Series BK72XX   Frequency 180 MHz   Flash size 4 MiB   RAM size 512 KiB   Voltage 3.0V - 3.6V   I/O 38x GPIO, 4x PWM, 2x UART, 7x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.0"},{"location":"boards/generic-bk7252/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7252</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7252]\nplatform = libretiny\nboard = generic-bk7252\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: generic-bk7252\n</code></pre>"},{"location":"boards/generic-bk7252/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P2, ADC4        P3, ADC5        P4, ADC1        P5, ADC2        P6    PWM0    P7    PWM1    P10 RX1       P11 TX1       P12, ADC6 CTS1       P13, ADC7 RTS1       P14   SCK     P15   CS     P16   MOSI     P17   MISO     P18        P19        P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P25        P26    PWM5    P27     MCLK   P28        P29     PCLK   P30     HSYNC   P31     VSYNC   P32     PD0   P33     PD1   P34     PD2   P35     PD3   P36     PD4   P37     PD5   P38     PD6   P39     PD7"},{"location":"boards/generic-bk7252/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 4 MiB / 4,194,304 B / 0x400000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.7 MiB / 0x1BA000 0x1CB000   File System 0x1CB000 1.1 MiB / 0x119000 0x2E4000   Key-Value Store 0x2E4000 32 KiB / 0x8000 0x2EC000   OTA Image 0x2EC000 1.1 MiB / 0x112000 0x3FE000   Calibration 0x3FE000 4 KiB / 0x1000 0x3FF000   TLV Store 0x3FF000 4 KiB / 0x1000 0x400000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-ln882hki/","title":"Generic - LN882HKI","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-ln882hki</code>   MCU LN882HK   Manufacturer Lightning   Series LN882X   Frequency 160 MHz   Flash size 2 MiB   RAM size 295 KiB   Voltage 3.0V - 3.6V   I/O 20x GPIO, 2x UART, 6x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/generic-ln882hki/#usage","title":"Usage","text":"<p>Board code: <code>generic-ln882hki</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-ln882hki]\nplatform = libretiny\nboard = generic-ln882hki\nframework = arduino\n</code></pre>"},{"location":"boards/generic-ln882hki/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00, ADC2  SCL0, SDA0      PA01, ADC3  SCL0, SDA0   SWDIO   PA02 TX0 SCL0, SDA0      PA03 RX0 SCL0, SDA0      PA04, ADC4  SCL0, SDA0   SWCLK   PA05  SCL0, SDA0      PA06  SCL0, SDA0      PA07  SCL0, SDA0      PA08  SCL0, SDA0      PA09  SCL0, SDA0      PA10  SCL0, SDA0      PA11  SCL0, SDA0      PA12  SCL0, SDA0      PB03, ADC5  SCL0, SDA0      PB04, ADC6  SCL0, SDA0      PB05, ADC7  SCL0, SDA0      PB06  SCL0, SDA0      PB07  SCL0, SDA0      PB08 RX1 SCL0, SDA0      PB09 TX1 SCL0, SDA0"},{"location":"boards/generic-ln882hki/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot Image 0x000000 24 KiB / 0x6000 0x006000   part_tab 0x006000 4 KiB / 0x1000 0x007000   App Image 0x007000 1.2 MiB / 0x12C000 0x133000   ota 0x133000 680 KiB / 0xAA000 0x1DD000   nvds 0x1DD000 12 KiB / 0x3000 0x1E0000   kv 0x1E0000 16 KiB / 0x4000 0x1E4000   Key-Value Store 0x1E4000 32 KiB / 0x8000 0x1EC000   user 0x1EC000 80 KiB / 0x14000 0x200000"},{"location":"boards/generic-rtl8710bn-2mb-468k/","title":"Generic - RTL8710BN (2M/468k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bn-2mb-468k</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bn-2mb-468k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bn-2mb-468k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bn-2mb-468k]\nplatform = libretiny\nboard = generic-rtl8710bn-2mb-468k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: generic-rtl8710bn-2mb-468k\n</code></pre>"},{"location":"boards/generic-rtl8710bn-2mb-468k/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA06   FCS     PA07   FD1     PA08   FD2     PA09   FD0     PA10   FSCK     PA11   FD3     PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1 CTS0 SDA0 CS0, CS1     PA22 RTS0 SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/generic-rtl8710bn-2mb-468k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 468 KiB / 0x75000 0x080000   OTA2 Image 0x080000 468 KiB / 0x75000 0x0F5000   Key-Value Store 0x0F5000 32 KiB / 0x8000 0x0FD000   User Data 0x0FD000 1 MiB / 0x102000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/generic-rtl8710bn-2mb-788k/","title":"Generic - RTL8710BN (2M/788k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bn-2mb-788k</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bn-2mb-788k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bn-2mb-788k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bn-2mb-788k]\nplatform = libretiny\nboard = generic-rtl8710bn-2mb-788k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: generic-rtl8710bn-2mb-788k\n</code></pre>"},{"location":"boards/generic-rtl8710bn-2mb-788k/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA06   FCS     PA07   FD1     PA08   FD2     PA09   FD0     PA10   FSCK     PA11   FD3     PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1 CTS0 SDA0 CS0, CS1     PA22 RTS0 SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/generic-rtl8710bn-2mb-788k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/generic-rtl8710bx-4mb-980k/","title":"Generic - RTL8710BX (4M/980k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bx-4mb-980k</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 4 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bx-4mb-980k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bx-4mb-980k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bx-4mb-980k]\nplatform = libretiny\nboard = generic-rtl8710bx-4mb-980k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: generic-rtl8710bx-4mb-980k\n</code></pre>"},{"location":"boards/generic-rtl8710bx-4mb-980k/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA06   FCS     PA07   FD1     PA08   FD2     PA09   FD0     PA10   FSCK     PA11   FD3     PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1 CTS0 SDA0 CS0, CS1     PA22 RTS0 SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/generic-rtl8710bx-4mb-980k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 4 MiB / 4,194,304 B / 0x400000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 980 KiB / 0xF5000 0x100000   OTA2 Image 0x100000 980 KiB / 0xF5000 0x1F5000   Key-Value Store 0x1F5000 32 KiB / 0x8000 0x1FD000   User Data 0x1FD000 2 MiB / 0x202000 0x3FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/generic-rtl8710bx-4mb-980k/#information","title":"Information","text":"<p>This is a generic board definition for RTL8710BX with 4 MiB of flash. It has a bigger application partition size (980 KiB). The used bootloader is also different from the standard Tuya one.</p> <p>It can be found in Ezviz T31 smart plug - bare chip soldered onto the manufacturer-made PCB. The plug is not Tuya/SmartLife-compatible and has a 25Q32CSIG flash chip. Refer to libretiny#23 for photos and more information.</p> <p>Note that stock firmware seems to use smaller app images (0x80000 / 512 KiB). After 0x180000 some product-test data and device logs can be found. Because the OTA2 offset is 0x100000, the board definition was configured to use all available space.</p>"},{"location":"boards/generic-rtl8720cf-2mb-992k/","title":"Generic - RTL8720CF (2M/992k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> </ul>    Parameter Value     Board code <code>generic-rtl8720cf-2mb-992k</code>   MCU RTL8720CF   Manufacturer Realtek   Series AmebaZ2   Frequency 100 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 20x GPIO, 8x PWM, 3x UART   Wi-Fi 802.11 b/g/n   BLE v4.2"},{"location":"boards/generic-rtl8720cf-2mb-992k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8720cf-2mb-992k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8720cf-2mb-992k]\nplatform = libretiny\nboard = generic-rtl8720cf-2mb-992k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: generic-rtl8720cf-2mb-992k\n</code></pre>"},{"location":"boards/generic-rtl8720cf-2mb-992k/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00 RX1   PWM0 SWCLK, TCK   PA01 TX1   PWM1 SWDIO, TMS   PA02 RX1 SCL0 CS0 PWM2 TDO   PA03 TX1 SDA0 SCK0 PWM3 TDI   PA04 CTS1  MOSI0 PWM4 tRST   PA07   CS0     PA08   SCK0     PA09 RTS0  MOSI0     PA10 CTS0  MISO0     PA11 TX0 SCL0  PWM0    PA12 RX0 SDA0  PWM1    PA13 RX0   PWM7    PA14 TX0   PWM2    PA15 RX2 SCL0 CS0 PWM3    PA16 TX2 SDA0 SCK0 PWM4    PA17    PWM5    PA18    PWM6    PA19 CTS2 SCL0 MOSI0 PWM7    PA20 RTS2 SDA0 MISO0 PWM0    PA23    PWM7"},{"location":"boards/generic-rtl8720cf-2mb-992k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Partition Table 0x000000 4 KiB / 0x1000 0x001000   System Data 0x001000 4 KiB / 0x1000 0x002000   Calibration 0x002000 4 KiB / 0x1000 0x003000   (reserved) 0x003000 4 KiB / 0x1000 0x004000   Boot Image 0x004000 32 KiB / 0x8000 0x00C000   OTA1 Image 0x00C000 992 KiB / 0xF8000 0x104000   OTA2 Image 0x104000 992 KiB / 0xF8000 0x1FC000   Key-Value Store 0x1FC000 16 KiB / 0x4000 0x200000"},{"location":"boards/ln-02/","title":"LN-02 Wi-Fi/BLE Module","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>ln-02</code>   MCU LN882HK   Manufacturer Lightning   Series LN882X   Frequency 160 MHz   Flash size 2 MiB   RAM size 295 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 2x UART, 3x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/ln-02/#usage","title":"Usage","text":"<p>Board code: <code>ln-02</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:ln-02]\nplatform = libretiny\nboard = ln-02\nframework = arduino\n</code></pre>"},{"location":"boards/ln-02/#pinout","title":"Pinout","text":""},{"location":"boards/ln-02/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00, ADC2        PA01, ADC3     SWDIO   PA02 TX0       PA03 RX0       PA09        PA11        PB03, ADC5        PB08 RX1       PB09 TX1"},{"location":"boards/ln-02/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot Image 0x000000 24 KiB / 0x6000 0x006000   part_tab 0x006000 4 KiB / 0x1000 0x007000   App Image 0x007000 1.2 MiB / 0x12C000 0x133000   ota 0x133000 680 KiB / 0xAA000 0x1DD000   nvds 0x1DD000 12 KiB / 0x3000 0x1E0000   kv 0x1E0000 16 KiB / 0x4000 0x1E4000   Key-Value Store 0x1E4000 32 KiB / 0x8000 0x1EC000   user 0x1EC000 80 KiB / 0x14000 0x200000"},{"location":"boards/lsc-lma35/","title":"LSC LMA35 BK7231N","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>lsc-lma35</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/lsc-lma35/#usage","title":"Usage","text":"<p>Board code: <code>lsc-lma35</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:lsc-lma35]\nplatform = libretiny\nboard = lsc-lma35\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: lsc-lma35\n</code></pre>"},{"location":"boards/lsc-lma35/#pinout","title":"Pinout","text":""},{"location":"boards/lsc-lma35/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14        P16        P21        P22        P23, ADC3        P24    PWM4    P26    PWM5"},{"location":"boards/lsc-lma35/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/lsc-lma35/#information","title":"Information","text":"<p>This board has no marking on the front side, only something that looks like PCB manufacturing info on the back; thus it was named based on these symbols.</p> <p>It can be found in 'LSC Smart Connect Outdoor LED Strip', and is likely custom-made for this product.</p> <p>The pinout was established by writing to and probing consecutive GPIOs, using the generic board definition.</p> <p>Pins marked with '?' are currently unknown, with a possibility of being CEN. Pin 22 (P1/D14) is also not confirmed.</p>"},{"location":"boards/lsc-lma35-t/","title":"LSC LMA35 BK7231T","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>lsc-lma35-t</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2"},{"location":"boards/lsc-lma35-t/#usage","title":"Usage","text":"<p>Board code: <code>lsc-lma35-t</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:lsc-lma35-t]\nplatform = libretiny\nboard = lsc-lma35-t\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: lsc-lma35-t\n</code></pre>"},{"location":"boards/lsc-lma35-t/#pinout","title":"Pinout","text":""},{"location":"boards/lsc-lma35-t/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14        P16        P21        P22        P23, ADC3        P24    PWM4    P26    PWM5"},{"location":"boards/lsc-lma35-t/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/lsc-lma35-t/#information","title":"Information","text":"<p>This board has no marking on the front side, only something that looks like PCB manufacturing info on the back; thus it was named based on these symbols.</p> <p>It can be found in 'LSC Smart Connect Outdoor LED Strip', and is likely custom-made for this product.</p> <p>The pinout was established by writing to and probing consecutive GPIOs, using the generic board definition.</p> <p>Pins marked with '?' are currently unknown, with a possibility of being CEN. Pin 22 (P1/D14) is also not confirmed.</p>"},{"location":"boards/t102-v1.1/","title":"T102_V1.1","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>t102-v1.1</code>   MCU RTL8710BN (W302)   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART   Wi-Fi 802.11 b/g/n   FCC ID 2AU7O-T102V11"},{"location":"boards/t102-v1.1/#usage","title":"Usage","text":"<p>Board code: <code>t102-v1.1</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:t102-v1.1]\nplatform = libretiny\nboard = t102-v1.1\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: t102-v1.1\n</code></pre>"},{"location":"boards/t102-v1.1/#pinout","title":"Pinout","text":""},{"location":"boards/t102-v1.1/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/t102-v1.1/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/t103-v1.0/","title":"T103_V1.0","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>t103-v1.0</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2AU7O-T102V11"},{"location":"boards/t103-v1.0/#usage","title":"Usage","text":"<p>Board code: <code>t103-v1.0</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:t103-v1.0]\nplatform = libretiny\nboard = t103-v1.0\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: t103-v1.0\n</code></pre>"},{"location":"boards/t103-v1.0/#pinout","title":"Pinout","text":""},{"location":"boards/t103-v1.0/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/t103-v1.0/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/t103-v1.0/#source","title":"Source","text":"<p>Pinout information sourced from teardown post by @p.kaczmarek2 from Elektroda.</p>"},{"location":"boards/t112-v1.1/","title":"T112_V1.1","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>t112-v1.1</code>   MCU RTL8710BN (W302)   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2AU7O-T102V11"},{"location":"boards/t112-v1.1/#usage","title":"Usage","text":"<p>Board code: <code>t112-v1.1</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:t112-v1.1]\nplatform = libretiny\nboard = t112-v1.1\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: t112-v1.1\n</code></pre>"},{"location":"boards/t112-v1.1/#pinout","title":"Pinout","text":""},{"location":"boards/t112-v1.1/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/t112-v1.1/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wa2/","title":"WA2 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wa2</code>   MCU BK7231Q   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 5x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/wa2/#usage","title":"Usage","text":"<p>Board code: <code>wa2</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wa2]\nplatform = libretiny\nboard = wa2\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wa2\n</code></pre>"},{"location":"boards/wa2/#pinout","title":"Pinout","text":""},{"location":"boards/wa2/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P4, ADC1        P6    PWM0    P7    PWM1    P8    PWM2    P10 RX1       P11 TX1       P18    PWM4    P19    PWM5    P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO"},{"location":"boards/wa2/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb02a/","title":"WB02A Wi-Fi/BLE Module","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wb02a</code>   MCU LN882HK   Manufacturer Lightning   Series LN882X   Frequency 160 MHz   Flash size 2 MiB   RAM size 295 KiB   Voltage 3.0V - 3.6V   I/O 10x GPIO, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/wb02a/#usage","title":"Usage","text":"<p>Board code: <code>wb02a</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb02a]\nplatform = libretiny\nboard = wb02a\nframework = arduino\n</code></pre>"},{"location":"boards/wb02a/#pinout","title":"Pinout","text":""},{"location":"boards/wb02a/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA01, ADC3     SWDIO   PA02 TX0       PA03 RX0       PA04, ADC4     SWCLK   PA05        PA07        PA09        PA10        PB08 RX1       PB09 TX1"},{"location":"boards/wb02a/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot Image 0x000000 24 KiB / 0x6000 0x006000   part_tab 0x006000 4 KiB / 0x1000 0x007000   App Image 0x007000 1.2 MiB / 0x12C000 0x133000   ota 0x133000 680 KiB / 0xAA000 0x1DD000   nvds 0x1DD000 12 KiB / 0x3000 0x1E0000   kv 0x1E0000 16 KiB / 0x4000 0x1E4000   Key-Value Store 0x1E4000 32 KiB / 0x8000 0x1EC000   user 0x1EC000 80 KiB / 0x14000 0x200000"},{"location":"boards/wb1s/","title":"WB1S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb1s</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB1S"},{"location":"boards/wb1s/#usage","title":"Usage","text":"<p>Board code: <code>wb1s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb1s]\nplatform = libretiny\nboard = wb1s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb1s\n</code></pre>"},{"location":"boards/wb1s/#pinout","title":"Pinout","text":""},{"location":"boards/wb1s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb1s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb2l/","title":"WB2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb2l</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB2L"},{"location":"boards/wb2l/#usage","title":"Usage","text":"<p>Board code: <code>wb2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb2l]\nplatform = libretiny\nboard = wb2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb2l\n</code></pre>"},{"location":"boards/wb2l/#pinout","title":"Pinout","text":""},{"location":"boards/wb2l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb2l-m1/","title":"WB2L_M1 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb2l-m1</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/wb2l-m1/#usage","title":"Usage","text":"<p>Board code: <code>wb2l-m1</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb2l-m1]\nplatform = libretiny\nboard = wb2l-m1\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb2l-m1\n</code></pre>"},{"location":"boards/wb2l-m1/#pinout","title":"Pinout","text":""},{"location":"boards/wb2l-m1/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb2l-m1/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb2s/","title":"WB2S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb2s</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB2S"},{"location":"boards/wb2s/#usage","title":"Usage","text":"<p>Board code: <code>wb2s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb2s]\nplatform = libretiny\nboard = wb2s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb2s\n</code></pre>"},{"location":"boards/wb2s/#pinout","title":"Pinout","text":""},{"location":"boards/wb2s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb2s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb3l/","title":"WB3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb3l</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 16x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB3L"},{"location":"boards/wb3l/#usage","title":"Usage","text":"<p>Board code: <code>wb3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb3l]\nplatform = libretiny\nboard = wb3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb3l\n</code></pre>"},{"location":"boards/wb3l/#pinout","title":"Pinout","text":""},{"location":"boards/wb3l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14   SCK     P16   MOSI     P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb3s/","title":"WB3S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wb3s</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB3S"},{"location":"boards/wb3s/#usage","title":"Usage","text":"<p>Board code: <code>wb3s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb3s]\nplatform = libretiny\nboard = wb3s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wb3s\n</code></pre>"},{"location":"boards/wb3s/#pinout","title":"Pinout","text":""},{"location":"boards/wb3s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P7    PWM1    P8    PWM2    P9    PWM3    P10 RX1       P11 TX1       P14        P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wb3s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wblc5/","title":"WBLC5 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> </ul>    Parameter Value     Board code <code>wblc5</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 3x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2"},{"location":"boards/wblc5/#usage","title":"Usage","text":"<p>Board code: <code>wblc5</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wblc5]\nplatform = libretiny\nboard = wblc5\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>bk72xx:\n  board: wblc5\n</code></pre>"},{"location":"boards/wblc5/#pinout","title":"Pinout","text":""},{"location":"boards/wblc5/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     P0 TX2 SCL2      P1 RX2 SDA2      P6    PWM0    P10 RX1       P11 TX1       P20  SCL1   TCK   P21  SDA1   TMS   P22     TDI   P23, ADC3     TDO   P24    PWM4    P26    PWM5"},{"location":"boards/wblc5/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000   Tuya Storage 0x1ED000 76 KiB / 0x13000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wl2s/","title":"WL2S Wi-Fi/BLE Module","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wl2s</code>   MCU LN882HK   Manufacturer Lightning   Series LN882X   Frequency 160 MHz   Flash size 2 MiB   RAM size 295 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 2x UART, 3x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/wl2s/#usage","title":"Usage","text":"<p>Board code: <code>wl2s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wl2s]\nplatform = libretiny\nboard = wl2s\nframework = arduino\n</code></pre>"},{"location":"boards/wl2s/#pinout","title":"Pinout","text":""},{"location":"boards/wl2s/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00, ADC2        PA01, ADC3     SWDIO   PA02 TX0       PA03 RX0       PA05        PA07        PA09        PA10        PA11        PA12        PB03, ADC5        PB08 RX1       PB09 TX1"},{"location":"boards/wl2s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot Image 0x000000 24 KiB / 0x6000 0x006000   part_tab 0x006000 4 KiB / 0x1000 0x007000   App Image 0x007000 1.2 MiB / 0x12C000 0x133000   ota 0x133000 680 KiB / 0xAA000 0x1DD000   nvds 0x1DD000 12 KiB / 0x3000 0x1E0000   kv 0x1E0000 16 KiB / 0x4000 0x1E4000   Key-Value Store 0x1E4000 32 KiB / 0x8000 0x1EC000   user 0x1EC000 80 KiB / 0x14000 0x200000"},{"location":"boards/wr1/","title":"WR1 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr1</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 10x GPIO, 5x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR1"},{"location":"boards/wr1/#usage","title":"Usage","text":"<p>Board code: <code>wr1</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr1]\nplatform = libretiny\nboard = wr1\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr1\n</code></pre>"},{"location":"boards/wr1/#pinout","title":"Pinout","text":""},{"location":"boards/wr1/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr1/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr1e/","title":"WR1E Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr1e</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 10x GPIO, 5x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR1E"},{"location":"boards/wr1e/#usage","title":"Usage","text":"<p>Board code: <code>wr1e</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr1e]\nplatform = libretiny\nboard = wr1e\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr1e\n</code></pre>"},{"location":"boards/wr1e/#pinout","title":"Pinout","text":""},{"location":"boards/wr1e/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr1e/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr2/","title":"WR2 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2"},{"location":"boards/wr2/#usage","title":"Usage","text":"<p>Board code: <code>wr2</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2]\nplatform = libretiny\nboard = wr2\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr2\n</code></pre>"},{"location":"boards/wr2/#pinout","title":"Pinout","text":""},{"location":"boards/wr2/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr2/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr2e/","title":"WR2E Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2e</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 4x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2E"},{"location":"boards/wr2e/#usage","title":"Usage","text":"<p>Board code: <code>wr2e</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2e]\nplatform = libretiny\nboard = wr2e\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr2e\n</code></pre>"},{"location":"boards/wr2e/#pinout","title":"Pinout","text":""},{"location":"boards/wr2e/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1   CS0, CS1     PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2   PWM4"},{"location":"boards/wr2e/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr2l/","title":"WR2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2l</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 5x GPIO, 4x PWM, 1x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2L"},{"location":"boards/wr2l/#usage","title":"Usage","text":"<p>Board code: <code>wr2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2l]\nplatform = libretiny\nboard = wr2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr2l\n</code></pre>"},{"location":"boards/wr2l/#pinout","title":"Pinout","text":""},{"location":"boards/wr2l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA19, ADC1"},{"location":"boards/wr2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr2le/","title":"WR2LE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2le</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 5x GPIO, 5x PWM, 1x UART   Wi-Fi 802.11 b/g/n"},{"location":"boards/wr2le/#usage","title":"Usage","text":"<p>Board code: <code>wr2le</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2le]\nplatform = libretiny\nboard = wr2le\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr2le\n</code></pre>"},{"location":"boards/wr2le/#pinout","title":"Pinout","text":""},{"location":"boards/wr2le/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA22    PWM5"},{"location":"boards/wr2le/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr3/","title":"WR3 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3"},{"location":"boards/wr3/#usage","title":"Usage","text":"<p>Board code: <code>wr3</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3]\nplatform = libretiny\nboard = wr3\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr3\n</code></pre>"},{"location":"boards/wr3/#pinout","title":"Pinout","text":""},{"location":"boards/wr3/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr3/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr3e/","title":"WR3E Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3e</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3E"},{"location":"boards/wr3e/#usage","title":"Usage","text":"<p>Board code: <code>wr3e</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3e]\nplatform = libretiny\nboard = wr3e\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr3e\n</code></pre>"},{"location":"boards/wr3e/#pinout","title":"Pinout","text":""},{"location":"boards/wr3e/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr3e/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr3l/","title":"WR3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3l</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3L"},{"location":"boards/wr3l/#usage","title":"Usage","text":"<p>Board code: <code>wr3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3l]\nplatform = libretiny\nboard = wr3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr3l\n</code></pre>"},{"location":"boards/wr3l/#pinout","title":"Pinout","text":""},{"location":"boards/wr3l/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr3le/","title":"WR3LE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3le</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3LE"},{"location":"boards/wr3le/#usage","title":"Usage","text":"<p>Board code: <code>wr3le</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3le]\nplatform = libretiny\nboard = wr3le\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr3le\n</code></pre>"},{"location":"boards/wr3le/#pinout","title":"Pinout","text":""},{"location":"boards/wr3le/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA19, ADC1  SDA0 CS0, CS1     PA22  SCL0 MISO0, MISO1 PWM5    PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr3le/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"boards/wr3n/","title":"WR3N Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>Info &amp; flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3n</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3N"},{"location":"boards/wr3n/#usage","title":"Usage","text":"<p>Board code: <code>wr3n</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3n]\nplatform = libretiny\nboard = wr3n\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>rtl87xx:\n  board: wr3n\n</code></pre>"},{"location":"boards/wr3n/#pinout","title":"Pinout","text":""},{"location":"boards/wr3n/#pin-functions","title":"Pin functions","text":"Name(s) UART I\u00b2C SPI PWM Other     PA00    PWM2    PA05    PWM4    PA12    PWM3    PA14    PWM0 SWCLK   PA15    PWM1 SWDIO   PA18 RX0 SCL1 SCK0, SCK1     PA23 TX0 SDA1 MOSI0, MOSI1 PWM0    PA29 RX2 SCL0  PWM4    PA30 TX2 SDA0  PWM4"},{"location":"boards/wr3n/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 32 KiB / 0x8000 0x19D000   User Data 0x19D000 392 KiB / 0x62000 0x1FF000   Tuya Storage 0x1EB000 84 KiB / 0x15000 0x200000   RDP 0x1FF000 4 KiB / 0x1000 0x200000"},{"location":"cores/realtek-ambz/base/fixups/lib_rtlstd_patch/","title":"lib_rtlstd_patch.a","text":"<pre><code>arm-none-eabi-gcc-ar xo lib_rtlstd.a\nrm rtl_eabi_cast_ram.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded ram_libc.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded ram_libgloss_retarget.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded rtl_math_ram.o\narm-none-eabi-gcc-ar qs lib_rtlstd_patch.a *.o\n</code></pre>"},{"location":"docs/","title":"Documentation","text":"<p>This documentation is best suited for rendering with MkDocs. Some elements may not display correctly in the GitHub markdown reader.</p> <p>Please visit https://docs.libretiny.eu/ for the full experience.</p> <p>If you still want to read the docs on GitHub, visit SUMMARY.md.</p>"},{"location":"docs/TODO/","title":"TODO list","text":""},{"location":"docs/TODO/#general","title":"General","text":""},{"location":"docs/TODO/#environment-stability","title":"Environment stability","text":"<p>Do not publish any SDK functions, macros, defines and includes. Define only what's needed in LT's public headers (like <code>Arduino.h</code>). Everything else is taken from <code>sdk_extern.h</code> or <code>WVariant.h</code> (TODO decide whether to keep WV public / make both private / get rid of WV and use sdk_extern only). Private headers are included by LT's .cpp units (maybe a dedicated private header that would include sdk_extern + Arduino.h).</p> <p>Developers wanting to use SDK functions need to include them.</p> <p>Explicit is better than implicit.</p> <ul> <li>consider moving to C++17 (GNU)? or any newer than C++11</li> <li>wrap all memory management functions (malloc, calloc, free, memset, etc.) and their vendor SDK counterparts to use FreeRTOS instead<ul> <li>pretty much done for ambz and ambz2, Beken is yet left to do (<code>os_malloc()</code> etc.)</li> </ul> </li> <li>remove all network protocol client/server implementations from SDKs (mDNS, HTTP, DNS, etc.)</li> </ul>"},{"location":"docs/TODO/#new-families","title":"New families","text":"<ul> <li>BL602</li> <li>RTL8710A</li> <li>RTL8720C</li> <li>RTL8720D</li> <li>W600 and/or W800</li> <li>LN8825</li> <li>BK7231Q</li> <li>host-native family</li> </ul>"},{"location":"docs/TODO/#tools","title":"Tools","text":"<ul> <li>write OpenOCD flashers, using uf2ota library + FAL for partitions (in ltchiptool repository)</li> </ul>"},{"location":"docs/TODO/#development","title":"Development","text":"<ul> <li>write Contributor's Guide</li> <li>export LT cores in an Arduino IDE-compatible format (automatically - GitHub Actions)</li> <li>consider using precompiled SDK blobs for improved build speed (especially on e.g. Raspberry Pi)</li> </ul>"},{"location":"docs/TODO/#serial","title":"Serial","text":"<ul> <li>configuration of RX/TX pins</li> <li>SoftwareSerial library - receiving + Beken family</li> </ul>"},{"location":"docs/TODO/#other","title":"Other","text":"<ul> <li>implement Wire on BK, refactor the API and class</li> <li>watchdog API</li> <li><code>Preferences</code> library</li> <li>test/fix IPv6 on different families</li> <li>what is <code>PowerManagement</code> at all? probably useless -&gt; remove</li> </ul>"},{"location":"docs/TODO/#bk7231","title":"BK7231","text":"<ul> <li>fix WiFi on BK7231N, test other functionality</li> <li>fix SSL (mbedTLS)</li> <li>I2C (Wire)</li> <li>SPI</li> <li>BLE</li> </ul>"},{"location":"docs/TODO/#rtl8710b","title":"RTL8710B","text":"<ul> <li>take all stdio functions from stdio.h</li> <li>rewrite most of Wiring (it was copied from <code>ambd_arduino</code>, and is ugly)</li> </ul>"},{"location":"docs/contrib/lt-api-functions/","title":"Lt api functions","text":"Type Function Common Weak Family     <code>const char *</code> lt_cpu_get_core_type()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_config_timer()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_enter()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_keep_floating_gpio()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_unset_gpio()   \u2714\ufe0f   <code>lt_flash_id_t</code> lt_flash_get_id()   \u2714\ufe0f   <code>void</code> lt_get_device_mac()   \u2714\ufe0f   <code>uint32_t</code> lt_heap_get_size()   \u2714\ufe0f   <code>void</code> lt_init_arduino()   \u2714\ufe0f   <code>void</code> lt_init_family()   \u2714\ufe0f   <code>void</code> lt_init_variant()   \u2714\ufe0f   <code>uint8_t</code> lt_ota_dual_get_current()   \u2714\ufe0f   <code>uint8_t</code> lt_ota_dual_get_stored()   \u2714\ufe0f   <code>lt_ota_type_t</code> lt_ota_get_type()   \u2714\ufe0f   <code>bool</code> lt_ota_is_valid()   \u2714\ufe0f   <code>bool</code> lt_ota_switch()   \u2714\ufe0f   <code>uint32_t</code> lt_ram_get_size()   \u2714\ufe0f   <code>uint8_t</code> lt_cpu_get_core_count()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_cycle_count()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_freq()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_mac_id()  \u2714\ufe0f    <code>lt_cpu_model_t</code> lt_cpu_get_model()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_unique_id()  \u2714\ufe0f    <code>void</code> lt_deep_sleep_config_gpio()  \u2714\ufe0f    <code>uint32_t</code> lt_flash_get_size()  \u2714\ufe0f    <code>lt_reboot_reason_t</code> lt_get_reboot_reason()  \u2714\ufe0f    <code>void</code> lt_gpio_recover()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_free()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_max_alloc()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_min_free()  \u2714\ufe0f    <code>void</code> lt_ota_set_write_protect()  \u2714\ufe0f    <code>void</code> lt_reboot()  \u2714\ufe0f    <code>bool</code> lt_reboot_download_mode()  \u2714\ufe0f    <code>bool</code> lt_reboot_wdt()  \u2714\ufe0f    <code>bool</code> lt_set_debug_mode()  \u2714\ufe0f    <code>void</code> lt_wdt_disable()  \u2714\ufe0f    <code>bool</code> lt_wdt_enable()  \u2714\ufe0f    <code>void</code> lt_wdt_feed()  \u2714\ufe0f    <code>void</code> hexdump() \u2714\ufe0f     <code>char *</code> lt_btox() \u2714\ufe0f     <code>lt_cpu_family_t</code> lt_cpu_get_family() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_family_name() \u2714\ufe0f     <code>uint32_t</code> lt_cpu_get_freq_mhz() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_model_code() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_model_name() \u2714\ufe0f     <code>bool</code> lt_flash_erase() \u2714\ufe0f     <code>bool</code> lt_flash_erase_block() \u2714\ufe0f     <code>uint32_t</code> lt_flash_read() \u2714\ufe0f     <code>uint32_t</code> lt_flash_write() \u2714\ufe0f     <code>const char *</code> lt_get_board_code() \u2714\ufe0f     <code>const char *</code> lt_get_device_name() \u2714\ufe0f     <code>const char *</code> lt_get_reboot_reason_name() \u2714\ufe0f     <code>const char *</code> lt_get_version() \u2714\ufe0f     <code>void</code> lt_ota_begin() \u2714\ufe0f     <code>bool</code> lt_ota_can_rollback() \u2714\ufe0f     <code>bool</code> lt_ota_end() \u2714\ufe0f     <code>uf2_ota_scheme_t</code> lt_ota_get_uf2_scheme() \u2714\ufe0f     <code>size_t</code> lt_ota_write() \u2714\ufe0f     <code>bool</code> lt_ota_write_block() \u2714\ufe0f     <code>void</code> lt_rand_bytes() \u2714\ufe0f     <code>uint8_t *</code> lt_xtob() \u2714\ufe0f"},{"location":"docs/contrib/lt-api/","title":"API functions guide","text":"<p>The LibreTiny C API functions are split between three types: common, weak and family.</p> <ul> <li>Common functions are implemented in the base, common core and are the same between all families.</li> <li>Weak functions are provided in the common core, but can (and sometimes should) be overridden by family cores. They sometimes provide usable default implementations (which can be overriden to provide e.g. a better way to do something), otherwise they're empty (e.g. if a family doesn't support such a feature).</li> <li>Family functions are not provided in the common core and have to be implemented in the family core.</li> </ul> <p>A quick outline of all available functions and their types:</p>     Type Function Common Weak Family     <code>const char *</code> lt_cpu_get_core_type()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_config_timer()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_enter()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_keep_floating_gpio()   \u2714\ufe0f   <code>void</code> lt_deep_sleep_unset_gpio()   \u2714\ufe0f   <code>lt_flash_id_t</code> lt_flash_get_id()   \u2714\ufe0f   <code>void</code> lt_get_device_mac()   \u2714\ufe0f   <code>uint32_t</code> lt_heap_get_size()   \u2714\ufe0f   <code>void</code> lt_init_arduino()   \u2714\ufe0f   <code>void</code> lt_init_family()   \u2714\ufe0f   <code>void</code> lt_init_variant()   \u2714\ufe0f   <code>uint8_t</code> lt_ota_dual_get_current()   \u2714\ufe0f   <code>uint8_t</code> lt_ota_dual_get_stored()   \u2714\ufe0f   <code>lt_ota_type_t</code> lt_ota_get_type()   \u2714\ufe0f   <code>bool</code> lt_ota_is_valid()   \u2714\ufe0f   <code>bool</code> lt_ota_switch()   \u2714\ufe0f   <code>uint32_t</code> lt_ram_get_size()   \u2714\ufe0f   <code>uint8_t</code> lt_cpu_get_core_count()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_cycle_count()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_freq()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_mac_id()  \u2714\ufe0f    <code>lt_cpu_model_t</code> lt_cpu_get_model()  \u2714\ufe0f    <code>uint32_t</code> lt_cpu_get_unique_id()  \u2714\ufe0f    <code>void</code> lt_deep_sleep_config_gpio()  \u2714\ufe0f    <code>uint32_t</code> lt_flash_get_size()  \u2714\ufe0f    <code>lt_reboot_reason_t</code> lt_get_reboot_reason()  \u2714\ufe0f    <code>void</code> lt_gpio_recover()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_free()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_max_alloc()  \u2714\ufe0f    <code>uint32_t</code> lt_heap_get_min_free()  \u2714\ufe0f    <code>void</code> lt_ota_set_write_protect()  \u2714\ufe0f    <code>void</code> lt_reboot()  \u2714\ufe0f    <code>bool</code> lt_reboot_download_mode()  \u2714\ufe0f    <code>bool</code> lt_reboot_wdt()  \u2714\ufe0f    <code>bool</code> lt_set_debug_mode()  \u2714\ufe0f    <code>void</code> lt_wdt_disable()  \u2714\ufe0f    <code>bool</code> lt_wdt_enable()  \u2714\ufe0f    <code>void</code> lt_wdt_feed()  \u2714\ufe0f    <code>void</code> hexdump() \u2714\ufe0f     <code>char *</code> lt_btox() \u2714\ufe0f     <code>lt_cpu_family_t</code> lt_cpu_get_family() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_family_name() \u2714\ufe0f     <code>uint32_t</code> lt_cpu_get_freq_mhz() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_model_code() \u2714\ufe0f     <code>const char *</code> lt_cpu_get_model_name() \u2714\ufe0f     <code>bool</code> lt_flash_erase() \u2714\ufe0f     <code>bool</code> lt_flash_erase_block() \u2714\ufe0f     <code>uint32_t</code> lt_flash_read() \u2714\ufe0f     <code>uint32_t</code> lt_flash_write() \u2714\ufe0f     <code>const char *</code> lt_get_board_code() \u2714\ufe0f     <code>const char *</code> lt_get_device_name() \u2714\ufe0f     <code>const char *</code> lt_get_reboot_reason_name() \u2714\ufe0f     <code>const char *</code> lt_get_version() \u2714\ufe0f     <code>void</code> lt_ota_begin() \u2714\ufe0f     <code>bool</code> lt_ota_can_rollback() \u2714\ufe0f     <code>bool</code> lt_ota_end() \u2714\ufe0f     <code>uf2_ota_scheme_t</code> lt_ota_get_uf2_scheme() \u2714\ufe0f     <code>size_t</code> lt_ota_write() \u2714\ufe0f     <code>bool</code> lt_ota_write_block() \u2714\ufe0f     <code>void</code> lt_rand_bytes() \u2714\ufe0f     <code>uint8_t *</code> lt_xtob() \u2714\ufe0f"},{"location":"docs/contrib/porting/","title":"Porting new families","text":"<p>This document briefly outlines what needs to be done, in order to port a new chip family to LibreTiny.</p>"},{"location":"docs/contrib/porting/#base-framework-builders","title":"Base framework + builders","text":"<p>The base framework is the core part, that provides little functionality and a small HAL (over some things like OTA or sys control). It also includes a builder script for the vendor SDK.</p> <p>Here's what has to be done to make that work:</p> <ol> <li>Find vendor SDK - should be self-explanatory. We can't work without a working SDK (yet).</li> <li> <p>Test vendor SDK - compile a sample program \"as it was meant to be done\".</p> <ul> <li>Most SDKs provide some example programs (like Hello World, WiFi scanning, etc.) that can usually be compiled by running a single \"make\" command.</li> <li>Sometimes you need to configure your environment in a weird and complicated way. For me, using Cygwin on Windows was usually enough, though.</li> <li>You need to flash this to the chip as well. The SDK usually bundles some flashing tools.</li> <li>This step is crucial to understand the vendor build system, and to have working binaries to compare out results against.</li> </ul> </li> <li> <p>\"Clean up\" vendor SDK.</p> <ul> <li>SDKs usually bundle entire compiler toolchains, which can take up hundreds of megabytes. We want to keep the downloaded PlatformIO packages as small as possible.</li> <li>On existing families, GitHub Workflows produce the packages by removing some files and adding <code>package.json</code> to them. See framework-beken-bdk/.github/workflows/platformio-package.yml for an example.</li> </ul> </li> <li> <p>Write base family and board definitions.</p> <ul> <li><code>families.json</code> needs to have the new family added to it.</li> <li><code>platform.json</code> needs to know the vendor SDK repository.</li> <li>Add any boards and base JSONs to the <code>boards/</code> directory. It's easiest to start with generic boards.</li> <li>Use <code>boardgen ltci</code> to generate variant sources (.c and .h).</li> </ul> </li> <li> <p>Add base core code.</p> <ul> <li><code>lt_defs.h</code>, <code>lt_family.h</code> and <code>lt_api.c</code> files need to be created, and initialized with (even empty) functions and definitions.</li> <li>The list of family functions can be found here.</li> <li>Make the SDK call <code>lt_main()</code> as the entrypoint. If needed, use fixups.</li> </ul> </li> <li> <p>Write a binary manipulation tool.</p> <ul> <li>While this step could be optional, as these tools are provided in the SDK, they're usually platform-specific (i.e. Windows-only) and use proprietary executables, with no source code nor documentation. This is unacceptable for LibreTiny, as we need to support multiple architectures &amp; platforms (Windows, Linux, Raspberry Pi, etc.). Naturally, doing that in Python seems to be the best choice.</li> <li>All binary tools are currently in ltchiptool/soc/.../binary.py. The <code>elf2bin()</code> function is what takes an .ELF file, and generates a set of binaries that can be flashed to the chip.</li> <li>It's best to test if the generation is correct, by taking an .ELF compiled by vendor SDK, running it through ltchiptool and checking if the resulting binaries are identical.</li> <li>Ghidra/IDA Pro is your friend here; you can decompile the SDK tools.</li> </ul> </li> <li> <p>Write a flashing tool.</p> <ul> <li>mostly the same as above. Refer to the existing tools for examples. It's useful to make the flasher class \"standalone\", i.e. a class that is then wrapped by ltchiptool, like in <code>realtek-ambz2</code>.</li> </ul> </li> <li> <p>Write builder scripts.</p> <ul> <li><code>builder/family/xxx.py</code> files are builders, which contain all SDK sources and include paths. Write the script, based on the existing families, and any Makefiles or other scripts from the SDK.</li> <li>Make sure not to make a mess in the <code>CCFLAGS</code>/<code>CPPDEFINES</code>, and only include what's needed there. Some flags are project-wide (family-independent) in <code>builder/frameworks/base.py</code>.</li> <li>Use a pure PlatformIO project - not ESPHome!. Pass one of the generic boards you created before, and <code>framework = base</code> in <code>platformio.ini</code>. Generally, try to get the thing to compile.</li> <li>Use a simple Hello World program - C, not C++. Only add <code>main()</code> function with a <code>printf()</code> and a <code>while(1)</code> loop.</li> <li>I've noticed that using <code>nano.specs</code> instead of <code>nosys.specs</code> produces smaller binaries.</li> </ul> </li> <li> <p>When you get it to link successfully, build a UF2 file.</p> <ul> <li>UF2 packages are for flashing and for OTA.</li> <li>Add <code>UF2OTA</code> to the env, to provide binaries that will go to the UF2. Some understanding of the chip's partition and flash layout will be needed.</li> </ul> </li> <li> <p>Flash it, test if it works!</p> <ul> <li>It probably won't. You may need to remove <code>__libc_init_array()</code> from <code>cores/common/base/lt_api.c</code> so that it doesn't crash. Most SDKs don't support C++ properly.</li> </ul> </li> </ol>"},{"location":"docs/contrib/porting/#making-it-actually-work","title":"Making it actually work","text":"<ol> <li> <p>Write <code>flashdb</code> and <code>printf</code> ports.</p> <ul> <li>The ports are in <code>cores/.../base/port/</code>. It's a simple flash access layer, and a character printing function. Not a lot of work, but it needs to be done first.</li> </ul> </li> <li> <p>Add fixups so that string &amp; memory stdlib functions are not from SDK.</p> <ul> <li>Refer to stdlib.md to find functions that need to be wrapped.</li> <li>SDK should not define them, you have to figure out a way to remove them from headers. Fixups can mess with includes and trick the SDK into using our own functions.</li> </ul> </li> <li> <p>Clean up FreeRTOS.</p> <ul> <li>FreeRTOS' headers usually include some SDK headers, which pull in a lot of macros and typedefs, which usually break lots of non-SDK code, which doesn't expect these macros.</li> <li>library-freertos repo contains some FreeRTOS versions, adapted for SDKs. Basically, copy a clean (straight from FreeRTOS github) version to the repo, commit it. Then copy the version from SDK and compare the differences.</li> <li>Try to make it look as \"stock\" as possible. Discard any formatting differences (and backports).</li> <li>Annotate any parts that can't be removed with <code>#ifdef FREERTOS_PORT_REALTEK_AMB1</code>.</li> <li>Put the FreeRTOS vendor-specific port in library-freertos-port.</li> <li>Remove all FreeRTOS sources from builder scripts. Replace with:</li> </ul> <pre><code>env.Replace(FREERTOS_PORT=env[\"FAMILY_NAME\"], FREERTOS_PORT_DEFINE=\"REALTEK_AMB1\")\nqueue.AddExternalLibrary(\"freertos\")\nqueue.AddExternalLibrary(\"freertos-port\")\n</code></pre> </li> <li> <p>Do the same with lwIP - later.</p> </li> <li> <p>Write LibreTiny C APIs - in <code>lt_api.c</code>.</p> </li> <li> <p>At this point, your Hello World code should work fine.</p> </li> </ol>"},{"location":"docs/contrib/porting/#porting-arduino-core-c-support","title":"Porting Arduino Core - C++ support","text":"<ol> <li> <p>Add main.cpp and write wiring_*.c ports. GPIOs and stuff should work even without proper C++ support.</p> </li> <li> <p>Port Serial library first. This should already show whether C++ works fine or if it doesn't. For example, calling <code>Serial.println()</code> refers to the virtual function <code>Print::write</code>, which will probably crash the chip if C++ is not being linked properly.</p> </li> </ol>"},{"location":"docs/contrib/project-structure/","title":"Project structure","text":"<pre><code>arduino/\n\u251c\u2500 &lt;family name&gt;/               Arduino Core for a specific SoC family\n\u2502  \u251c\u2500 cores/                        Wiring core files\n\u2502  \u251c\u2500 libraries/                    Supported built-in family libraries\n\u2502  \u251c\u2500 port/                     External library port units\n\u251c\u2500 libretiny/\n\u2502  \u251c\u2500 api/                      Library interfaces\n\u2502  \u251c\u2500 common/                   Units common to all families\n\u2502  \u251c\u2500 compat/                   Fixes for compatibility with ESP32 framework\n\u2502  \u251c\u2500 core/                     LibreTiny API for Arduino cores\n\u2502  \u251c\u2500 libraries/                Built-in family-independent libraries\n|  \u251c\u2500 port/                     External library port units\n|  \u251c\u2500 posix/                    POSIX-like C utility functions\nboards/\n\u251c\u2500 _base/                       Base board manifests\n\u251c\u2500 &lt;board name&gt;/                Board-specific code\n\u2502  \u251c\u2500 variant.cpp                   Arduino variant initialization\n\u2502  \u251c\u2500 variant.h                     Arduino variant pin configs\n\u251c\u2500 &lt;board name&gt;.json            PlatformIO board description\nbuilder/\n\u251c\u2500 frameworks/                  Framework builders for PlatformIO\n\u2502  \u251c\u2500 &lt;family name&gt;-sdk.py          Vanilla SDK build system\n\u2502  \u251c\u2500 &lt;family name&gt;-arduino.py      Arduino Core build system\n\u251c\u2500 libs/                        Builders for external libraries\n\u251c\u2500 utils/                       SCons utils used during the build\n\u251c\u2500 arduino-common.py            Builder to provide ArduinoCore-API and LibreTiny APIs\n\u251c\u2500 main.py                      Main PlatformIO builder\ndocs/                           Project documentation, guides, tips, etc.\nplatform/\n\u251c\u2500 &lt;family name&gt;/               Family-specific configurations\n\u2502  \u251c\u2500 bin/                          Binary blobs (bootloaders, etc.)\n\u2502  \u251c\u2500 fixups/                       Code fix-ups to replace SDK parts\n\u2502  \u251c\u2500 ld/                           Linker scripts\n\u2502  \u251c\u2500 openocd/                      OpenOCD configuration files\ntools/\n\u251c\u2500 &lt;tool name&gt;/                     Tools used during the build\n\u251c\u2500 util/                            Utilities used by CLI tools and the builders\nfamilies.json                   List of supported device families\nplatform.json                   PlatformIO manifest\nplatform.py                     Custom PlatformIO script\n</code></pre>"},{"location":"docs/contrib/stdlib/","title":"C stdlib","text":"<p>Usually, functions available in C standard library should not be defined by the SDK. Instead, they should be included using GCC's headers, and implemented by the libc or wrapped and implemented in the SDK.</p> <p>The following functions should not be defined by the SDK. Their presence creates conflicts due to incompatibility with C library, so they should be removed or disabled, and replaced with wrappers.</p> <p>Memory management functions must be wrapped and redirected to FreeRTOS. The necessary linker flags are already added for all families (in <code>base.py</code>), and a FreeRTOS implementation of the wrappers are provided in <code>malloc.c</code> in the common core. If the family doesn't use FreeRTOS, a separate implementation must be added.</p> <p>Additionally, if the <code>printf</code> library is used in the chip family code, all other vendor-defined printf-like functions should be replaced with it.</p> <p>Function prototypes taken from devdocs.io.</p> <pre><code>// stdlib.h / Dynamic memory management\nvoid *calloc(size_t num, size_t size);\nvoid *malloc(size_t size);\nvoid *realloc(void *ptr, size_t new_size);\nvoid free(void *ptr);\n// stdlib.h / Conversions to numeric formats\ndouble atof(const char *str);\nint atoi(const char *str);\nlong atol(const char *str);\nlong long atoll(const char *str);\ndouble strtod(const char *str, char **str_end);\nfloat strtof(const char *str, char **str_end);\nlong strtol(const char *str, char **str_end, int base);\nlong double strtold(const char *str, char **str_end);\nlong long strtoll(const char *str, char **str_end, int base);\nunsigned long strtoul(const char *str, char **str_end, int base);\nunsigned long long strtoull(const char *str, char **str_end, int base);\n// stdlib.h / Random numbers\nint rand();\n\n// string.h / Character classification\nint isalnum(int ch);\nint isalpha(int ch);\nint islower(int ch);\nint isupper(int ch);\nint isdigit(int ch);\nint isxdigit(int ch);\nint iscntrl(int ch);\nint isgraph(int ch);\nint isspace(int ch);\nint isblank(int ch);\nint isprint(int ch);\nint ispunct(int ch);\nint tolower(int ch);\nint toupper(int ch);\n// string.h / String manipulation\nchar *strcat(char *dest, const char *src);\nchar *strcpy(char *dest, const char *src);\nchar *strncat(char *dest, const char *src, size_t count);\nchar *strncpy(char *dest, const char *src, size_t count);\nsize_t strxfrm(char *dest, const char *src, size_t count);\n// string.h / String examination\nchar *strchr(const char *str, int ch);\nint strcmp(const char *lhs, const char *rhs);\nsize_t strcspn(const char *dest, const char *src);\nsize_t strlen(const char *str);\nint strncmp(const char *lhs, const char *rhs, size_t count);\nchar *strpbrk(const char *dest, const char *breakset);\nchar *strrchr(const char *str, int ch);\nsize_t strspn(const char *dest, const char *src);\nchar *strstr(const char *str, const char *substr);\nchar *strtok(char *str, const char *delim);\n// string.h / Character array manipulation\nvoid *memchr(const void *ptr, int ch, size_t count);\nint memcmp(const void *lhs, const void *rhs, size_t count);\nvoid *memcpy(void *dest, const void *src, size_t count);\nvoid *memmove(void *dest, const void *src, size_t count);\nvoid *memset(void *dest, int ch, size_t count);\n\n// stdio.h / Unformatted input/output\nint putc(int ch, FILE *stream);\nint putchar(int ch);\nint puts(const char *str);\n\n// stdio.h / Formatted input/output\nint printf(const char *format, ...);\nint sprintf(char *buffer, const char *format, ...);\nint snprintf(char *buffer, size_t bufsz, const char *format, ...);\nint vprintf(const char *format, va_list vlist);\nint vsprintf(char *buffer, const char *format, va_list vlist);\nint vsnprintf(char *buffer, size_t bufsz, const char *format, va_list vlist);\n\n// POSIX/BSD (from www.die.net)\nsize_t strlcat(char *dst, const char *src, size_t size);\nsize_t strlcpy(char *dst, const char *src, size_t size);\nsize_t strnlen(const char *s, size_t maxlen);\nchar *strsep(char **stringp, const char *delim);\n\n// Non-stdlib\n_calloc_r\n_free_r\n_malloc_r\n_realloc_r\natoui\natoul\natoull\nstrnicmp\nzalloc\n\n// Additional forbidden macros\n#define max(a, b)\n#define min(a, b)\ntypedef bool boolean;\n</code></pre>"},{"location":"docs/contrib/ota/","title":"UF2-based OTA","text":"<p>LibreTiny's OTA updating is based on Microsoft's UF2 specification. Some aspects of the process, such as OTA1/2 support and target partition selection, have been customized with extension tags.</p>  <p>Note</p> <p>Just like in UF2, all values in this format are little-endian.</p>"},{"location":"docs/contrib/ota/#firmware-images","title":"Firmware images","text":"<p>UF2 files may contain multiple firmware images that are to be flashed, i.e. main firmware + bootloader + some config partition.</p> <p>Some CPUs support dual-OTA schemes: firmware runs from one image, while the other one is reserved for updated firmware. After applying the update, a reboot causes to run the other image instead.</p> <p>Each firmware image may be either applicable:</p> <ol> <li>only when flashing OTA1 (<code>part;file;;</code>)</li> <li>only when flashing OTA2 (<code>;;part;file</code>)</li> <li>for both schemes to a single partition (<code>part;file</code>)</li> <li>for both schemes but different partitions (<code>part1;file;part2;file</code>)</li> <li>for both schemes but with a different binary (<code>part;file1;part;file2</code>)</li> <li>for both schemes, with different binaries and target partitions (<code>part1;file1;part2;file2</code>)</li> </ol> <p>* <code>part</code> means partition here</p> <p>** values in parentheses show the input format to use for <code>uf2ota.py</code></p> <p>For easier understanding, these update types will be referred to in this document using the numbers.</p>"},{"location":"docs/contrib/ota/#extension-tags","title":"Extension tags","text":"<p>Standard tags are used: <code>VERSION</code>, <code>DEVICE</code> and <code>DEVICE_ID</code>.</p> <p>Additionally, custom tags are defined:</p>    Name ID Type Description     <code>OTA_VERSION</code> 0x5D57D0 int 8-bit format version (for simple compatibility checks)   <code>BOARD</code> 0xCA25C8 string board name / code (lowercase)   <code>FIRMWARE</code> 0x00DE43 string firmware description / name   <code>BUILD_DATE</code> 0x822F30 int 32-bit build date/time as Unix timestamp   <code>LT_VERSION</code> 0x59563D semver LT version   <code>LT_PART_1</code> 0x805946 string OTA1 partition name   <code>LT_PART_2</code> 0xA1E4D7 string OTA2 partition name   <code>LT_HAS_OTA1</code> 0xBBD965 bool 8-bit image has any data for OTA1   <code>LT_HAS_OTA2</code> 0x92280E bool 8-bit image has any data for OTA2   <code>LT_BINPATCH</code> 0xB948DE bytes binary patch to convert OTA1-&gt;OTA2"},{"location":"docs/contrib/ota/#update-types","title":"Update types","text":""},{"location":"docs/contrib/ota/#single-ota-scheme-1-2","title":"Single OTA scheme (1, 2)","text":"<p>Image is ignored if the OTA scheme does not match. UF2 has <code>LT_PART_1</code> or <code>LT_PART_2</code> set to target partition name. The other partition tag is present, but empty (0 bytes).</p> <pre><code>08 46 59 80 6f 74 61 31 | .FY.ota1 | LT_PART_1\n04 d7 e4 a1             | ....     | LT_PART_2\n</code></pre>"},{"location":"docs/contrib/ota/#dual-otasingle-file-scheme-3-4","title":"Dual-OTA/single-file scheme (3, 4)","text":"<p>One image is used for both OTA schemes. UF2 has <code>LT_PART_1</code> and <code>LT_PART_2</code> tags set. For type <code>3</code> these two tags contain the same partition name.</p> <pre><code>08 46 59 80 6f 74 61 31 | .FY.ota1 | LT_PART_1\n08 d7 e4 a1 6f 74 61 32 | ....ota2 | LT_PART_2\n</code></pre>"},{"location":"docs/contrib/ota/#dual-otadual-file-scheme-5-6","title":"Dual-OTA/dual-file scheme (5, 6)","text":"<p>Just like types <code>3</code> and <code>4</code>, UF2 has two partition tags set. For type <code>5</code> they have the same name.</p> <p>The image stored in UF2 is meant for OTA1 scheme. There is an additional tag <code>LT_BINPATCH</code> present. In OTA1 flashing scheme, it is ignored.</p>"},{"location":"docs/contrib/ota/#binary-patching","title":"Binary patching","text":"<p>OTA2 images are not stored directly, as that would needlessly double the UF2 file size. Instead, binary patching instructions, embedded into the extension tags area, allow the CPU to convert the OTA1 image from UF2 into OTA2 image.</p> <p>There can be at most one binpatch tag in a UF2 block. It has the following format:</p> <ul> <li>opcode (1 byte) - operation type:<ul> <li><code>DIFF32</code> (0xFE) - difference between 32-bit values</li> </ul> </li> <li>length (1 byte) - data length</li> <li>data (<code>length</code> bytes)<ul> <li>for <code>DIFF32</code>:<ul> <li>difference value (signed int 32-bit)</li> <li>offset table (<code>length-4</code> bytes)</li> </ul> </li> </ul> </li> </ul> <p>The presented structure can be repeated in a single binpatch tag.</p>"},{"location":"docs/contrib/ota/#diff32","title":"DIFF32","text":"<p>This method works by adding the difference value to a 32-bit integer. It allows to save the most space in OTA1/2 image scenarios, where the only different values are, for example, flash memory addresses. The offset table contains positions within the 256-byte block, to which the difference value should be mathematically added.</p> <p>For a block like: <pre><code>000  72 71 73 61 76 65 00 00  5f 66 72 65 65 72 74 6f  |rqsave.._freerto|\n010  73 5f 6d 75 74 65 78 5f  67 65 74 5f 74 69 6d 65  |s_mutex_get_time|\n020  6f 75 74 00 5d a4 03 08  61 a4 03 08 85 a4 03 08  |out.]...a.......|\n030  5d a4 03 08 61 a4 03 08  85 a4 03 08 81 a9 03 08  |]...a...........|\n040  6d a9 03 08 7d a4 03 08  d9 a8 03 08 05 a7 03 08  |m...}...........|\n050  bd a4 03 08 ad a8 03 08  59 a7 03 08 9d a8 03 08  |........Y.......|\n060  01 a7 03 08 51 a8 03 08  21 aa 03 08 b9 a4 03 08  |....Q...!.......|\n070  85 a3 03 08 89 a3 03 08  4d a4 03 08 a1 a8 03 08  |........M.......|\n080  00 00 00 00 00 00 00 00  19 a8 03 08 c1 a4 03 08  |................|\n090  8d a8 03 08 ed a6 03 08  dd a7 03 08 ad a4 03 08  |................|\n0a0  9d a7 03 08 95 a4 03 08  81 a7 03 08 09 a7 03 08  |................|\n0b0  31 a7 03 08 d1 a6 03 08  dd a5 03 08 61 aa 03 08  |1...........a...|\n0c0  c5 a2 03 08 d5 a2 03 08  d9 a2 03 08 b1 a6 03 08  |................|\n0d0  65 aa 03 08 ad a6 03 08  a9 a6 03 08 8d a6 03 08  |e...............|\n0e0  e5 a2 03 08 e9 a2 03 08  1d a4 03 08 ed a3 03 08  |................|\n0f0  35 a4 03 08 05 a4 03 08  bd a3 03 08 8d a3 03 08  |5...............|\n</code></pre></p> <p>a DIFF32 patch containing: <pre><code>     fe 39 00 50 0c 00 24 28  2c 30 34 38 3c 40 44 48  |.9.P..$(,048&lt;@DH|\n     4c 50 54 58 5c 60 64 68  6c 70 74 78 7c 88 8c 90  |LPTX\\`dhlptx|...|\n     94 98 9c a0 a4 a8 ac b0  b4 b8 bc c0 c4 c8 cc d0  |................|\n     d4 d8 dc e0 e4 e8 ec f0  f4 f8 fc                 |...........     |\n</code></pre></p> <p>adds 0x000C5000 to 53 values, producing OTA2 output like this: <pre><code>000  72 71 73 61 76 65 00 00  5f 66 72 65 65 72 74 6f  |rqsave.._freerto|\n010  73 5f 6d 75 74 65 78 5f  67 65 74 5f 74 69 6d 65  |s_mutex_get_time|\n020  6f 75 74 00 5d f4 0f 08  61 f4 0f 08 85 f4 0f 08  |out.]...a.......|\n030  5d f4 0f 08 61 f4 0f 08  85 f4 0f 08 81 f9 0f 08  |]...a...........|\n040  6d f9 0f 08 7d f4 0f 08  d9 f8 0f 08 05 f7 0f 08  |m...}...........|\n050  bd f4 0f 08 ad f8 0f 08  59 f7 0f 08 9d f8 0f 08  |........Y.......|\n060  01 f7 0f 08 51 f8 0f 08  21 fa 0f 08 b9 f4 0f 08  |....Q...!.......|\n070  85 f3 0f 08 89 f3 0f 08  4d f4 0f 08 a1 f8 0f 08  |........M.......|\n080  00 00 00 00 00 00 00 00  19 f8 0f 08 c1 f4 0f 08  |................|\n090  8d f8 0f 08 ed f6 0f 08  dd f7 0f 08 ad f4 0f 08  |................|\n0a0  9d f7 0f 08 95 f4 0f 08  81 f7 0f 08 09 f7 0f 08  |................|\n0b0  31 f7 0f 08 d1 f6 0f 08  dd f5 0f 08 61 fa 0f 08  |1...........a...|\n0c0  c5 f2 0f 08 d5 f2 0f 08  d9 f2 0f 08 b1 f6 0f 08  |................|\n0d0  65 fa 0f 08 ad f6 0f 08  a9 f6 0f 08 8d f6 0f 08  |e...............|\n0e0  e5 f2 0f 08 e9 f2 0f 08  1d f4 0f 08 ed f3 0f 08  |................|\n0f0  35 f4 0f 08 05 f4 0f 08  bd f3 0f 08 8d f3 0f 08  |5...............|\n</code></pre></p>"},{"location":"docs/contrib/ota/library/","title":"uf2ota library","text":"<p>uf2ota library allows to write a LibreTiny UF2 file to the flash, while parsing all the necessary tags. It manages the target partitions, compatibility checks, and works on top of the FAL provided by FlashDB.</p>"},{"location":"docs/contrib/ota/library/#usage-example","title":"Usage example","text":"<pre><code>uint8_t target     = 1;          // target OTA scheme - 1 or 2\nuint32_t family    = F_RTL8710B; // chip's UF2 family ID\nuf2_ota_t *ctx     = uf2_ctx_init(target, family);\nuf2_info_t *info   = uf2_info_init(); // optional, for getting firmware info\nuf2_block_t *block = (uf2_block_t *)malloc(UF2_BLOCK_SIZE);\nuf2_err_t err;\n\n// ... // read the first header block (512 bytes) into *block\n\n// check the block for validity\nerr = uf2_check_block(ctx, block);\nif (err &gt; UF2_ERR_IGNORE)\n    // handle the error\n    return;\n\n// parse the header block\n// note: if you don't need info, you can skip this step and call uf2_write() directly\nerr = uf2_parse_header(ctx, block, info);\nif (err)\n    // handle the error\n    return;\n\nwhile (/* have input data */) {\n\n    // ... // read the next block into *block\n\n    // check the block for validity\n    err = uf2_check_block(ctx, block);\n    if (err == UF2_ERR_IGNORE)\n        // skip this block\n        continue;\n    if (err)\n        // handle the error\n        return;\n\n    // write the block to flash\n    err = uf2_write(ctx, block);\n    if (err &gt; UF2_ERR_IGNORE)\n        // handle the error\n        return;\n}\n\n// finish the update process\n\n// ... // activate your new OTA partition\n\n// cleanup\nfree(ctx);\nfree(block);\nuf2_info_free(info);\n</code></pre>"},{"location":"docs/contrib/ota/uf2ota/","title":"uf2ota.py","text":"<p>This is a tool for converting LibreTiny firmware images to UF2 format for OTA updates.</p> <pre><code>$ python uf2ota.py\nusage: uf2ota [-h] [--output OUTPUT] [--family FAMILY] [--board BOARD] [--version VERSION] [--fw FW] {info,dump,write} inputs [inputs ...]\nuf2ota: error: the following arguments are required: action, inputs\n</code></pre>"},{"location":"docs/contrib/ota/uf2ota/#write","title":"write","text":"<p>Generate a UF2 file from a firmware image or several images.</p> <pre><code>$ python uf2ota.py write --family RTL8710B --board wr3 --version 0.4.0 --fw esphome:2022.6.0-dev \"ota1;xip1.bin;ota2;xip2.bin\"\n\n$ ls -l out.uf2\n-rw-r--r-- 1 Kuba None 605696 May 28 14:35 out.uf2\n</code></pre>"},{"location":"docs/contrib/ota/uf2ota/#inputs-format","title":"inputs format","text":"<p>Format for <code>inputs</code> parameter is <code>part;file[;part;file]</code> (square brackets mean optional). First two (colon separated) values correspond to flashing OTA1 region, second two to OTA2.</p> <p>Partition name can be suffixed by <code>+offset</code>, which causes writing the image file to the partition after some byte offset. Both files and/or partition names can be equal. Values can be empty (like <code>part;file;;</code> or <code>;;part;file</code>) if OTA1/2 images are not present in this file.</p> <p>When using two different firmware binaries, they need to have the same <code>offset</code> and be of the same size.</p> <p><code>inputs</code> parameter can be repeated in order to embed multiple files in the UF2. For example: <pre><code>\"bootloader;boot.bin\" \"ota1;xip1.bin;ota2;xip2.bin\" \"config;config1.bin;config;config2.bin\"\n</code></pre> will:</p> <ul> <li>flash the bootloader in both OTA schemes</li> <li>flash <code>xip1.bin</code> or <code>xip2.bin</code> to <code>ota1</code> or <code>ota2</code> partitions</li> <li>flash <code>config1.bin</code> or <code>config2.bin</code> to <code>config</code> partition</li> </ul>"},{"location":"docs/contrib/ota/uf2ota/#info","title":"info","text":"<p>This command shows some basic parameters of a UF2 image.</p> <pre><code>$ python uf2ota.py info out.uf2\nFamily: RTL8710B\nTags:\n - BOARD: wr3\n - DEVICE_ID: 312d5ec5\n - LT_VERSION: 0.4.0\n - FIRMWARE: esphome\n - VERSION: 2022.6.0-dev\n - OTA_VERSION: 01\n - DEVICE: LibreTiny\n - LT_HAS_OTA1: 01\n - LT_HAS_OTA2: 01\n - LT_PART_1: ota1\n - LT_PART_2: ota2\n - LT_BINPATCH: fe0900500c009094989ca0\nData chunks: 1182\nTotal binary size: 302448\n</code></pre>"},{"location":"docs/contrib/ota/uf2ota/#dump","title":"dump","text":"<p>Dump UF2 file (only LibreTiny format) into separate firmware binaries.</p> <pre><code>$ python uf2ota.py dump out.uf2\n\n$ ls -1 out.uf2_dump/\nesphome_2022.6.0-dev_lt0.4.0_wr3_1_ota1_0x0.bin\nesphome_2022.6.0-dev_lt0.4.0_wr3_2_ota2_0x0.bin\n</code></pre>"},{"location":"docs/dev/config/","title":"Configuration","text":""},{"location":"docs/dev/config/#project-options","title":"Project options","text":"platformio.ini<pre><code>[env:my_board]\n# custom firmware name, present in UF2 output files\n# - default: project directory name\ncustom_fw_name = my_firmware\n# custom firmware version\n# - default: current date in yy.mm.dd format\ncustom_fw_version = 1.2.0\n\n# custom build options (#defines, NOT compiler flags)\ncustom_options.lwip =\n    # make sure to enable LT_DEBUG_LWIP as well\n    NETIF_DEBUG = 0x80\n    IP_DEBUG = 0x80\n    TCP_DEBUG = 0x80\ncustom_options.freertos =\n    configUSE_TICK_HOOK = 1\n\n# partition layout modification (not recommended, unless you know what you're doing)\ncustom_flash.app = 0x12000\n\n# custom board JSON (overrides)\n# - path relative to the project directory; only values specified\n#     in the JSON will override the defaults\n#     (it's like using board_build.xxx but for more keys)\ncustom_board = myboard.json\n\n# custom library versions (not recommended)\ncustom_versions.lwip = 2.1.3\ncustom_versions.beken_bdk = 2021.06.07\n</code></pre>"},{"location":"docs/dev/config/#libretiny-options","title":"LibreTiny options","text":"<p>Note</p> <p>See lt_config.h for most options and their defaults.</p>  <p>All options are configurable via C++ defines in PlatformIO project file. For example: platformio.ini<pre><code>[env:my_board]\nbuild_flags =\n  -D LT_LOGLEVEL=LT_LEVEL_DEBUG\n</code></pre></p>  <p>Tip</p> <p>Values in parentheses represent the defaults for the config options.</p>"},{"location":"docs/dev/config/#logger","title":"Logger","text":"<ul> <li><code>LT_LOGGER</code> (1) - enable/disable LibreTiny logger globally; disabling this sets the loglevel to <code>LT_LEVEL_NONE</code> - the logger can't be enabled even by using <code>lt_log_set_port()</code></li> <li> <p><code>LT_LOGLEVEL</code> - global LT loglevel:</p> <ul> <li><code>LT_LEVEL_VERBOSE</code></li> <li><code>LT_LEVEL_TRACE</code> - same as <code>LT_LEVEL_VERBOSE</code></li> <li><code>LT_LEVEL_DEBUG</code></li> <li><code>LT_LEVEL_INFO</code> - default</li> <li><code>LT_LEVEL_WARN</code></li> <li><code>LT_LEVEL_ERROR</code></li> <li><code>LT_LEVEL_FATAL</code></li> <li><code>LT_LEVEL_NONE</code> - disables everything</li> </ul> </li> <li> <p><code>LT_LOGGER_TIMESTAMP</code> (1) - print program runtime in printk-like format</p> </li> <li><code>LT_LOGGER_CALLER</code> (1) - print calling method name</li> <li><code>LT_LOGGER_TASK</code> (1) - print calling FreeRTOS task (if available)</li> <li><code>LT_LOGGER_COLOR</code> (0) - output ANSI terminal colors</li> <li><code>LT_PRINTF_BROKEN</code> (0) - whether printf outputs \"0.\" for floats with value 0</li> <li><code>LT_LOG_HEAP</code> (0) - print free heap size using <code>LT_HEAP_I()</code>, and periodically every 1000 ms</li> <li><code>LT_LOG_ERRNO</code> (0) - print and clear errno value (if set) using <code>LT_ERRNO()</code></li> </ul>"},{"location":"docs/dev/config/#per-module-logging-debugging","title":"Per-module logging &amp; debugging","text":"<p>The following options enable library-specific logging output. They are effective for all loglevels - i.e. disabling <code>LT_DEBUG_WIFI</code> will disable WiFi debug messages, warnings, as well as errors.</p> <p>To see debug messages from i.e. OTA, loglevel must also be changed.</p> <ul> <li><code>LT_DEBUG_ALL</code> (0) - enable all following options by default (except for FDB and LWIP)</li> <li><code>LT_DEBUG_WIFI</code> (1) - WiFi (generic, STA, AP, scan, events, etc.)</li> <li><code>LT_DEBUG_CLIENT</code> (0) - TCP client</li> <li><code>LT_DEBUG_SERVER</code> (0) - TCP server</li> <li><code>LT_DEBUG_SSL</code> (0) - SSL clients</li> <li><code>LT_DEBUG_OTA</code> (1) - OTA updates (<code>Update</code> library)</li> <li><code>LT_DEBUG_FDB</code> (0) - FlashDB debugging (macros within the library)</li> <li><code>LT_DEBUG_MDNS</code> (0) - mDNS client library</li> <li><code>LT_DEBUG_LWIP</code> (0) - enables <code>LWIP_DEBUG</code>, provides <code>LWIP_PLATFORM_DIAG</code>; per-module options (i.e. <code>TCP_DEBUG</code>) are off by default and need to be enabled separately - see example in <code>Project options</code> above</li> <li><code>LT_DEBUG_LWIP_ASSERT</code> (0) - enables assertions within lwIP (doesn't need <code>LT_DEBUG_LWIP</code>)</li> </ul>  <p>Tip</p> <p>Enabling <code>LT_DEBUG_ALL</code> doesn't mean that every debugging message will be printed. If loglevel is i.e. <code>WARN</code>, debug messages won't be visible anyway.</p> <p>This can be used, for example, to enable only \"important\" messages: platformio.ini<pre><code>[env:my_board]\nbuild_flags =\n  -D LT_LOGLEVEL=LT_LEVEL_WARN\n  -D LT_DEBUG_ALL=1 # will print only warnings and errors from all modules\n</code></pre></p>"},{"location":"docs/dev/config/#serial-output","title":"Serial output","text":"<p>Options for controlling default UART log output.</p> <ul> <li><code>LT_UART_DEFAULT_PORT</code> (unset) - default output port for all messages (SDK, LT logger, Serial class); can be 0, 1 or 2</li> <li><code>LT_UART_DEFAULT_LOGGER</code> (unset) - override default output port for LT logger only</li> <li><code>LT_UART_DEFAULT_SERIAL</code> (unset) - override default output port for <code>Serial</code> class (without a number)</li> <li><code>LT_UART_SILENT_ENABLED</code> (1) - enable auto-silencing of SDK \"loggers\"; this makes the serial output much more readable, but can hide some error messages</li> <li><code>LT_UART_SILENT_ALL</code> (0) - disable all SDK output (LT output and logger still work); since v1.0.0 this has no effect if <code>LT_UART_SILENT_ENABLED</code> is 0</li> </ul>  <p>Info</p> <p>Values 0, 1 and 2 correspond to physical UART port numbers (refer to board pinout for the available ports).</p> <p>Serial class instances (<code>Serial0</code>, <code>Serial1</code>, <code>Serial2</code>) use the respective port numbers for printing.</p> <p>If <code>LT_UART_DEFAULT_LOGGER</code> is not set, it is chosen by the family code - whichever port is most appropriate (i.e. LOG_UART (2) on Realtek, RX2/TX2 on Beken).</p>"},{"location":"docs/dev/config/#misc-options","title":"Misc options","text":"<ul> <li><code>LT_USE_TIME</code> (0) - enables implementation of <code>gettimeofday()</code> and <code>settimeofday()</code>; checks for <code>millis()</code> overflows periodically</li> <li><code>LT_MICROS_HIGH_RES</code> (1) - count runtime microseconds using a high-resolution timer (if possible); disable if your application doesn't need <code>micros()</code></li> <li><code>LT_AUTO_DOWNLOAD_REBOOT</code> (1) - automatically reboot into \"download mode\" after detecting a flashing protocol command; read more</li> </ul>"},{"location":"docs/dev/config/#family-configuration","title":"Family configuration","text":"<p>Warning</p> <p>These options are not meant for end-users. They're provided here as a reference for developers. Do not set these options manually.</p>  <p>These options are selectively set by all families, as part of the build process. They are used for enabling LT core API parts, if the family has support for it. Files named <code>lt_defs.h</code>, containing these options, are read by the PlatformIO builders (note: they're never included by C code).</p> <p>Checking for option value should be done with <code>#if</code> (not with <code>#ifdef</code>!) - if it's not defined, it will evaluate to 0. Otherwise, it will use the defined value, either 0 or 1.</p> <ul> <li>family-/chip-specific hardware peripherals<ul> <li><code>LT_HW_WIFI</code> - WiFi supported on the chip</li> <li><code>LT_HW_BT</code> - Bluetooth Classic supported on the chip</li> <li><code>LT_HW_BLE</code> - Bluetooth Low Energy supported on the chip</li> <li><code>LT_HW_WATCHDOG</code> - watchdog available</li> <li><code>LT_HW_DEEP_SLEEP</code> - deep sleep possible</li> </ul> </li> <li>board-specific peripherals (note: defined in <code>lt_pins.h</code>, depending on available pin numbers)<ul> <li><code>LT_HW_UART#</code> - UART number # available on the board</li> <li><code>LT_HW_I2C#</code> - I\u00b2C number # available on the board</li> <li><code>LT_HW_SPI#</code> - SPI number # available on the board</li> </ul> </li> <li>family software options (SDK features, LT implementation status)<ul> <li><code>LT_HAS_FREERTOS</code> - FreeRTOS supported and used</li> <li><code>LT_HAS_LWIP</code> - LwIP in SDK (any version)</li> <li><code>LT_HAS_LWIP2</code> - LwIP v2.0.0 or newer</li> <li><code>LT_HAS_MBEDTLS</code> - mbedTLS in SDK</li> <li><code>LT_HAS_PRINTF</code> - printf library implemented</li> <li><code>LT_HAS_FLASH</code> - FAL flash port implemented</li> <li><code>LT_HAS_OTA</code> - OTA implemented in base framework</li> </ul> </li> <li>Arduino Core implementation status (only available and used along with Arduino framework)<ul> <li><code>LT_ARD_HAS_SERIAL</code> - Serial class implemented</li> <li><code>LT_ARD_HAS_SOFTSERIAL</code> - SoftwareSerial library implemented</li> <li><code>LT_ARD_HAS_WIFI</code> - WiFi library implemented</li> <li><code>LT_ARD_HAS_WIRE</code> - Wire (I\u00b2C) library implemented</li> <li><code>LT_ARD_HAS_SPI</code> - SPI library implemented</li> <li><code>LT_ARD_MD5_MBEDTLS</code> - use mbedTLS for MD5 library</li> <li><code>LT_ARD_MD5_HOSTAPD</code> - use hostapd for MD5 library</li> </ul> </li> <li>misc options<ul> <li><code>LT_HEAP_FUNC</code> - function name used to get available heap size (for <code>LT_HEAP_I()</code>)</li> <li><code>LT_REALLOC_FUNC</code> - function name used for <code>realloc()</code> call</li> <li><code>LT_REMALLOC</code> - use <code>malloc()</code> and <code>memcpy()</code> in <code>realloc()</code> call</li> </ul> </li> </ul>"},{"location":"docs/dev/libs-3rd-party/","title":"Libraries","text":"<p>A page outlining 3-rd some party libraries compatible with LibreTiny.</p>  <p>Note</p> <p>To use some (most? (all?)) of these, a flag in <code>platformio.ini</code> is required to disable compatibility checks (because most libs are meant for ESP32/Arduino official framework): <pre><code>[env:my_board]\nlib_compat_mode = off\n</code></pre></p>"},{"location":"docs/dev/libs-3rd-party/#256dpimqtt","title":"256dpi/MQTT","text":"<p>Tested with <code>realtek-ambz</code>. <pre><code>lib_deps = 256dpi/MQTT@^2.5.0\n</code></pre></p>"},{"location":"docs/dev/libs-3rd-party/#bbx10dnsserver","title":"bbx10/DNSServer","text":"<p>Tested with <code>beken-72xx</code>. <pre><code>lib_deps = bbx10/DNSServer@^1.1.0\n</code></pre> This is the same library as in ESP32 Arduino Core.</p>"},{"location":"docs/dev/libs-3rd-party/#esphomeasynctcp-esphome","title":"esphome/AsyncTCP-esphome","text":"<p>Tested with <code>beken-72xx</code> and <code>realtek-ambz</code>. <pre><code>lib_deps = esphome/AsyncTCP-esphome@^2.0.0\n</code></pre> This is ESPHome's fork of the original library.</p>"},{"location":"docs/dev/libs-3rd-party/#esphomeespasyncwebserver-esphome","title":"esphome/ESPAsyncWebServer-esphome","text":"<p>Tested with <code>beken-72xx</code> and <code>realtek-ambz</code>. <pre><code>lib_deps = esphome/ESPAsyncWebServer-esphome@^3.0.0\n</code></pre> This is ESPHome's fork of the original library.</p>"},{"location":"docs/dev/lt-api/","title":"LibreTiny API","text":"<p>The LibreTiny API is divided in two parts:</p> <ul> <li>the C API, available in all families and frameworks</li> <li>the C++ API, available in the Arduino framework only.</li> </ul> <p>The C++ API is a thin wrapper around the C API (using classes with inline functions). It's provided for less-experienced users, who are used to Arduino IDE's classes like <code>ESP</code> (and for backwards compatibility). It's recommended to use the C API wherever possible.</p>"},{"location":"docs/dev/lt-api/#c-api","title":"C API","text":"<p>This API is available using:</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"docs/dev/lt-api/#cpu","title":"CPU","text":"Type Name     uint8_t lt_cpu_get_core_count () Get CPU core count.   const char * lt_cpu_get_core_type () Get CPU core type name as string.   uint32_t lt_cpu_get_cycle_count () Get CPU cycle count.   lt_cpu_family_t lt_cpu_get_family () Get CPU family ID (as lt_cpu_family_t enum member).   const char * lt_cpu_get_family_name () Get CPU family name as string.   uint32_t lt_cpu_get_freq () Get CPU frequency in Hz.   uint32_t lt_cpu_get_freq_mhz () Get CPU frequency in MHz.   uint32_t lt_cpu_get_mac_id () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   lt_cpu_model_t lt_cpu_get_model () Get CPU model ID (as lt_cpu_model_t enum member).   const char * lt_cpu_get_model_code () Get CPU model name as string (lowercase).   const char * lt_cpu_get_model_name () Get CPU model name as string (uppercase).   uint32_t lt_cpu_get_unique_id () Get CPU unique ID. This may be based on MAC, eFuse, etc. (family-specific). Note: the number is 24-bit (with the MSB being zero)."},{"location":"docs/dev/lt-api/#device","title":"Device","text":"Type Name     const char * lt_get_board_code () Get board code.   void lt_get_device_mac (uint8_t * mac) Read device's default MAC address into 'mac' array. This can be used even without Wi-Fi enabled, and will ignore user-changed Wi-Fi MAC (if changing is possible).   const char * lt_get_device_name () Get device friendly name in format \"LT-&lt;chip model&gt;-&lt;MAC ID&gt;\". Can be used as hostname.   lt_reboot_reason_t lt_get_reboot_reason () Get the reason of last chip reboot.   const char * lt_get_reboot_reason_name (lt_reboot_reason_t reason) Get a textual representation of a reboot reason.   const char * lt_get_version () Get LibreTiny version string.   void lt_gpio_recover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   void lt_reboot () Reboot the CPU.   bool lt_reboot_download_mode () Reboot the CPU and stay in download mode (if possible).   bool lt_reboot_wdt () Reboot the CPU with a watchdog timeout (if possible).   bool lt_set_debug_mode (lt_debug_mode_t mode) Set debugger mode (JTAG, SWD or OFF)."},{"location":"docs/dev/lt-api/#macros","title":"Macros","text":"Type Name     define REBOOT_REASON_SLEEP  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_BROWNOUT  REBOOT_REASON_BROWNOUT   define RESET_REASON_CRASH  REBOOT_REASON_CRASH   define RESET_REASON_HARDWARE  REBOOT_REASON_HARDWARE   define RESET_REASON_MAX  REBOOT_REASON_MAX   define RESET_REASON_POWER  REBOOT_REASON_POWER   define RESET_REASON_SLEEP  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_SLEEP_GPIO  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_SLEEP_RTC  REBOOT_REASON_SLEEP_RTC   define RESET_REASON_SLEEP_USB  REBOOT_REASON_SLEEP_USB   define RESET_REASON_SOFTWARE  REBOOT_REASON_SOFTWARE   define RESET_REASON_UNKNOWN  REBOOT_REASON_UNKNOWN   define RESET_REASON_WATCHDOG  REBOOT_REASON_WATCHDOG"},{"location":"docs/dev/lt-api/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"docs/dev/lt-api/#enum-lt_debug_mode_t","title":"enum lt_debug_mode_t","text":"<pre><code>enum lt_debug_mode_t {\n    DEBUG_MODE_OFF = 0,\n    DEBUG_MODE_JTAG = 1,\n    DEBUG_MODE_SWD = 2\n};\n</code></pre>"},{"location":"docs/dev/lt-api/#enum-lt_reboot_reason_t","title":"enum lt_reboot_reason_t","text":"<pre><code>enum lt_reboot_reason_t {\n    REBOOT_REASON_UNKNOWN = 1,\n    REBOOT_REASON_POWER = 2,\n    REBOOT_REASON_BROWNOUT = 3,\n    REBOOT_REASON_HARDWARE = 4,\n    REBOOT_REASON_SOFTWARE = 5,\n    REBOOT_REASON_WATCHDOG = 6,\n    REBOOT_REASON_CRASH = 7,\n    REBOOT_REASON_SLEEP_GPIO = 8,\n    REBOOT_REASON_SLEEP_RTC = 9,\n    REBOOT_REASON_SLEEP_USB = 10,\n    REBOOT_REASON_DEBUGGER = 11,\n    REBOOT_REASON_MAX = 12\n};\n</code></pre>"},{"location":"docs/dev/lt-api/#flash","title":"Flash","text":"Type Name     bool lt_flash_erase (uint32_t offset, size_t length) Erase flash area. Flash can only be erased in blocks (usually 4 KiB).   bool lt_flash_erase_block (uint32_t offset) Erase a single block of flash (usually 4 KiB).   lt_flash_id_t lt_flash_get_id () Read flash chip ID and return a lt_flash_id_t struct.   uint32_t lt_flash_get_size () Get flash chip total size.   uint32_t lt_flash_read (uint32_t offset, uint8_t * data, size_t length) Read data from the flash.   uint32_t lt_flash_write (uint32_t offset, const uint8_t * data, size_t length) Write data to the flash."},{"location":"docs/dev/lt-api/#memory","title":"Memory","text":"Type Name     uint32_t lt_heap_get_free () Get free heap size.   uint32_t lt_heap_get_max_alloc () Get largest block of heap that can be allocated at once.   uint32_t lt_heap_get_min_free () Get lowest level of free heap memory.   uint32_t lt_heap_get_size () Get total heap size.   uint32_t lt_ram_get_size () Get total RAM size."},{"location":"docs/dev/lt-api/#ota","title":"OTA","text":"Type Name     void lt_ota_begin (lt_ota_ctx_t * ctx, size_t size) Initialize the update context to begin OTA process.   bool lt_ota_can_rollback () Check if OTA rollback is possible (switching the stored index to another partition).   uint8_t lt_ota_dual_get_current () Get the currently running firmware's OTA index.   uint8_t lt_ota_dual_get_stored () Read the currently active OTA index, i.e. the one that will boot upon restart.   bool lt_ota_end (lt_ota_ctx_t * ctx) Finish the update process. If the update has been written completely, try to activate the target image. Free allocated internal structures, regardless of the activation result.   lt_ota_type_t lt_ota_get_type () Get OTA type of the device's chip.   uf2_ota_scheme_t lt_ota_get_uf2_scheme () Check which UF2 OTA scheme should be used for applying firmware updates.   bool lt_ota_is_valid (uint8_t index) Check if the specified OTA image is valid.   void lt_ota_set_write_protect (uf2_ota_t * uf2) Set family-specific, write-protected flash areas in the OTA update context. This shouldn't be called manually, as it's done by lt_ota_begin().   bool lt_ota_switch (bool revert) Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid.   size_t lt_ota_write (lt_ota_ctx_t * ctx, const uint8_t * data, size_t len) Process a chunk of data.   bool lt_ota_write_block (lt_ota_ctx_t * ctx, uf2_block_t * block) Try to write the block. In case of UF2 errors, error code is set in the context. Note: use lt_ota_write() instead. This is for internal usage only."},{"location":"docs/dev/lt-api/#public-types-documentation_1","title":"Public Types Documentation","text":""},{"location":"docs/dev/lt-api/#enum-lt_ota_type_t","title":"enum lt_ota_type_t","text":"<pre><code>enum lt_ota_type_t {\n    OTA_TYPE_SINGLE = 0,\n    OTA_TYPE_DUAL = 1,\n    OTA_TYPE_FILE = 2\n};\n</code></pre>"},{"location":"docs/dev/lt-api/#utilities","title":"Utilities","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset=0, uint8_t width=16) Print data pointed to by buf in hexdump-like format (hex+ASCII).   char * lt_btox (const uint8_t * src, int len, char * dest) Convert a byte array to hexadecimal string.   void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand().   uint8_t * lt_xtob (const char * src, int len, uint8_t * dest) Convert a hexadecimal string to byte array."},{"location":"docs/dev/lt-api/#watchdog","title":"Watchdog","text":"Type Name     void lt_wdt_disable () Disable the hardware watchdog.   bool lt_wdt_enable (uint32_t timeout) Enable the hardware watchdog.   void lt_wdt_feed () Feed/reset the hardware watchdog timer."},{"location":"docs/dev/lt-api/#logger","title":"Logger","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void void lt_log_set_port (uint8_t port) Change log output port."},{"location":"docs/dev/lt-api/#posix-compatibility-api","title":"POSIX compatibility API","text":"<p>A small subset of POSIX functions, commonly present in other Arduino cores, is provided for compatibility.</p>    Type Name     int strcasecmp (const char * s1, const char * s2)    char * strdup (const char *)    int strncasecmp (const char * s1, const char * s2, size_t n)    char * strptime (const char * buf, const char * fmt, struct tm * tm)"},{"location":"docs/dev/lt-api/#c-api_1","title":"C++ API","text":"<p>This API is available using:</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"docs/dev/lt-api/#libretiny","title":"LibreTiny","text":"<p>Since v1.0.0, this class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>LT</code> global object. </p>    Type Name     const char * getBoard () Get board code.   const char * getChipCoreType () Get CPU core type name as string.   uint8_t getChipCores () Get CPU core count.   ChipFamily getChipFamily () Get CPU family ID (as lt_cpu_family_t enum member).   const char * getChipFamilyName () Get CPU family name as string.   uint32_t getChipId () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   const char * getChipModel () Get CPU model name as string (uppercase).   ChipType getChipType () Get CPU model ID (as lt_cpu_model_t enum member).   uint32_t getCpuFreq () Get CPU frequency in Hz.   uint32_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   const char * getDeviceName () Get device friendly name in format \"LT-&lt;chip model&gt;-&lt;MAC ID&gt;\". Can be used as hostname.   FlashId getFlashChipId () Read flash chip ID and return a lt_flash_id_t struct.   uint32_t getFlashChipSize () Get flash chip total size.   uint32_t getFreeHeap () Get free heap size.   uint32_t getHeapSize () Get total heap size.   uint32_t getMaxAllocHeap () Get largest block of heap that can be allocated at once.   uint32_t getMaxFreeBlockSize () Get largest block of heap that can be allocated at once.   uint32_t getMinFreeHeap () Get lowest level of free heap memory.   uint32_t getRamSize () Get total RAM size.   ResetReason getResetReason () Get the reason of last chip reboot.   const char * getResetReasonName (ResetReason reason=lt_get_reboot_reason()) Get a textual representation of a reboot reason.   const char * getVersion () Reset reason enumeration.   void gpioRecover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   void restart () Reboot the CPU.   void restartDownloadMode () Reboot the CPU and stay in download mode (if possible)."},{"location":"docs/dev/lt-api/#libretinyota","title":"LibreTinyOTA","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>OTA</code> global object. </p>    Type Name     bool canRollback () Check if OTA rollback is possible (switching the stored index to another partition).   uint8_t getCurrentIndex () Get the currently running firmware's OTA index.   uint8_t getStoredIndex () Read the currently active OTA index, i.e. the one that will boot upon restart.   lt_ota_type_t getType () Get OTA type of the device's chip.   uf2_ota_scheme_t getUF2Scheme () Check which UF2 OTA scheme should be used for applying firmware updates.   bool isValid (uint8_t index) Check if the specified OTA image is valid.   bool switchImage (bool revert=false) Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid."},{"location":"docs/dev/lt-api/#libretinywdt","title":"LibreTinyWDT","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>WDT</code> global object. </p>    Type Name     void disable () Disable the hardware watchdog.   bool enable (uint32_t timeout=10000) Enable the hardware watchdog.   void feed () Feed/reset the hardware watchdog timer."},{"location":"docs/dev/lt-api/#esp-compatibility-class","title":"ESP (compatibility class)","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>ESP</code> global object. </p>    Type Name     bool flashEraseSector (uint32_t sector) Erase a single block of flash (usually 4 KiB).   bool flashRead (uint32_t address, uint8_t * data, size_t size) Read data from the flash.   bool flashWrite (uint32_t address, const uint8_t * data, size_t size) Write data to the flash.   uint8_t getBootMode ()    uint8_t getBootVersion ()    uint32_t getChipId () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   String getCoreVersion ()    uint8_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   uint32_t getFlashChipId () Flash chip ID structure.   uint32_t getFlashChipMode ()    uint32_t getFlashChipRealSize () Get flash chip total size.   uint32_t getFlashChipSize () Get flash chip total size.   uint32_t getFlashChipSizeByChipId () Get flash chip total size.   uint8_t getFlashChipVendorId () Flash chip ID structure.   uint32_t getFreeHeap () Get free heap size.   String getFullVersion ()    uint16_t getMaxFreeBlockSize () Get largest block of heap that can be allocated at once.   String getResetInfo () Get a textual representation of a reboot reason.   String getResetReason () Get a textual representation of a reboot reason.   const char * getSdkVersion ()    uint16_t getVcc ()    uint8_t * random (uint8_t * resultArray, const size_t outputSizeBytes) Generate random bytes using rand().   uint32_t random () Generate random bytes using rand().   void rebootIntoUartDownloadMode () Reboot the CPU and stay in download mode (if possible).   void reset () Reboot the CPU.   void restart () Reboot the CPU.   void wdtDisable () Disable the hardware watchdog.   void wdtEnable (uint32_t timeout_ms=0) Enable the hardware watchdog.   void wdtFeed () Feed/reset the hardware watchdog timer."},{"location":"docs/dev/lt-api/#arduino-custom-api","title":"Arduino custom API","text":"<p>These functions extend the standard Wiring (Arduino) library, to provide additional features.</p>    Type Name     int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   uint16_t analogReadMaxVoltage (pin_size_t pinNumber) Get max reading voltage for the specified pin (millivolts).   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   uint16_t analogReadVoltage (pin_size_t pinNumber) Read voltage from analog input (in millivolts).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly.   PinInfo * pinByGpio (uint32_t gpio) Find PinInfo struct by GPIO number. Returns NULL if not found.   PinInfo * pinByIndex (uint32_t index) Get PinInfo struct for the specified index. Returns NULL if pin index is invalid.   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   uint32_t pinIndex (PinInfo * pin) Get index of PinInfo in the global pin info table.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   void pinModeNone (pin_size_t pinNumber) Deinitialize the pin, by removing all enabled modes.   void pinModeRemove (pin_size_t pinNumber, uint32_t mask) Disable modes specified by 'mask'.   void pinRemoveMode (PinInfo * pin, uint32_t mask)    bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow.   bool startMainTask (void) Run mainTask &amp; start OS kernel (family-defined). Return false if an error occured; else do not return and and keep the OS kernel running."},{"location":"docs/dev/lt-api/#arduino-compatibility-api","title":"Arduino compatibility API","text":"<p>These functions and macros provide compatibility between LT and other Arduino cores, such as ESP32.</p>    Type Name     String ipToString (const IPAddress &amp; ip)        Type Name     define CONFIG_LWIP_MAX_ACTIVE_TCP  16   define ESP_FAIL  -1   define ESP_OK  0   define FPSTR (pstr_pointer) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))   define OUTPUT_OPEN_DRAIN  OUTPUT_OPENDRAIN   define PGM_VOID_P  const void *   define attachInterruptArg  attachInterruptParam   define digitalPinToInterrupt (pin) (pin)   define esp_err_t  int   define voidFuncPtrArg  voidFuncPtrParam   define vsnprintf_P  vsnprintf   define xTaskCreatePinnedToCore  xTaskCreateUniversal   define xTaskCreateUniversal (pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, xCoreID)   xTaskCreate(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)"},{"location":"docs/dev/lt-api/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"docs/dev/lt-api/#variable-emptystring","title":"variable emptyString","text":"<pre><code>const String emptyString;\n</code></pre>"},{"location":"docs/dev/lt-api/#chip-family-types","title":"Chip &amp; family types","text":""},{"location":"docs/dev/lt-api/#enum-lt_cpu_family_t","title":"enum lt_cpu_family_t","text":"<pre><code>enum lt_cpu_family_t {\n    F_RTL8710A = 0x9FFFD543,\n    F_RTL8710B = 0x22E0D6FC,\n    F_RTL8720C = 0xE08F7564,\n    F_RTL8720D = 0x3379CFE2,\n    F_BK7231Q = 0xAFE81D49,\n    F_BK7231T = 0x675A40B0,\n    F_BK7231N = 0x7B3EF230,\n    F_BK7251 = 0x6A82CC42,\n    F_BL60X = 0xDE1270B7,\n    F_LN882H = 0xA38090A8\n};\n</code></pre>"},{"location":"docs/dev/lt-api/#enum-lt_cpu_model_t","title":"enum lt_cpu_model_t","text":"<pre><code>enum lt_cpu_model_t {\n    RTL8710BL = CPU_MODEL(F_RTL8710B, 0xE0),\n    RTL8710BN = CPU_MODEL(F_RTL8710B, 0xFF),\n    RTL8710BU = CPU_MODEL(F_RTL8710B, 0xFE),\n    RTL8710BX = CPU_MODEL(F_RTL8710B, 0xF6),\n    RTL8710L0 = CPU_MODEL(F_RTL8710B, 0xFB),\n    RTL8711BN = CPU_MODEL(F_RTL8710B, 0xFD),\n    RTL8711BU = CPU_MODEL(F_RTL8710B, 0xFC),\n    MX1290 = RTL8710BN,\n    MX1290V2 = RTL8710BX,\n    W302 = RTL8710BN,\n    RTL8720CM = CPU_MODEL(F_RTL8720C, 0xEC),\n    RTL8720CF = CPU_MODEL(F_RTL8720C, 0xED),\n    RTL8720CX = RTL8720CM,\n    BK7231Q = CPU_MODEL(F_BK7231Q, 0x31),\n    BK7231T = CPU_MODEL(F_BK7231T, 0x1A),\n    BK7231N = CPU_MODEL(F_BK7231N, 0x1C),\n    BK7252 = CPU_MODEL(F_BK7251, 0x00),\n    BL2028N = BK7231N,\n    BK7231S = BK7231T,\n    BK7231U = BK7231T,\n    LN882HF = CPU_MODEL(F_LN882H, 0x00),\n    LN882HK = CPU_MODEL(F_LN882H, 0x00),\n    LN882HC = CPU_MODEL(F_LN882H, 0x00)\n};\n</code></pre>"},{"location":"docs/dev/migration_v1.0.0/","title":"Migration to v1.0.0","text":"<p>1.0.0 is the first major release of LT. Compared to previous versions, few things have changed which can impact developers using LT in PlatformIO (but shouldn't affect ESPHome users at all).</p>"},{"location":"docs/dev/migration_v1.0.0/#gpio-numbering","title":"GPIO numbering","text":"<p>Pin numbers passed to <code>pinMode()</code>/<code>digitalWrite()</code>/etc. are now the raw GPIO numbers of the chip. Previously, one had to use <code>D#</code> numbering in these functions, so you have to migrate your code to use GPIO numbers instead.</p> <p>To make the migration easier, you can simply change:</p> <pre><code>digitalWrite(1, LOW);\n</code></pre> <p>to:</p> <pre><code>digitalWrite(PIN_D1, LOW);\n// or\ndigitalWrite(D1, LOW);\n</code></pre> <p>For more information, refer to GPIO instructions.</p>"},{"location":"docs/dev/migration_v1.0.0/#environment-stability","title":"Environment stability","text":"<p>All public headers exported by LT are now stable between all chip families - this means that they're not including any code from the vendor SDK.</p> <p>This change was made to prevent the SDK from introducing its own functions and macros, which often replace stdlib functions, or cause other compilation issues.</p> <p>If your code is using vendor SDK functions, you'll have to import the appropriate headers yourself.</p>"},{"location":"docs/dev/migration_v1.0.0/#ota-uf2-packages","title":"OTA (.uf2 packages)","text":"<p>The format of OTA packages has changed slightly, to reflect the OTA scheme naming change (described below). There's also a distinction between the <code>flasher</code> (PC flasher) and <code>device</code> (on-device OTA code) in the package.</p> <p>New OTA packages are backwards-compatible (i.e. can be installed on devices running LT v0.x.x), but v1.0.0 will not accept older packages - it's not possible to rollback a device from v1.0.0 to v0.x.x with an old .uf2 file.</p>"},{"location":"docs/dev/migration_v1.0.0/#ota-scheme-naming-change","title":"OTA scheme naming change","text":"<p>Previously, each chip family had a \"has dual OTA\" property, which was very confusing (even to me, the author of the code). A new scheme has been introduced:</p> <ul> <li>single OTA - devices with a separate \"download\" partition, which is used by the bootloader to flash the main application</li> <li>dual OTA - devices with two separate application partitions, which can be updated directly by the application</li> </ul>"},{"location":"docs/flashing/SUMMARY/","title":"Flashing/dumping methods &amp; guides","text":"<ul> <li>ltchiptool GUI manual</li> <li>Flashing PlatformIO projects</li> <li>Flashing ESPHome</li> <li>Dumping stock firmware</li> <li>Converting with tuya-cloudcutter</li> <li>Auto-download-reboot</li> </ul>"},{"location":"docs/flashing/dumping/","title":"Dumping stock firmware","text":"<p>It is a good idea to dump the stock firmware (full flash contents) of your device before flashing custom firmware.</p> <p>Currently, the easiest way to dump firmware is to use ltchiptool. Download/install the tool, and follow the guide.</p>"},{"location":"docs/flashing/esphome/","title":"Flashing ESPHome","text":"<p>Tip</p> <p>See the Cloudcutter video guide for a complete tutorial on flashing with Cloudcutter and installing LibreTiny-ESPHome. Includes Home Assistant Add-On setup.</p>  <p>ESPHome can be flashed in few different ways, depending on your needs.</p>  <p>Abstract</p> <p>All binary files generated by ESPHome will be in <code>.esphome/build/&lt;yourdevice&gt;/.pioenvs/&lt;yourdevice&gt;/</code>. The methods described below may require you to get a file from that directory.</p> <p>If you're using the GUI (ESPHome Dashboard) this path will be in your <code>configs/</code> directory.</p> <p>This path will be referred to as build directory.</p>"},{"location":"docs/flashing/esphome/#built-in-flasher","title":"Built-in flasher","text":"CLIGUI   <p>The flasher program built-in LibreTiny is also available for ESPHome.</p> <ul> <li>use <code>python -m esphome run yourdevice.yml</code> to recompile AND upload the firmware</li> <li>use <code>python -m esphome upload yourdevice.yml</code> to upload without recompiling</li> </ul> <p> The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides to learn how to connect your device.</p> <p>If your device is already running ESPHome, refer to the OTA guide below.</p>   <p>The built-in flasher is not yet available in the GUI. Here are your options:</p> <ul> <li>OTA, using the downloaded UF2 file (if you're already running ESPHome)</li> <li>wired (also UF2), using ltchiptool</li> <li>wirelessly, using tuya-cloudcutter</li> </ul> <p>Read below for more details on each of these methods.</p>"},{"location":"docs/flashing/esphome/#over-the-air-ota","title":"Over-the-Air (OTA)","text":"<p>This method requires having ESPHome already installed on your device.</p> <ul> <li>If you've added the Web Server component, navigate to the device's IP address (or <code>.local</code> name) in your web browser. Grab <code>firmware.uf2</code> from the build directory and drop it on the \"OTA Update\" field.</li> <li>You can also use ESPHome CLI to flash via OTA. Add a <code>--device</code> argument to the command, as such: <code>python -m esphome upload yourdevice.yml --device yourdevice.local</code></li> </ul>"},{"location":"docs/flashing/esphome/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/flashing/esphome/#converting-devices-with-tuya-cloudcutter","title":"Converting devices with tuya-cloudcutter","text":"<p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p>Grab the <code>image_bk7231x_app.ota.ug.bin</code> file from the build directory - take care to choose the correct file. It must have \"OTA\" and \"UG\" in its name.</p> <p>Next, refer to Using tuya-cloudcutter guide.</p>"},{"location":"docs/flashing/esphome/#migrating-from-openbeken-ota","title":"Migrating from OpenBeken (OTA)","text":"<p>OpenBeken is a custom, Tasmota-like firmware for non-ESP chips. Currently, this part of the guide applies to BK7231 only, as that's the only chip supported both by LT and OBK.</p> <p>OBK is compatible with standard Beken OTA packages, but the web panel does a filename check to prevent chip type mismatch. Grab the <code>image_bk7231t_app.ota.rbl</code> file from build directory (note: without \"UG\" in the name!), rename it to something like <code>OpenBK7231T_esphome.rbl</code> (change T to N depending on the chip type), and drop it on the OTA panel.</p>"},{"location":"docs/flashing/esphome/#migrating-from-esphome-to-openbeken","title":"Migrating from ESPHome to OpenBeken","text":"<p>ESPHome is only compatible with UF2 OTA packages, which OpenBeken doesn't provide. You need to create an UF2 package manually, using ltchiptool (see ltchiptool#7 for more info). Grab an .RBL file from OpenBeken Releases page, and run this command:</p> <pre><code>ltchiptool uf2 write -b generic-bk7231n-qfn32-tuya -o OpenBeken.uf2 \"OpenBK7231N_1.17.205.rbl=device:download\"\n</code></pre> <p>This will create <code>OpenBeken.uf2</code> file that you can upload on the ESPHome web server dashboard page. Pay attention to the chip selection - incorrectly built UF2 file may brick your device! Make sure to download the right .RBL file of OpenBeken, and to choose the correct board (<code>-b</code>) parameter.</p>"},{"location":"docs/flashing/platformio/","title":"Flashing PlatformIO projects","text":"<p>PlatformIO projects developed with LibreTiny can be flashed just like any other PIO project.</p>  <p>Abstract</p> <p>All binary files generated by PlatformIO will be in <code>.pio/build/&lt;my_board&gt;/</code>. The methods described below may require you to get a file from that directory.</p> <p>This path will be referred to as build directory.</p>"},{"location":"docs/flashing/platformio/#built-in-flasher","title":"Built-in flasher","text":"<p>LibreTiny has a built-in firmware uploader, based on ltchiptool. Pressing <code>Upload</code> in PlatformIO IDE does all the work for you.</p> <p>If you have more than one COM port, configure your PIO project first:</p> platformio.ini<pre><code>[env:my_board]\nmonitor_port = COM96\nupload_port = COM96\n</code></pre> <p>The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides to learn how to connect your device.</p>"},{"location":"docs/flashing/platformio/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/flashing/tools/adr/","title":"Auto-download-reboot","text":"<p>(CEN-less uploading)</p> <p>This feature allows to upload code using UART, without needing to ground the CEN wire or power-cycle the device.</p> <p>It is enabled by default (using the <code>LT_AUTO_DOWNLOAD_REBOOT</code> option). It works by listening to incoming UART data, and checking if it matches a command that the flashing program would send. If it does, a chip reboot is performed and the uploading process starts.</p>  <p>Note</p> <p>ADR will only work if there's already a recent build of LibreTiny flashed to the device (and if the device doesn't bootloop or freeze immediately).</p>"},{"location":"docs/flashing/tools/adr/#beken-72xx","title":"Beken 72xx","text":"<p>The code listens on UART1 for a link-check command (<code>01 E0 FC 01 00</code>). The baudrate configured on the serial port has to be 115200 - it is configured automatically upon booting, but ADR won't work anymore if you change the baudrate manually. Because BK72xx doesn't have a dedicated \"persistent\" download mode, a normal reboot is performed and the chip waits a few hundred milliseconds for another link-check command.</p>"},{"location":"docs/flashing/tools/adr/#realtek-amebaz","title":"Realtek AmebaZ","text":"<p>This only works when using ltchiptool for flashing. Upon starting UART communication, the tool sends <code>55 AA 22 E0 D6 FC</code> (0x55AA followed by the <code>realtek-ambz</code> family ID). After detecting that pattern, the chip proceeds to reboot into UART download mode (using <code>lt_reboot_download_mode()</code>)</p>"},{"location":"docs/flashing/tools/adr/#realtek-amebaz2","title":"Realtek AmebaZ2","text":"<p>The code listens on UART2 for a <code>ping\\n</code> command, that is sent by ltchiptool (and possibly by the vendor flasher, too). The device is then rebooted to download mode.</p>"},{"location":"docs/flashing/tools/cloudcutter/","title":"Converting with tuya-cloudcutter","text":"<p>Tip</p> <p>See the Cloudcutter video guide for a complete tutorial on flashing with Cloudcutter and installing LibreTiny-ESPHome. Includes Home Assistant Add-On setup.</p>   <p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p><code>tuya-cloudcutter</code> is a tool that disconnects IoT devices from the Tuya cloud, while also allowing remote firmware flashing. This means you can flash ESPHome without even disassembling it.</p>  <p>Warning</p> <p>This guide might be outdated. For an up-to-date guide, always refer to tuya-cloudcutter/INSTRUCTIONS.md.</p>  <p>If your device doesn't have a profile yet, it will probably not work. You can contribute by taking a device dump and posting it on cloudcutter's issues page.</p>"},{"location":"docs/flashing/tools/cloudcutter/#instructions","title":"Instructions","text":""},{"location":"docs/flashing/tools/cloudcutter/#preparation","title":"Preparation","text":"<ol> <li>Get a laptop (or a PC with Wi-Fi) with Linux and Docker installed. This was tested on Ubuntu 20.04, but you should be able to use another Debian-based distribution with NetworkManager.<ul> <li>To install Docker, run <code>sudo apt-get install docker.io</code>. When it completes, run <code>sudo adduser &lt;your username&gt; docker</code> and reboot the machine.</li> <li>This was also successfully performed on a VirtualBox VM, with a USB Wi-Fi adapter redirected to the VM.</li> </ul> </li> <li>Install <code>git</code>, if you haven't already (<code>sudo apt-get install git</code>).</li> <li><code>git clone https://github.com/tuya-cloudcutter/tuya-cloudcutter</code></li> </ol>"},{"location":"docs/flashing/tools/cloudcutter/#firmware-building","title":"Firmware building","text":"<ol> <li>Compile ESPHome, or your custom firmware based on LibreTiny.</li> <li>Get the firmware binary, named <code>bk7231x_app.ota.ug.bin</code> from the build directory (<code>.pio/build/&lt;board&gt;/</code> or <code>.esphome/build/&lt;board&gt;/.pioenvs/&lt;board&gt;/</code>).</li> <li>Put it in the <code>custom-firmware</code> directory of tuya-cloudcutter.</li> </ol>"},{"location":"docs/flashing/tools/cloudcutter/#pairing-and-flashing","title":"Pairing and flashing","text":"<ol> <li>Run <code>./tuya-cloudcutter.sh</code> from the cloudcutter directory.</li> <li>Answer questions about the desired firmware file, the device vendor and profile.</li> <li>Put the device to AP mode: (**)<ul> <li>Bulbs (devices without buttons) usually need to be power-cycled a few times, until they start blinking slowly.</li> <li>Switches, plugs, relays (devices with buttons) usually enable AP after pressing the button for a few seconds.</li> <li>If the device (bulb or switch LED) is blinking quickly (~2 times per second), do the procedure again.</li> </ul> </li> <li>Cloudcutter will scan for APs, connect to the device and send a payload to it.</li> <li>The device will most likely hang (not respond). Reboot it again to AP mode (just like in step 9).</li> <li>Cloudcutter will scan for APs again, configure the device to talk to it, then begin the OTA update.</li> <li>After around 30 seconds, the device will boot new firmware \ud83d\udc4f</li> </ol> <p>** Use a smartphone with the Wi-Fi screen open and scanning, so that you can see if AP mode got enabled.</p>"},{"location":"docs/flashing/tools/ltchiptool/","title":"ltchiptool","text":"<p>ltchiptool is a universal, easy-to-use GUI flashing/dumping tool for BK7231, RTL8710B and RTL8720C. It also contains some CLI utilities for binary firmware manipulation.</p>"},{"location":"docs/flashing/tools/ltchiptool/#installation","title":"Installation","text":"<p> Download Windows GUI</p>"},{"location":"docs/flashing/tools/ltchiptool/#cli-program","title":"CLI program","text":"<p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Run the CLI using <code>python -m ltchiptool</code> or just <code>ltchiptool</code>.</p>"},{"location":"docs/flashing/tools/ltchiptool/#gui-application","title":"GUI application","text":"Windows 7 and newer <p>Download the latest release .EXE from the GitHub Releases page. Open the file, and you're ready to go!</p>   Windows (manual installation) <p>Install the package from PyPI (including GUI extras), using <code>pip install ltchiptool[gui]</code>. Note that Python 3.10 or newer is required for the GUI. I recommend Python 3.10 since it has prebuilt wheels of wxPython, which doesn't require C++ build dependencies.</p>   Linux (Ubuntu) <p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Python 3.10 or newer is required.</p> <p>Make sure you have wxPython installed. Install it from PyPI (if you have the necessary build dependencies), or refer to the wxPython Downloads page to install prebuilt wheels (recommended).</p> <p>Next, open a terminal and run <code>ltchiptool gui</code> (or <code>python -m ltchiptool gui</code>).</p>   MacOS (untested) <p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Python 3.10 or newer is required.</p> <p>Install wxPython from PyPI as well. Version 4.2.0 (latest at the time of writing) has some wheels for MacOS, so that should work.</p>"},{"location":"docs/flashing/tools/ltchiptool/#gui-usage","title":"GUI Usage","text":"<p>The main window is somewhat similar to NodeMCU PyFlasher. Available modes of operation are described below.</p>"},{"location":"docs/flashing/tools/ltchiptool/#dumping-firmware","title":"Dumping firmware","text":"<p>It is a good idea to dump the stock firmware (full flash contents) of your device before flashing custom firmware.</p> <ol> <li>Choose the <code>Read flash</code> option. If you've previously chosen an input or output file, it will generate a dump filename based on the current timestamp and chip type. Otherwise, click <code>Browse</code> and choose the output file.</li> <li>You need to pick the \"family\" of your chip (the chip model). If you choose the wrong option, the process will fail, but the device won't be bricked.</li> <li>Now, connect the chip to your PC, according to the chip connection guides. Select the COM port that your UART adapter is using.</li> <li>By default, the tool will attempt to read the entire flash chip (usually 2 MiB). Unless you know what you're doing, the default values don't need to be changed.</li> <li>Hit <code>Start</code>. The tool will try to connect to the chip on the selected UART port. The black log window will print any warnings/errors. The dumping process should begin shortly.</li> </ol>"},{"location":"docs/flashing/tools/ltchiptool/#flashing-firmware","title":"Flashing firmware","text":"<p>If you want to flash custom firmware, or restore stock firmware from a previously dumped file, follow the steps below.</p>  <p>Info</p> <p>LibreTiny generates multiple firmware files in the build directory. You usually want to flash the <code>.uf2</code> file, but since ltchiptool can detect file types, you can choose a different firmware file and it'll tell you if that works.</p>  <ol> <li>Choose <code>Write flash</code>. Click <code>Browse</code> and select a valid firmware file. The file type and chip type will be auto-detected, along with correct flash offset and length. No need to worry about overwriting the bootloader anymore!</li> <li>Connect the chip to your PC, according to the chip connection guides. Select the COM port that your UART adapter is using.</li> <li>Hit <code>Start</code>. The tool will try to connect to the chip on the selected UART port. The black log window will print any warnings/errors. The flashing process should begin shortly.</li> </ol>  <p>Info</p> <p>It's best to leave <code>Auto-detect advanced parameters</code> checked. If you're an experienced user and want to flash custom areas of the flash, uncheck the box and specify the parameters manually.</p> <p>If the file you're selecting is <code>Unrecognized</code> or <code>Not flashable</code>, it's most likely not a valid firmware file. Refer to usage guides of the custom firmware project of choice, to find which file is meant for flashing.</p>"},{"location":"docs/flashing/tools/ltchiptool/#cli-usage","title":"CLI Usage","text":""},{"location":"docs/flashing/tools/ltchiptool/#flashingdumping","title":"Flashing/dumping","text":"<p>This is for users, who are more experienced with using a terminal. There are three main commands used for flashing:</p> <ul> <li><code>ltchiptool flash file &lt;FILE&gt;</code> - detect file type based on its contents (i.e. chip from which a dump was acquired), similar to Linux <code>file</code> command</li> <li><code>ltchiptool flash read &lt;FAMILY&gt; &lt;FILE&gt;</code> - make a full flash dump of the connected device; specifying the family is required</li> <li><code>ltchiptool flash write &lt;FILE&gt;</code> - upload a file to the device; detects file type automatically (just like the <code>file</code> command above)</li> </ul> <p>Supported device families can be checked using <code>ltchiptool list families</code> command. In the commands above, you can use any of the family names (name/code/short name/etc).</p> <p>The upload UART port and baud rate should be detected automatically. To override it, use <code>-d COMx</code> or <code>-d /dev/ttyUSBx</code>. To change the target baud rate, use <code>-b 460800</code>. Note that the baud rate is changed after linking. Linking is performed using chip-default baud rate.</p> <p>It's not required to specify chip family for writing files - <code>ltchiptool</code> tries to recognize contents of the file, and chooses the best settings automatically. If you want to flash unrecognized/raw binaries (or fine-tune the flashing parameters), specify <code>-f &lt;FAMILY&gt;</code> and <code>-s &lt;START OFFSET&gt;</code>.</p>"},{"location":"docs/flashing/tools/ltchiptool/#cli-reference","title":"CLI Reference","text":"<p>Note</p> <p>If you're here to learn how to flash or dump firmware files, use the instructions above.</p> <p>The content below serves as a short documentation page for <code>ltchiptool</code> and is mostly meant for advanced users.</p>  <pre><code>$ ltchiptool --help\nUsage: ltchiptool [OPTIONS] COMMAND [ARGS]...\n\n  Tools for working with LT-supported IoT chips\n\nOptions:\n  -v, --verbose         Output debugging messages (repeat to output more)\n  -T, --traceback       Print complete exception traceback\n  -t, --timed           Prepend log lines with timing info\n  -r, --raw-log         Output logging messages with no additional styling\n  -i, --indent INTEGER  Indent log messages using graph lines\n  -V, --version         Show the version and exit.\n  -h, --help            Show this message and exit.\n\nCommands:\n  dump      Capture or process device dumps\n  elf2bin   Generate firmware binaries from ELF file\n  flash     Flashing tool - reading/writing\n  link2bin  Link code to binary format\n  list      List boards, families, etc.\n  soc       Run SoC-specific tools\n  uf2       Work with UF2 files\n</code></pre>"},{"location":"docs/flashing/tools/ltchiptool/#uf2-example","title":"UF2 Example","text":"<pre><code>$ ltchiptool uf2 info ./arduinotest_22.08.01_wb2l_BK7231T_lt0.8.0.uf2\nFamily: BK7231T / Beken 7231T\nTags:\n - BOARD: wb2l\n - DEVICE_ID: d80e20c2\n - LT_VERSION: 0.8.0\n - FIRMWARE: arduinotest\n - VERSION: 22.08.01\n - OTA_VERSION: 01\n - DEVICE: LibreTiny\n - BUILD_DATE: 6d08e862\n - LT_HAS_OTA1: 01\n - LT_HAS_OTA2: 00\n - LT_PART_1: app\n - LT_PART_2:\nData chunks: 1871\nTotal binary size: 478788\n</code></pre>"},{"location":"docs/getting-started/","title":"Getting started","text":"<p>Using LibreTiny is simple, just like every other PlatformIO development platform.</p> <ol> <li>Install PlatformIO</li> <li><code>pio pkg install --platform libretiny</code></li> </ol>  <p>Tip</p> <p>See the Cloudcutter video guide for a complete tutorial on flashing with Cloudcutter and installing LibreTiny-ESPHome. Includes Home Assistant Add-On setup.</p> <p>More information on Cloudcutter can be found in the Tuya Cloudcutter GitHub repository.</p>"},{"location":"docs/getting-started/#board-selection","title":"Board selection","text":"<ol> <li>Navigate to the supported boards &amp; CPUs list.</li> <li>Find the board your device has (usually, the model number is written on the silkscreen).  If your board isn't available yet, use one of the \"Generic\" boards that matches the CPU you your board has.</li> <li>Click on the board name. A new page opens with information about the selected board name.</li> <li>Scroll down to the \"Usage\" section of the page, and copy the configuration section that is relevant to your use case.</li> </ol>"},{"location":"docs/getting-started/#run-community-projects","title":"Run community projects","text":"<p>LibreTiny was developed with popular community projects in mind.</p> <p>There is an official ESPHome port available and integrated into the ESPHome project. No extra downloads or code compilations are needed to use ESPHome with LibreTiny-supported platforms.</p>"},{"location":"docs/getting-started/#develop-your-own-project","title":"Develop your own project","text":"<p>Developing your own embedded software that runs on LibreTiny-supported platforms.</p> <p>To get started with LibreTiny on your chosen platform, create a new project using your preferred method.</p> <p>There's a few ways to create a new PlatformIO Project. For example:</p> <ul> <li>using the PlatformIO IDE graphical interface (PIO Home -&gt; Open -&gt; New Project)</li> <li>by running the <code>pio project init</code> command in your desired project directory  See the PlatformIO Core (CLI) documentation for information on <code>pio project init</code> and other command line usage.</li> </ul> <p>Next, read one of the flashing guides to upload and run your project!</p>"},{"location":"docs/getting-started/#config-options-platformioini","title":"Config options (platformio.ini)","text":"<p>LibreTiny has a few configuration options that allow you to change its behavior or features. These can be defined, specified or changed in the platformio.ini configuration file for your project.</p> <p>Refer to the LibreTiny Configuration manual for details.</p>"},{"location":"docs/getting-started/#gpio-usage-important-change","title":"GPIO usage - important change","text":"<p>Important</p> <p>As of LibreTiny release v1.0.0, references to GPIO pins using their <code>D#</code> numbers has been deprecated and should no longer be used in new projects.</p> <p>If your program is using Arduino I/O functions, please refer to the migration guide on how to modify your code accordingly.</p>"},{"location":"docs/getting-started/#examples","title":"Examples","text":"<ul> <li>PinScan</li> </ul>"},{"location":"docs/getting-started/gpio/","title":"GPIO usage instructions","text":"<p>Note</p> <p>This has changed since v1.0.0. Refer to the migration guide for more info.</p>  <p>GPIO pins can be accessed in a few ways:</p> <ul> <li>using the raw GPIO number of the chip</li> <li>using the \"function macro\" of the pin</li> <li>using Arduino digital pin numbers (<code>D#</code>, deprecated)</li> </ul> <p>This applies both to Arduino code and ESPHome YAML configs.</p>"},{"location":"docs/getting-started/gpio/#gpio-numbers-arduino-only","title":"GPIO numbers - Arduino only","text":"<p>The simplest form of GPIO access is by using raw pin numbers of the CPU (just like on ESP8266/ESP32). For example, to access GPIO6, write <code>digitalRead(6)</code>.</p>"},{"location":"docs/getting-started/gpio/#function-macros-arduino-esphome","title":"Function macros - Arduino &amp; ESPHome","text":"<p>If you go to a board documentation page (like this one - CB2S) you'll see a pinout drawing, containing various labels in small blocks. There's also a table below to make the pinout a bit more clear.</p> <p>You can use any of these labels to access a particular pin. For example, to access GPIO6, which is also the PWM0 pin on CB2S, one can use:</p> <ul> <li><code>digitalRead(PIN_P6)</code> (Arduino) or <code>pin: P6</code> (ESPHome)</li> <li><code>digitalRead(PIN_PWM0)</code> (Arduino) or <code>pin: PWM0</code> (ESPHome)</li> </ul>"},{"location":"docs/getting-started/gpio/#arduino-d-numbers-deprecated","title":"Arduino <code>D#</code> numbers (deprecated)","text":"<p>This method of accessing pins is deprecated since v1.0.0, and will (probably) be removed in the future. It's kept for legacy compatibility.</p> <p>To access the previously mentioned GPIO6, use <code>digitalRead(D2)</code> or <code>digitalRead(PIN_D2)</code> or <code>pin: D2</code>. Note that the <code>D#</code> pin numbers are not consistent between boards (for example, on WB3S, GPIO6 is already D4).</p>"},{"location":"docs/inc/find-board/","title":"Find board","text":"<p>You need to know which board your device uses. Head to Supported Boards to find it. A good number of popular boards have their dedicated support and documentation pages in LibreTiny. Otherwise, you have to use one of the Generic boards that matches the CPU model of your device.</p>"},{"location":"docs/inc/flashing-note/","title":"Flashing note","text":"<p>Read this!</p> <p>This is probably the most important part of the docs - flashing firmware to the chip.</p> <p>This is why you're here. Please read this section carefully, and only then start flashing firmware.</p>"},{"location":"docs/inc/ota-cloudcutter/","title":"Ota cloudcutter","text":""},{"location":"docs/inc/ota-cloudcutter/#converting-devices-with-tuya-cloudcutter","title":"Converting devices with tuya-cloudcutter","text":"<p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p>Grab the <code>image_bk7231x_app.ota.ug.bin</code> file from the build directory - take care to choose the correct file. It must have \"OTA\" and \"UG\" in its name.</p> <p>Next, refer to Using tuya-cloudcutter guide.</p>"},{"location":"docs/inc/ota-openbeken/","title":"Ota openbeken","text":""},{"location":"docs/inc/ota-openbeken/#migrating-from-openbeken-ota","title":"Migrating from OpenBeken (OTA)","text":"<p>OpenBeken is a custom, Tasmota-like firmware for non-ESP chips. Currently, this part of the guide applies to BK7231 only, as that's the only chip supported both by LT and OBK.</p> <p>OBK is compatible with standard Beken OTA packages, but the web panel does a filename check to prevent chip type mismatch. Grab the <code>image_bk7231t_app.ota.rbl</code> file from build directory (note: without \"UG\" in the name!), rename it to something like <code>OpenBK7231T_esphome.rbl</code> (change T to N depending on the chip type), and drop it on the OTA panel.</p>"},{"location":"docs/inc/uart-adr/","title":"Uart adr","text":"<p>If you have a recent version of LibreTiny already installed on the chip, you don't need to perform any steps to enter download mode. Instead, Auto-download-reboot will reboot the chip automatically, as soon as it notices the flasher program. This is enabled by default, so you don't have to configure anything.</p>"},{"location":"docs/inc/uart-cen/","title":"Uart cen","text":"<p>Note</p> <p>\"CEN\" pin is the RESET pin - connecting it to GND will keep the chip in \"reset\" state. Disconnecting it will allow the chip to start back up.</p> <p>If you're having issues with using CEN pin (or if it's not accessible on your device) you can toggle the 3.3V power instead. Removing power will keep it in \"reset\", and applying it back will start it again.</p>"},{"location":"docs/inc/uart-info/","title":"Uart info","text":"<p>The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides to learn how to connect your device.</p>"},{"location":"docs/inc/uart-ltchiptool/","title":"Uart ltchiptool","text":""},{"location":"docs/inc/uart-ltchiptool/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/inc/uart-power/","title":"Uart power","text":"<p>Important</p> <p>Using a good, stable 3.3V power supply is crucial. Most flashing issues are caused by either voltage drops during intensive flash operations, or bad/loose wires. The UART adapter's 3.3V power regulator is usually not enough.</p> <p>Instead, a regulated bench power supply, or a linear 1117-type regulator is recommended.</p>"},{"location":"docs/platform/SUMMARY/","title":"Flashing guides","text":"<ul> <li>Beken BK72xx</li> <li>Realtek RTL8710Bx</li> <li>Lightning LN882x</li> </ul>"},{"location":"docs/platform/beken-72xx/","title":"Beken 72xx","text":""},{"location":"docs/platform/beken-72xx/#introduction","title":"Introduction","text":"<p>Also read</p> <ul> <li>Finding encryption keys - what to do if LibreTiny doesn't boot because of incorrect flash encryption keys</li> </ul>  <p>Beken BK7231 is a family of Wi-Fi and BLE microcontrollers, of which most popular are BK7231N and BK7231T.</p> <p>Features:</p> <ul> <li>ARM968E-S (ARMv5TE) CPU (120 MHz)</li> <li>256 KiB SRAM</li> <li>built-in 2 MiB SPI flash with XiP</li> <li>802.11b/g/n Wi-Fi</li> </ul> <p>Resources:</p> <ul> <li>BK7231U Datasheet v0.71 (Machine-translated to English)</li> <li>BL2028N Datasheet v1.0 (BL2028N is a \"clone\" of BK7231N)</li> <li>BK72XX SDK User Manual 3.0.3 (Machine-translated to English)</li> <li>BEKEN WiFi SDK API Reference 3.0.27 (Machine-translated to English)</li> <li>Beken SDK documentation (online)</li> <li><code>encrypt v0.3</code> source code (Encryption routines and FPGA code used on the chip)</li> <li><code>ota_tools</code> source code</li> <li>BK7231 OpenOCD debugging (From Elektroda.pl user <code>@xabean</code>)</li> </ul>"},{"location":"docs/platform/beken-72xx/#finding-your-board","title":"Finding your board","text":"<p>You need to know which board your device uses. Head to Supported Boards to find it. A good number of popular boards have their dedicated support and documentation pages in LibreTiny. Otherwise, you have to use one of the Generic boards that matches the CPU model of your device.</p>"},{"location":"docs/platform/beken-72xx/#flashing","title":"Flashing","text":"<p>Read this!</p> <p>This is probably the most important part of the docs - flashing firmware to the chip.</p> <p>This is why you're here. Please read this section carefully, and only then start flashing firmware.</p>  <p>BK7231 has two UART ports - UART2 (sometimes called LOG_UART) and UART1. The UART1 port is used for flashing (and external components, such as TuyaMCU) and has no text output. The UART2 port is used for log viewing only.</p> <p>You need to find which pins correspond to UART1 TX and RX. If your board is supported, you'll find the pinout on its documentation page. Otherwise (and for generic boards), you'll have to find the pinout online.</p> <p>For best experience, you should have two USB&lt;-&gt;UART adapters plugged in:</p> <ul> <li>One for flashing, preferably a real FT232RL or a good alternative. This connects to UART1 of the chip.</li> <li>One for log output - BK72xx outputs messages on a separate port. You can have a terminal session continuously open on this adapter. This connects to UART2 of the chip - but it's not necessary for flashing.</li> </ul>"},{"location":"docs/platform/beken-72xx/#wiring","title":"Wiring","text":"<p>Connect UART1 of the BK7231 to the USB-TTL adapter:</p>    PC BK7231     RX TX1 (GPIO11 / P11)   TX RX1 (GPIO10 / P10)   GND GND     <p>Important</p> <p>Using a good, stable 3.3V power supply is crucial. Most flashing issues are caused by either voltage drops during intensive flash operations, or bad/loose wires. The UART adapter's 3.3V power regulator is usually not enough.</p> <p>Instead, a regulated bench power supply, or a linear 1117-type regulator is recommended.</p>   <p>Note</p> <p>\"CEN\" pin is the RESET pin - connecting it to GND will keep the chip in \"reset\" state. Disconnecting it will allow the chip to start back up.</p> <p>If you're having issues with using CEN pin (or if it's not accessible on your device) you can toggle the 3.3V power instead. Removing power will keep it in \"reset\", and applying it back will start it again.</p>  <p>The download mode is entered when the chip communicates with the flasher program. Hence, the first step is running the flasher program (described below). While the program is trying to establish communication, the chip has to be rebooted. In order to do that, you need to bridge CEN pin to GND with a wire.</p> <p>Keep in mind that BK7231T (not N) will exit the download mode when it can't communicate with the flasher (or when the flasher finishes its work). It's not possible to forcefully enter download mode without it.</p> <p>After linking with the chip, the flasher program will begin writing (or reading) the firmware automatically. If that doesn't happen, try resetting the chip again until it works.</p> <p>If you're getting a <code>No response received</code> (or similar) error, this means that:</p> <ul> <li>the power supply is too weak (read above)</li> <li>you're resetting the chip too quickly, i.e. you resetted it after the program started communicating with it</li> </ul>"},{"location":"docs/platform/beken-72xx/#flashing_1","title":"Flashing","text":"<p>The recommended tool to flash (or dump firmware) is <code>ltchiptool</code>.</p> <p>Read Using ltchiptool to learn the flashing procedure</p>  <p>Tip</p> <p>BK7231N can't be software-bricked, because it has a ROM that contains the download mode. BK7231T doesn't contain it, so be careful with this one.</p> <p><code>ltchiptool</code>'s Beken flashing program is based on bk7231tools. Refer to the guide for information how to use it, but keep in mind that using the ltchiptool GUI is probably just easier.</p>"},{"location":"docs/platform/beken-72xx/#auto-download-reboot","title":"Auto-download-reboot","text":"<p>If you have a recent version of LibreTiny already installed on the chip, you don't need to perform any steps to enter download mode. Instead, Auto-download-reboot will reboot the chip automatically, as soon as it notices the flasher program. This is enabled by default, so you don't have to configure anything.</p>"},{"location":"docs/platform/beken-72xx/#single-uart-adapter-usage","title":"Single UART adapter usage","text":"<p>If you only have a single adapter, or just want to use the UART1 (upload) port only, you can change the logging port of LibreTiny firmware.</p> <p>Refer to Options &amp; config (<code>Serial output</code> section). Set <code>LT_UART_DEFAULT_PORT</code> to <code>1</code>, which will use UART1 for all output.</p>"},{"location":"docs/platform/beken-72xx/#firmware-output-files","title":"Firmware output files","text":"<p>These files are present in the build directory after successful compilation:</p>    File Description     firmware.uf2 UF2 package for UART and OTA upload   image_bk7231t_app.ota.rbl Beken OTA package (e.g. OpenBeken)   image_bk7231t_app.ota.ug.bin Tuya OTA package (incl. Cloudcutter)   image_bk7231t_app.0x011000.rbl App partition - flashable at 0x11000   image_bk7231t_app.0x011000.crc Encrypted app image - not for flashing   image_bk7231t_app.0x129F0A.rblh RBL header - not for flashing"},{"location":"docs/platform/beken-72xx/#spi-flashing-unbricking-bk7231t","title":"SPI flashing (unbricking BK7231T)","text":"<p>The bk7231_spi_flasher.py script can be used to put BK7231 in SPI flashing mode. Then, one can use flashrom to read/write the raw flash chip.</p>"},{"location":"docs/platform/beken-72xx/#other-toolsguides","title":"Other tools/guides","text":"<p>These tools are not recommended and are kept here for reference only. Don't use them, please.</p> <ul> <li>Flashing (Tuya manual)</li> <li>BkWriter v1.6.0</li> <li>hid_download_py</li> </ul>"},{"location":"docs/platform/beken-72xx/#other-info","title":"Other info","text":"<p>There are many chip variations in this SoC family:</p> <ul> <li>BK7231 - marked BK7231QN40, so we're calling it \"BK7231Q\" to reduce confusion</li> <li>BK7231T</li> <li>BK7231N</li> <li>BK7231S</li> <li>BK7231U</li> </ul> <p>The \"officially existing\" ones are BK7231Q, BK7231N and BK7231U. These are supported by Beken SDKs, such as <code>bdk_freertos</code>, although <code>bk7231s_alios_sdk</code> also existed at some point.</p> <ul> <li>BK7231N is substantially different than the other chips, so running T code on N (and vice versa) is not directly possible.</li> <li>BK7231Q does not have eFuse and BLE</li> <li>there are some references to U meaning USB support</li> <li>T seems to be exclusive to Tuya boards (that would explain the name); in the T SDK from Tuya, <code>CFG_SOC_NAME</code> is set to <code>SOC_BK7231U</code></li> <li>T's bootloader greets with <code>BK7231S_1.0.5</code> on UART</li> </ul> <p>Regarding <code>bdk_freertos</code>:</p> <ul> <li><code>make</code> allows selecting for which MCU the code should be compiled</li> <li><code>make bk7231</code> doesn't compile at all</li> <li><code>make bk7231u</code> doesn't run on T with Tuya's bootloader (1.0.5), though it works just fine after replacing the bootloader with one of these included with <code>bdk_freertos</code> (1.0.8) (yes, even <code>bk7231n</code> bootloader)</li> <li>after making a few changes to <code>driver/entry</code> and <code>driver/intc</code> (so it looks more like the code from T SDK) <code>bdk_freertos</code> runs just fine</li> </ul>"},{"location":"docs/platform/beken-72xx/keys/","title":"Finding encryption keys","text":""},{"location":"docs/platform/beken-72xx/keys/#introduction","title":"Introduction","text":"<p>Tip</p> <p>Before proceeding with this method, try using ltchiptool's <code>Get chip info</code> function. It will read eFuse, which may reveal the raw encryption key. If you see all <code>00000000</code>s, then the eFuse is readout-protected and the key cannot be extracted in this simple way.</p>  <p>3-rd party firmware for Beken chips must be compiled with a flash encryption key matching the one programmed into the chip. Incorrect keys will make the firmware unable to run.</p> <p>The <code>bk72xx-bootloader-dump</code> firmware might make it easier to find the encryption key of BK7231N/BK7231T chips.</p> <p>The key is made of four 32-bit integers; the default key is usually <code>510fb093 a3cbeadc 5993a17e c7adeb03</code> (used by Beken and Tuya on most devices), but devices with different keys have been recently discovered (likely from other manufacturers).</p> <p>If your device doesn't use the default keys (i.e. 3-rd party firmware doesn't boot up, or it hangs on bootloader logs), you can try using this firmware file to extract the keys from the bootloader.</p>"},{"location":"docs/platform/beken-72xx/keys/#why-this-works-and-when-it-doesnt","title":"Why this works (and when it doesn't)","text":"<p>The bootloader has its own copy of the keys. It uses that to encrypt firmware on-the-fly when applying OTA updates.</p> <p>Files downloaded during an OTA update are not encrypted using the main encryption keys, so the bootloader must encrypt them before flashing to the app partition. This method works by flashing firmware directly to the OTA partition. It is then unpacked and encrypted properly by the bootloader.</p> <p>However, OTA update packages are encrypted using AES - for this method to work, the AES key must be known in advance.</p> <p>Most of the time, a simple <code>0123456789ABCDEF</code> key is used for OTA AES. We have seen manufacturers using different keys - this method will not work in that case.</p> <p>Additionally, OTA packages don't have to be encrypted - some bootloaders allow that, some don't. Using an unencrypted package is worth trying if your device uses a non-standard OTA AES key.</p>"},{"location":"docs/platform/beken-72xx/keys/#prerequisites","title":"Prerequisites","text":"<ol> <li>A working computer with a working UART flashing setup. The preferred flashing tool is ltchiptool. You should have at least some prior experience with dumping or flashing firmware.</li> <li>A full factory firmware dump of the device you're working on. This is mostly in case something goes wrong, but may also be necessary to read OTA partition offsets from.</li> <li>A serial terminal (such as the <code>ltchiptool-terminal</code> plugin).</li> </ol>"},{"location":"docs/platform/beken-72xx/keys/#to-be-continued","title":"To be continued","text":""},{"location":"docs/platform/lightning-ln882x/","title":"Lightning LN882x","text":""},{"location":"docs/platform/lightning-ln882x/#introduction","title":"Introduction","text":"<p>Lightning LN882x is a family of Wi-Fi and BLE microcontrollers designed for indoor short-range IoT.</p> <p>Features:</p> <ul> <li>32-bit Cortex M4F CPU (160 MHz)</li> <li>296 KiB SRAM</li> <li>built-in 512 KiB to 2 MiB flash with XiP</li> <li>802.11b/g/n Wi-Fi</li> <li>Bluetooth 5.1 (LN882H only)</li> </ul> <p>Resources:</p> <ul> <li>LN882H  : MCU Combo Wi-Fi/BLE IoT</li> <li>LN882H Datasheet  : LN882H Datasheet</li> <li>LN882H DOC  : Official LN882H Document Collection</li> <li>LN882H SDK  : Official LN882H SDK</li> <li>LN882X SDK  : Official LN882X SDK</li> <li>LN8825A/B : Wi-Fi SOC</li> <li>LN8825A/B SDK : Official LN8825A/B SDK</li> <li>Flashing tool (GUI) : Flashing tool with GUI (chinese)</li> <li>Flashing tool (CMD) : Command-line Flashing tool</li> </ul>"},{"location":"docs/platform/lightning-ln882x/#finding-your-board","title":"Finding your board","text":"<p>You need to know which board your device uses. Head to Supported Boards to find it. A good number of popular boards have their dedicated support and documentation pages in LibreTiny. Otherwise, you have to use one of the Generic boards that matches the CPU model of your device.</p>"},{"location":"docs/platform/lightning-ln882x/#flashing","title":"Flashing","text":"<p>Read this!</p> <p>This is probably the most important part of the docs - flashing firmware to the chip.</p> <p>This is why you're here. Please read this section carefully, and only then start flashing firmware.</p>  <p>LN882x has two UART ports - The UART0 port is used for flashing and text output.</p> <p>You need to find which pins correspond to UART0 TX and RX. If your board is supported, you'll find the pinout on its documentation page. Otherwise (and for generic boards), you'll have to find the pinout online.</p>"},{"location":"docs/platform/lightning-ln882x/#wiring","title":"Wiring","text":"<p>Connect UART0 of the LN882H to the USB-TTL adapter:</p>    PC LN882H     RX TX0 (GPIOA2 / P2)   TX RX0 (GPIOA3 / P3)   GND GND     <p>Important</p> <p>Using a good, stable 3.3V power supply is crucial. Most flashing issues are caused by either voltage drops during intensive flash operations, or bad/loose wires. The UART adapter's 3.3V power regulator is usually not enough.</p> <p>Instead, a regulated bench power supply, or a linear 1117-type regulator is recommended.</p>   <p>Note</p> <p>\"CEN\" pin is the RESET pin - connecting it to GND will keep the chip in \"reset\" state. Disconnecting it will allow the chip to start back up.</p> <p>If you're having issues with using CEN pin (or if it's not accessible on your device) you can toggle the 3.3V power instead. Removing power will keep it in \"reset\", and applying it back will start it again.</p>  <p>The download mode is entered when the chip communicates with the flasher program. Hence, the first step is running the flasher program (described below). While the program is trying to establish communication, the chip has to be rebooted. In order to do that, you need to bridge BOOT1 pin to GND with a wire before powering the chip.</p> <p>After linking with the chip, the flasher program will begin writing (or reading) the firmware automatically. If that doesn't happen, try resetting the chip again until it works.</p> <p>If you're getting a <code>No response received</code> (or similar) error, this means that:</p> <ul> <li>the power supply is too weak (read above)</li> <li>you're resetting the chip too quickly, i.e. you resetted it after the program started communicating with it</li> </ul>"},{"location":"docs/platform/lightning-ln882x/#flashing_1","title":"Flashing","text":"<p>The recommended tool to flash (or dump firmware) is <code>ltchiptool</code>.</p> <p>Read Using ltchiptool to learn the flashing procedure</p>  <p>Tip</p> <p>Because the UART uploading code is programmed in the ROM of the chip, it can't be software-bricked, even if you damage the bootloader.</p>"},{"location":"docs/platform/lightning-ln882x/#firmware-output-files","title":"Firmware output files","text":"<p>These files are present in the build directory after successful compilation:</p>    File Description     firmware.uf2 UF2 package for UART and OTA upload   image_firmware.0x000000.bin Full flash binary image - flashable at 0x0   image_boot.0x000000.bin Boot partition binary image - flashable at 0x0   image_part_tab.0x006000.bin Partition table binary image - flashable at 0x6000   image_app.0x007000.bin Application partition binary image - flashable at 0x7000   image_ota.0x133000.bin OTA partition binary image - flashable at 0x133000"},{"location":"docs/platform/lightning-ln882x/#other-toolsguides","title":"Other tools/guides","text":"<ul> <li> <p>Official command-line flashing tool</p> <p>Usage Examples: <code>LN882H_CMD_Tool.exe COM1 download flash 921600 0x0 image_firmware.0x000000.bin</code> <code>LN882H_CMD_Tool.exe COM1 download flash 921600 0x7000 image_app.0x007000.bin</code></p> </li> </ul>"},{"location":"docs/platform/lightning-ln882x/debugging/","title":"Debugging","text":"<p>Debugging of Lightning LN882x chips is possible and was tested with a JLink probe on OpenOCD and JLinkGDBServer.</p> <p>(the following is applicable to Arduino framework, and was not tested with SDK framework)</p> <p>LibreTiny has ready-to-use OpenOCD config files:</p> <ul> <li>platform/lightning-ln882x/openocd/ln882x.cfg</li> </ul>"},{"location":"docs/platform/lightning-ln882x/debugging/#local-debugger","title":"Local debugger","text":"<p>It should be possible to use PlatformIO's built-in debugging capabilities directly, when plugging an OpenOCD-compatible debugger into your PC. As there are no debugger interfaces built into these IoT boards, you need to specify your interface of choice in <code>platformio.ini</code>:</p> <p><pre><code>[env:my_board]\nopenocd_interface = &lt;interface name&gt;\n</code></pre> where <code>&lt;interface name&gt;</code> is for example <code>raspberrypi2-native</code>, <code>stlink</code>, etc.</p>"},{"location":"docs/platform/lightning-ln882x/debugging/#jlink-configuration","title":"JLink configuration","text":"<pre><code>[env:my_board]\nboard = ln-02\ndebug_tool = custom\ndebug_server =\n    ../JLink_Linux_V698e_x86_64/JLinkGDBServerExe\n    -singlerun\n    -if\n    SWD\n    -select\n    USB\n    -port\n    3333\n    -device\n    Cortex-M4\ndebug_init_cmds =\n    define pio_reset_halt_target\n        monitor reset\n    end\n    target extended-remote $DEBUG_PORT\n    ;monitor speed auto\n    monitor reset\n    $LOAD_CMDS\n    $INIT_BREAK\nupload_protocol = custom\nupload_flags =\n    -auto\n    -startapp\n    -exit\nupload_command = ../JLink_Linux_V698e_x86_64/JFlashExe -openprj\"../JLink_Linux_V698e_x86_64/ln882h.jflash\" -open\"${BUILD_DIR}/image_firmware.bin\",0 $UPLOAD_FLAGS\ndebug_init_break = tbreak Reset_Handler\n</code></pre>"},{"location":"docs/platform/lightning-ln882x/debugging/#technical-details","title":"Technical details","text":"<p>GDB is first configured with <code>mem 0x0000000 0x1000000 ro</code> in order to mark flash memory as read-only. This makes GDB use hardware breakpoints, as software BPs don't work on these boards.</p>"},{"location":"docs/platform/realtek-amb/","title":"Realtek Ameba","text":"<p>The logic behind naming of Realtek chips and their series took me some time to figure out:</p> <ul> <li>RTL8xxxA - Ameba1/Ameba Series</li> <li>RTL8xxxB - AmebaZ Series</li> <li>RTL8xxxC - AmebaZ2/ZII Series</li> <li>RTL8xxxCS - Ameba CS Series</li> <li>RTL8xxxD - AmebaD Series</li> <li>Realtek product pages</li> </ul> <p>As such, there are numerous CPUs with the same numbers but different series. Different Ameba series are not compatible with each other, which makes them require different code and SDKs.</p>   Ameba series comparison table"},{"location":"docs/platform/realtek-amb/#table-from-wwwe-paper-displaycom","title":"Table from www.e-paper-display.com","text":"<p>(modified a bit)</p>    Realtek P/N Series Protocol CPU Frequency SRAM UART SPI I2S ADC/DAC     RTL8710BN Ameba Z WiFi ARM M4 125M 256KB 1 1 N Y/N   RTL8710BX Ameba Z WiFi ARM M4 62.5M 256KB 1 1 N Y/N   RTL8710CX Ameba Zii WiFi ARM M4 100M 256KB 3 1 N N/N   RTL8710CM Ameba Zii WiFi ARM M4 100M 256K+4M 3 1 N N/N   RTL8720CN Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CF Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CM Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CS Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512KB 2 2 Y Y/Y   RTL8721CSM Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512K+4M 3 2 Y Y/Y   RTL8722CSM Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512K+4M 4 2 Y Y/Y   RTL8720DN Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K 2 1 Y Y/Y   RTL8721DM Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K+4M 3 2 Y Y/Y   RTL8722DM Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K+4M 4 2 Y Y/Y"},{"location":"docs/platform/realtek-amb/#other-chips","title":"Other chips","text":"<ul> <li>RTL8195AM</li> <li>RTL8710AF (found in amb1_arduino)</li> <li>RTL8711AM</li> <li>RTL8710BN</li> <li>RTL8710BX (found in Tuya product pages)</li> <li>RTL8710B? (found in amb1_sdk)</li> <li>RTL8711B? (found in amb1_sdk)</li> <li>RTL8710CM</li> <li>RTL8722CSM (found in ambd_arduino)</li> <li>RTL8720DN (found in ambd_arduino)</li> <li>RTL8721DM</li> <li>RTL8722DM (found in ambd_arduino)</li> </ul>"},{"location":"docs/platform/realtek-ambz/","title":"Realtek AmebaZ","text":""},{"location":"docs/platform/realtek-ambz/#introduction","title":"Introduction","text":"<p>Realtek AmebaZ is a family of Wi-Fi microcontrollers, primarily consisting of two chips - RTL8710BN and RTL8710BX.</p> <p>RTL8710BX seems to be the same chip but clocked at 62.5 MHz (instead of 125 MHz for BN). However, it seems that firmware compiled for either of the chips can run on the other with no issues.</p> <p>Features:</p> <ul> <li>ARM Cortex M4 CPU (up to 125 MHz)</li> <li>512 KiB ROM</li> <li>256 KiB SRAM</li> <li>SPI flash interface with XiP</li> <li>802.11b/g/n Wi-Fi</li> </ul> <p>Resources:</p> <ul> <li>Realtek Ameba-Z datasheet v3.4</li> <li>Realtek product page</li> <li>Realtek PDFs for Ameba1/AmebaZ</li> <li>Ameba1/AmebaZ SDK</li> </ul>"},{"location":"docs/platform/realtek-ambz/#finding-your-board","title":"Finding your board","text":"<p>You need to know which board your device uses. Head to Supported Boards to find it. A good number of popular boards have their dedicated support and documentation pages in LibreTiny. Otherwise, you have to use one of the Generic boards that matches the CPU model of your device.</p>"},{"location":"docs/platform/realtek-ambz/#flashing","title":"Flashing","text":"<p>Realtek RTL8710B has two UART ports - UART2 (sometimes called LOG_UART) and UART0. The port used for flashing and viewing logs is UART2.</p> <p>You need to find which pins correspond to UART2 TX and RX. If your board is supported, you'll find the pinout on its documentation page. Otherwise (and for generic boards), you'll have to find the pinout online.</p>  <p>Tip</p> <p>You need a good USB&lt;-&gt;UART adapter for the process. Some chips may not support 1.5M baud rate, required by the ROM for the initial handshake. Widespread PL2303 is currently known not to work, at least under Windows. FT232RL is verified to work reliably.</p>"},{"location":"docs/platform/realtek-ambz/#wiring","title":"Wiring","text":"<p>Connect UART2 of the Realtek chip to the USB-TTL adapter:</p>    PC RTL8710B     RX TX2 (Log_TX / PA30)   TX RX2 (Log_RX / PA29)   GND GND     <p>Important</p> <p>Using a good, stable 3.3V power supply is crucial. Most flashing issues are caused by either voltage drops during intensive flash operations, or bad/loose wires. The UART adapter's 3.3V power regulator is usually not enough.</p> <p>Instead, a regulated bench power supply, or a linear 1117-type regulator is recommended.</p>  <p>In order to flash the chip, you need to enable download mode. This is done by resetting the chip while pulling down the TX2 pin.</p>  <p>Note</p> <p>\"CEN\" pin is the RESET pin - connecting it to GND will keep the chip in \"reset\" state. Disconnecting it will allow the chip to start back up.</p> <p>If you're having issues with using CEN pin (or if it's not accessible on your device) you can toggle the 3.3V power instead. Removing power will keep it in \"reset\", and applying it back will start it again.</p>  <p>Do this, in order:</p> <ul> <li>connect CEN to GND</li> <li>connect TX2 to GND</li> <li>release CEN from GND</li> <li>release TX2 from GND</li> </ul> <p>To find out whether download mode is enabled, open a serial terminal (such as PuTTY) on your PC. You should see a few characters printed to the serial console every second (usually some kind of grey blocks, or other non-letter characters).</p> <p>Note that you will not see any characters before you release TX2 from GND.</p>"},{"location":"docs/platform/realtek-ambz/#partition-layout","title":"Partition layout","text":"<p>When you compile firmware for Realtek with LibreTiny (either ESPHome or other PlatformIO projects), you need to choose a board. Different Realtek boards have different partition layouts - the main difference is the OTA2 firmware address. Choosing a board with wrong address will make it harder to flash OTA updates.</p> <p>Flashing over UART will update (set) the on-chip OTA address to match the firmware being flashed. OTA flashing will not update the address - so make sure to choose the correct board, and keep using the same board for OTA flashing.</p> <p>Using incorrect boards may result in OTA updates having no effect, or (worst case) bricking the device completely.</p>"},{"location":"docs/platform/realtek-ambz/#flashing_1","title":"Flashing","text":"<p>The recommended tool to flash (or dump firmware) is <code>ltchiptool</code>.</p> <p>Read Using ltchiptool to learn the flashing procedure</p>  <p>Tip</p> <p>Because the UART uploading code is programmed in the ROM of the chip, it can't be software-bricked, even if you damage the bootloader.</p>"},{"location":"docs/platform/realtek-ambz/#auto-download-reboot","title":"Auto-download-reboot","text":"<p>If you have a recent version of LibreTiny already installed on the chip, you don't need to perform any steps to enter download mode. Instead, Auto-download-reboot will reboot the chip automatically, as soon as it notices the flasher program. This is enabled by default, so you don't have to configure anything.</p>"},{"location":"docs/platform/realtek-ambz/#firmware-output-files","title":"Firmware output files","text":"<p>These files are present in the build directory after successful compilation:</p>    File Description     firmware.uf2 UF2 package for UART and OTA upload   image_ota1.0x00B000.bin OTA 1 image, flashable to 0xB000   image_ota2.0x0D0000.bin OTA 2 image, flashable to 0xD0000 (the address might be different)"},{"location":"docs/platform/realtek-ambz/#other-toolsguides","title":"Other tools/guides","text":"<p>These tools are not recommended and are kept here for reference only. Don't use them, please.</p> <ul> <li>Flashing (Tuya manual)</li> <li>ImageTool (AmebaZ/AmebaD)</li> <li>rtltool.py</li> </ul> <p>OTA1/2 files can be flashed using <code>ImageTool_v2.3.1_AmebaZ(8710b)</code>. Browse and select one of the files and enter an appropriate address. Select COM port, press <code>Open</code> and then <code>Download</code>.</p> <p>This method is not recommended, as it requires you to know the currently enabled OTA index (1 or 2). Flashing the wrong file will either not make any changes, or upload firmware which won't run.</p>"},{"location":"docs/platform/realtek-ambz/debugging/","title":"Debugging","text":"<p>Debugging of Realtek Ameba chips is possible and was tested with OpenOCD running remotely on a Raspberry Pi.</p> <p>(the following is applicable to Arduino framework, and was not tested with SDK framework)</p> <p>LibreTiny has ready-to-use OpenOCD config files:</p> <ul> <li>platform/realtek-ambz/openocd/amebaz.cfg</li> </ul>"},{"location":"docs/platform/realtek-ambz/debugging/#local-debugger","title":"Local debugger","text":"<p>It should be possible to use PlatformIO's built-in debugging capabilities directly, when plugging an OpenOCD-compatible debugger into your PC. As there are no debugger interfaces built into these IoT boards, you need to specify your interface of choice in <code>platformio.ini</code>: <pre><code>[env:my_board]\nopenocd_interface = &lt;interface name&gt;\n</code></pre> where <code>&lt;interface name&gt;</code> is for example <code>raspberrypi2-native</code>, <code>stlink</code>, etc.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#remote-debugger","title":"Remote debugger","text":"<p>Using a Raspberry Pi is probably the easiest option (and cheapest, as everyone has a spare Pi laying around).</p> <p>Connect your Realtek board to your Pi, as per Programming Microcontrollers using OpenOCD on a Raspberry Pi.</p> <p>Check out RPi BCM2711 GPIOs to read more about BCM pin mappings.</p> <p>TL;DR: Install OpenOCD. Conenct A14 to BCM GPIO#11, A15 to BCM GPIO#25. Remember to join GND together. Refer to boards/ for pinouts.</p>  <p>Note</p> <p>On Raspberry Pi 4, additional config might be needed: <pre><code>bcm2835gpio peripheral_base 0xFE000000\nbcm2835gpio speed_coeffs 236181 60\n</code></pre> Save the lines to a .cfg file, and pass it to OpenOCD using <code>-f file.cfg</code>. Read more here.</p>  <p>Start OpenOCD like this (you also need your config file in the working directory): <pre><code>sudo openocd -f interface/raspberrypi2-native.cfg -f amebaz.cfg -c \"bindto 0.0.0.0\"\n</code></pre> The bindto line is important, as it will allow remote connections.</p> <p>Configure <code>platformio.ini</code> not to start local OpenOCD: <pre><code>[env:my_board]\ndebug_tool = custom\ndebug_port = 192.168.0.33:3333\ndebug_server =\n</code></pre> Replace IP with your Pi's address.</p> <p>Done, go to PlatformIO in VSCode (or whatever you're using) and click <code>Start Debugging</code>.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#openocd-output","title":"OpenOCD output","text":"<p>OpenOCD should show this if everything is connected properly: <pre><code>alpine:~$ sudo openocd -f interface/raspberrypi2-native.cfg -f amebaz.cfg -c \"bindto 0.0.0.0\"\nOpen On-Chip Debugger 0.11.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nBCM2835 GPIO nums: swclk = 11, swdio = 25\n\nWarn : Interface already configured, ignoring\nInfo : Listening on port 6666 for tcl connections\nInfo : Listening on port 4444 for telnet connections\nInfo : BCM2835 GPIO JTAG/SWD bitbang driver\nInfo : clock speed 1001 kHz\nInfo : SWD DPIDR 0x2ba01477\nInfo : rtl8711b.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : starting gdb server for rtl8711b.cpu on 3333\nInfo : Listening on port 3333 for gdb connections\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#auto-reset","title":"Auto reset","text":"<p>PlatformIO will reset your board by default when starting debugging. Sometimes this may not be desired. Also the current config is a bit buggy: VSCode thinks the board is halt, but it's actually running so you need to press continue for that first time.</p> <p>To disable auto reset before and after debugging: <pre><code>[env:my_board]\ndebug_init_cmds =\n  target extended-remote $DEBUG_PORT ; remove this line if you're debugging locally\n  $INIT_BREAK\n;   monitor reset halt\n  $LOAD_CMDS\n  monitor init\n;   monitor reset halt\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#technical-details","title":"Technical details","text":"<p>GDB is first configured with <code>mem 0x8000000 0x8200000 ro</code> in order to mark flash memory as read-only. This makes GDB use hardware breakpoints, as software BPs don't work on these boards.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#more-powerful-playground","title":"More powerful playground","text":"<pre><code>Microsoft Windows [Version 6.1.7601]\n\nKuba@KUBA-PC C:\\Users\\Kuba\n# telnet 192.168.0.33 4444\nOpen On-Chip Debugger\n&gt; mdw 0x8000000\n0x08000000: 96969999\n\n&gt; halt\ntarget halted due to debug-request, current mode: Thread\nxPSR: 0x61000000 pc: 0x0000b462 msp: 0x1003ef5c\n&gt; reg\n===== arm v7m registers\n(0) r0 (/32): 0x035a9584\n(1) r1 (/32): 0x00000015\n[...]\n===== Cortex-M DWT registers\n\n&gt; resume\n&gt;\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#useful-openocd-commands","title":"Useful OpenOCD commands","text":"<p>Run them in your power playground.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#soft-reset","title":"Soft reset","text":"<p>Doesn't even disconnect from WiFi (which confuses the code and makes it disconnect anyway). <pre><code>mww 0xE000ED0C 0x05FA0007\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#uart-upload-mode","title":"UART upload mode","text":"<pre><code>mww 0x40000138 0x8\nmww 0xE000ED0C 0x05FA0007\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#hard-fault","title":"Hard Fault","text":"<pre><code>halt\nreg pc 0\nresume\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#rom-dump","title":"ROM dump","text":"<pre><code>&gt; dump_image rom2.bin 0x0 0x80000\ndumped 524288 bytes in 14.041406s (36.464 KiB/s)\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#flash-dump","title":"Flash dump","text":"<pre><code>&gt; dump_image flash.bin 0x8000000 0x200000\ndumped 2097152 bytes in 54.447296s (37.614 KiB/s)\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#efuse-dump","title":"Efuse dump","text":"<p>(or something that looks like it) <pre><code>&gt; dump_image efuse.bin 0x40000000 0x400\ndumped 1024 bytes in 0.026813s (37.295 KiB/s)\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/exception-decoder/","title":"Exception decoder","text":"<p>Configure built-in hard fault decoder in <code>platformio.ini</code>:</p> <pre><code>[env:my_board]\nmonitor_speed = 115200\nmonitor_filters = rtl_hard_fault_decoder\n</code></pre>"},{"location":"docs/projects/esphome/","title":"ESPHome","text":"<p>Tip</p> <p>See the Cloudcutter video guide for a complete tutorial on flashing with Cloudcutter and installing LibreTiny-ESPHome. Includes Home Assistant Add-On setup.</p>  <p>LibreTiny is now natively supported by ESPHome in versions 2023.9.0 and later.</p> <p>There are three basic ways to install and use ESPHome. You can choose the option that best suits you:</p> <ul> <li>ESPHome Dashboard (GUI) - for new users, might be an easy way to go; config management &amp; compilation using web-based dashboard</li> <li>command line (CLI) - for more experienced users; compilation using CLI commands, somewhat easier to troubleshoot</li> <li>Home Assistant Add-On - using ESPHome in Home Assistant as an add-on</li> </ul>  <p>Important</p> <p>If you have the LibreTiny-ESPHome add-on installed in Home Assistant, migrate your YAML files over to the official ESPHome add-on.</p> <p>The standalone add-on is now deprecated - after migrating your configs, uninstall the old add-on.</p>"},{"location":"docs/projects/esphome/#find-your-devices-board","title":"Find your device's board","text":"<p>Go to Boards &amp; CPU list, find your board (chip model), click on it and remember the <code>Board code</code>. This will be used later, during config creation.</p> <p>If your board isn't listed, use one of the Generic boards, depending on the chip type of your device.</p>"},{"location":"docs/projects/esphome/#download-esphome","title":"Download ESPHome","text":"GUICLI   <p>For this, you need Docker, Docker Compose and Python installed. After running the commands, you'll have a running ESPHome Dashboard interface that you can connect to.</p> <ol> <li>Open a terminal/cmd.exe.</li> <li> <p>Create a <code>docker-compose.yml</code> file in a directory of choice:</p> docker-compose.yml<pre><code>version: \"3\"\nservices:\n  esphome:\n    container_name: esphome\n    image: ghcr.io/esphome/esphome:latest\n    volumes:\n      - ./configs:/config:rw # (1)!\n      - /etc/localtime:/etc/localtime:ro\n    restart: always\n    privileged: false\n    network_mode: host\n</code></pre> <ol> <li>You can change <code>./configs</code> to another path, in which your ESPHome configs will be stored.</li> </ol> </li> <li> <p>Start the container using <code>docker-compose up</code>. You should be able to open the GUI on http://localhost:6052/.</p> </li> </ol>    <p>Important</p> <p>Read Getting started first - most importantly, the first part about installation.</p>  <p>Assuming you have PlatformIO, git and Python installed:</p> <ol> <li>Open a terminal/cmd.exe</li> <li><code>git clone https://github.com/esphome/esphome</code></li> <li><code>cd</code> into the newly created <code>esphome</code> directory.</li> <li>Check if it works by typing <code>python -m esphome</code></li> </ol>  <p>Tip</p> <p>You can alternately install ESPHome CLI using pip with <code>pip install esphome</code></p>"},{"location":"docs/projects/esphome/#create-your-device-config","title":"Create your device config","text":"GUICLI   <ol> <li>Open the GUI on http://localhost:6052/ (or a different IP address if you're running on a Pi).</li> <li>Go through the wizard steps:<ul> <li><code>New Device</code></li> <li><code>Continue</code></li> <li>enter name and WiFi details (first time only)</li> <li>LibreTiny will not currently be listed as an option, choose any of the boards and you will overwrite them later</li> <li>select <code>Skip</code></li> </ul> </li> <li>A new config file will be added. Press <code>Edit</code> and proceed to the next section.</li> <li>Delete the entire generated configuration and replace it with the example configuration below or one generated by UPK2ESPHome.</li> </ol>   <ol> <li>Create a YAML config file for your device. You can either:<ul> <li>use <code>python -m esphome wizard yourdevice.yml</code> - type answers to the six questions the wizard asks, OR:</li> <li>write a config file manually:     yourdevice.yml<pre><code>esphome:\n  name: yourdevice\n\nbk72xx:  # adjust accordingly: bk72xx or rtl87xx\n  board: cb2s  # THIS IS YOUR BOARD CODE\n  framework:\n    version: latest\n\nlogger:\nweb_server:\ncaptive_portal:\napi:\nota:\n\nwifi:\n  ssid: !secret wifi_ssid\n  password: !secret wifi_password\n  ap:\n</code></pre></li> </ul> </li> </ol>"},{"location":"docs/projects/esphome/#automatically-generate-config","title":"Automatically generate config","text":"<p>Instead of adding components manually and writing everything from scratch, you can use UPK2ESPHome to generate a working config (for supported BK7231 devices only). If your device has a Cloudcutter profile, there's a high chance it can have a generated config.</p>"},{"location":"docs/projects/esphome/#add-components","title":"Add components","text":"<p>Now, just like with standard ESPHome on ESP32/ESP8266, you need to add components for your device. Visit ESPHome homepage to learn about YAML configuration. If you want, you can upload an \"empty\" config first, and add actual components later.</p>  <p>Important</p> <p>It's highly recommended to always include the <code>web_server</code> and <code>captive_portal</code> components - even in your first \"empty\" upload.</p> <p>Adding these two components will safeguard you against accidentally soft-bricking the device, by e.g. entering invalid Wi-Fi credentials. The Web Server provides an easy way to flash a new image over-the-air, and the Captive Portal allows to easily open the Web Server on a fallback AP.</p>"},{"location":"docs/projects/esphome/#build-upload","title":"Build &amp; upload","text":"GUICLI   <p>Close the config editor. Press the three dots icon and select <code>Install</code>. Choose <code>Manual download</code> and <code>Modern format</code>. The firmware will be compiled and a UF2 file will be downloaded automatically.</p>   <p>The command <code>python -m esphome compile yourdevice.yml</code> will compile ESPHome.</p>    <p>Now, refer to the flashing guide to learn how to upload ESPHome to your device. There's also info on using <code>tuya-cloudcutter</code> in that guide.</p>"},{"location":"docs/projects/esphome/#advanced-lt-configuration","title":"Advanced: LT configuration","text":"<p>Note</p> <p>This part is for advanced users. You'll probably be fine with the default options.</p>  <p>All options from Options &amp; config can be customized in the LibreTiny block:</p> yourdevice.yml<pre><code>bk72xx:\n  framework:\n    version: latest\n  lt_config:\n    LT_LOG_HEAP: 1\n    LT_UART_DEFAULT_PORT: 2\n    LT_UART_SILENT_ALL: 0\n</code></pre> <p>(this is only an example)</p> <p>Additionally, few options have their dedicated keys:</p> yourdevice.yml<pre><code>bk72xx:\n  framework:\n    version: latest\n  # verbose/trace/debug/info/warn/error/fatal\n  loglevel: warn\n  # suppress chip's SDK log messages\n  # (same as LT_UART_SILENT_ALL above)\n  sdk_silent: true\n  # disable SWD/JTAG so that all GPIOs can be used\n  # set to false if you want to attach a debugger\n  gpio_recover: true\n</code></pre> <p>(these values are defaults)</p>"},{"location":"docs/projects/esphome/#advanced-using-development-versions-with-esphome","title":"Advanced: Using development versions with ESPHome","text":"<p>There are a two ways to use development versions of LibreTiny with ESPHome:</p> <ul> <li><code>version</code> is a required field, and must match a specific format, it is recommended to use <code>\"0.0.0\"</code> for custom development</li> <li><code>source</code> must point to where your development version of LibreTiny resides.</li> </ul> GitLocal   <pre><code>bk72xx:\n  framework:\n    version: \"0.0.0\"\n    source: \"https://github.com/libretiny-eu/libretiny\"\n</code></pre> <p>Source can be post-fixed to checkout a specified branch or a Pull Request:</p> <ul> <li>Branch: add <code>#branch_name</code> (ex: <code>source: \"https://github.com/libretiny-eu/libretiny#experimental_branch_name\"</code>)</li> <li>Pull Requests: Pull requests currently require you to check out the source branch of the pull request. To get this information, visit the PR, click on the source branch, and copy their git address and apply the branch their PR uses (ex: <code>https://github.com/pr_user/libretiny#pr_branch</code>)</li> </ul>   <p>Check out with Git (recommended) or download and extract a copy of LibreTiny to your local file system running ESPHome.</p> <pre><code>bk72xx:\n  framework:\n    version: \"0.0.0\"\n    source: \"/local_path_to_libretiny\"\n</code></pre>"},{"location":"docs/resources/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Documents</li> <li>Tuya Pinout Config</li> <li>Beken Flash Chip List</li> </ul>"},{"location":"docs/resources/beken-flash/","title":"Beken Flash Chip List","text":"Chip ID Location Manufacturer Device Size SR Size Line Mode CMP Post Protect Post Protect Mask Protect All Protect None Protect Half Unprotect Last Block QE Bit Post QE Bit M Value Mode Sel Unprotect Protect cwMsk sb lb SR Read SR Write     <code>00 00 00</code> BDK na DEFAULT 4 MiB 2 2 0 2 0x1F 0x00 0x00 0x00 0x000 0 0 0x00 0x01          <code>0B 40 14</code> BDK xtx / XT 25F08B 1 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0C 0x101 9 1 0xA0 0x01          <code>0B 40 15</code> HDP,BDK xtx / XT 25F16B 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 40 16</code> HDP,BDK xtx / XT 25F32B 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 40 17</code> HDP,BDK xtx / XT 25F64B 8 MiB 2 2 14 2 0x1F 0x05 0x00 0x0E 0x109 9 1 0xA0 0x01 0x00 0x07 BIT(14)or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 60 17</code> HDP xtx / XT 25Q64B 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0E 40 16</code> BDK xtx / FT 25H32 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01          <code>1C 31 13</code> HDP xtx / PN 25F04B 512 KiB 1             0x00 0x07 BFD(0x0f,2,4) 2 4 <code>05</code> <code>01</code>   <code>1C 41 16</code> HDP ESMT 25QH32A 4 MiB 1             0x00 0x07 BFD(0xf,2,5) 2 4 <code>05</code> <code>01</code>   <code>1C 70 15</code> HDP,BDK EN / ESMT 25QH16B 2 MiB 1 2 0 2 0x1F 0x1F 0x00 0x0d 0x0d 0 0 0xA5 0x01 0x00 0x07 BFD(0xf,2,5) 2 4 <code>05</code> <code>01</code>   <code>1C 70 16</code> BDK en 25QH32B 4 MiB 1 2 0 2 0x1F 0x1F 0x00 0x16 0x01B 0 0 0xA5 0x01          <code>20 40 16</code> BDK xmc 25QH32B 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01          <code>51 40 13</code> HDP GD 25D40 512 KiB 1             0x00 0x07 BFD(0x0f,2,3) 2 3 <code>05</code> <code>01</code>   <code>51 40 14</code> HDP GD 25D80 1 MiB 1             0x00 0x07 BFD(0x0f,2,3) 2 3 <code>05</code> <code>01</code>   <code>5E 40 14</code> HDP xtx / PN 25F08B 1 MiB 1             0x00 0x07 BFD(0x0f,2,4) 2 4 <code>05</code> <code>01</code>   <code>85 60 13</code> HDP Puya 25Q40 512 KiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 14</code> HDP Puya 25Q80 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 16</code> HDP Puya 25Q32H 4 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 17</code> HDP Puya 25Q64H 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C2 23 14</code> HDP WH 25V8035F 1 MiB 2             0x00 0x07 BIT(12) or BFD(0x1f,2,4) 2 5 <code>05 15</code> <code>01</code>   <code>C2 23 15</code> BDK mx 25V16B 2 MiB 1 2 0 2 0x0F 0x0F 0x00 0x0A 0x00E 6 1 0xA5 0x01          <code>C2 23 15</code> HDP WH 25V1635F 2 MiB 2             0x00 0x07 BIT(12) or BFD(0x1f,2,4) 2 5 <code>05 15</code> <code>01</code>   <code>C8 40 13</code> HDP GD 25Q41B 512 KiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>C8 40 14</code> HDP GD 25D80 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 40 15</code> HDP,BDK GD 25Q16 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 40 16</code> HDP,BDK GD 25Q32 4 MiB 1 2 0 2 0x1F 0x1F 0x00 0x0E 0x00E 0 0 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 15</code> HDP GD 25WQ16E 2 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 16</code> HDP GD 25WQ32E 4 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 17</code> HDP GD 25WQ64E 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>CD 60 14</code> HDP TH 25Q80HB 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>E0 40 13</code> HDP BY / PN 25Q40A 512 KiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>E0 40 14</code> HDP BY / PN 25Q80A 1 MiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>EB 60 15</code> HDP,BDK zg / TH 25Q16(H)B 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>EF 40 16</code> BDK w 25Q32BFJ 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x00 0x101 9 1 0xA0 0x01          <code>EF 40 18</code> HDP WB 25Q128JV 16 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>"},{"location":"docs/resources/documents/","title":"Documents","text":""},{"location":"docs/resources/documents/#realtek","title":"Realtek","text":"Code Name       From ambd_sdk   AN0004 Realtek low power wi-fi mp user guide   AN0011 Realtek wlan simple configuration   AN0012 Realtek secure socket layer(ssl)   AN0025 Realtek at command   AN0075 Realtek Ameba-all at command v2.0   AN0096 Realtek Ameba-all xmodem uart update firmware   AN0400 Ameba-D Application Note   UM0150 Realtek Ameba CoAP User Guide   UM0201 Ameba Common BT Application User Manual EN     Found elsewhere   AN0400 Ameba-D Application Note_v3_watermark   AN0500 Realtek Ameba-ZII application note     Realtek Ameba-ZII datasheet v0.8"},{"location":"docs/resources/tuya-pin-config/","title":"Tuya Pinout Config","text":"<p>Device configuration (<code>user_param_key</code>) can be extracted to JSON, using bk7231tools from a full firmware dump.</p> <p>Also see:</p> <ul> <li>UPK2ESPHome</li> </ul> <p>Sources:</p> <ul> <li><code>tuya_demo_light_pwm</code> for Lights/bulbs</li> <li>Original post by @blakadder on Discord channel #resources</li> </ul>    Key(s) Meaning Possible values     <code>crc</code> UPK data checksum    <code>module</code> Tuya module used <code>CB3S</code> / <code>WB3S</code> / <code>CBU</code>, etc.   <code>category</code> Device type as a number 0502 - CW light0505 - RGBCW light   <code>Jsonver</code><code>jv</code> \"JSON\" version    Common     <code>netled_pin</code><code>netled1_pin</code><code>wfst_pin</code> Status LED for WiFi    <code>netled_lv</code><code>netled1_lv</code><code>wfst_lv</code> Status LED Active Level 0 - Active low1 - Active high   <code>netled_reuse</code>     <code>reset_pin</code> + <code>reset_lv</code> Reset Button Pin + Active Level    <code>reset_t</code> Button press time to reset the device 3/5/6/9/10 seconds   <code>iicscl</code> I\u00b2C SCL Pin    <code>iicsda</code> I\u00b2C SDA Pin    <code>net_trig</code>     <code>net_type</code>     <code>wfct</code>     Lights/bulbs     <code>cmod</code> Color Mode <code>rgbcw</code> / <code>rgb</code> / <code>cw</code> / <code>c</code> / <code>rgbc</code>   <code>dmod</code> Light driver type 0 - PWM1 - SM16726B2 - SM2135E3 - SM2135EH4 - SM2135EJ5 - BP1658CJ6 - BP5758D7 - SM2235/2335   <code>cwtype</code> Color temperature driver 0 - cool and warm white (CW)1 - correlated color temperature (CCT)   <code>onoffmode</code> On/off gradient enabled 0 / 1   <code>pmemory</code> Power-off memory enabled 0 / 1   <code>defcolor</code> Default Color <code>c</code> / <code>r</code>   <code>defbright</code> Default Brightness 0%-100%   <code>deftemp</code> Default Color Temperature 0-100 when defcolor is cool white   <code>cwmaxp</code> Cold-Warm Max Power 100-200 with a pitch of 10   <code>brightmin</code>, <code>brightmax</code> Min/Max Brightness 0%-100%   <code>colormin</code>, <code>colormax</code> RGB Min/Max Brightness 0%-100%   <code>cwmin</code>, <code>cwmax</code> Cold-Warm Min/Max Brightness 0%-100%   <code>colormaxp</code> RGB Max Power 0%-100%   <code>colorpfun</code> Color mixing power limit enabled 0 / 1   <code>brightstep</code><code>bristep</code> Brightness Step    <code>hsvstep</code>     <code>rgbt</code> Used in prod.tests, not relevant    <code>title20</code> \"title20/T20\" supported 0 / 1   Gamma correction     <code>gmr</code>, <code>gmg</code>, <code>gmb</code>     <code>gmkr</code>, <code>gmkg</code>, <code>gmkb</code>     <code>gmwr</code>, <code>gmwg</code>, <code>gmwb</code>     PWM Lights     <code>r_pin</code> + <code>r_lv</code> Red Channel Pin + Active Level    <code>g_pin</code> + <code>g_lv</code> Green Channel Pin + Active Level    <code>b_pin</code> + <code>b_lv</code> Blue Channel Pin + Active Level    <code>c_pin</code> + <code>c_lv</code> Cool White Pin + Active Level    <code>w_pin</code> + <code>w_lv</code> Warm White Pin + Active Level    <code>pwmhz</code> PWM Operating Frequency (Hz)    I\u00b2C Lights     <code>dccur</code><code>ehccur</code><code>cjccur</code> Cold White Current    <code>dwcur</code><code>ehwcur</code><code>cjwcur</code> Warm White Current    <code>drgbcur</code> RGB Current    <code>campere</code> Max current of SM2135 colored output 10-45 with a pitch of 5 and defaults to 20   <code>wampere</code> Max current of SM2135 white output 10-80 with a pitch of 5 and defaults to 30   <code>iicr</code> Red Channel Number 0-5   <code>iicg</code> Green Channel Number 0-5   <code>iicb</code> Blue Channel Number 0-5   <code>iicc</code> Cold White Channel Number 0-5   <code>iicw</code> Warm White Channel Number 0-5   <code>iicccur</code> Cold White Current 0   <code>iicwcur</code> Warm White Current 5   Sockets/switches     <code>btX_pin</code> + <code>btX_lv</code> Button X Pin + Active Level    <code>btX_type</code><code>bt_type</code> Button X Trigger Type 0 - level_trig1 - edge_trig   <code>rlX_pin</code> + <code>rlX_lv</code> Relay X Pin + Active Level    <code>rlX_type</code><code>rl_type</code> Relay X Type 0 - Electric holding relay1 - Magnetic holding relay   <code>rl_onX_pin</code> + <code>rl_onX_lv</code> Relay ON Pin + Active Level    <code>rl_offX_pin</code> + <code>rl_offX_lv</code> Relay OFF Pin + Active Level    <code>rl1_dr_type</code>     <code>rl_drvtime</code>     <code>total_bt_pin</code> + <code>total_bt_lv</code>     Power monitoring     <code>ele_fun_en</code> Power Monitoring Enabled 0 / 1   <code>chip_type</code> Power Monitoring Chip Type 0 - BL09371 - HLW80122 - HLW80324 - BL0942   <code>ele_pin</code> CF Pin    <code>vi_pin</code> CF1 Pin    <code>sel_pin_pin</code> + <code>sel_pin_lv</code> SEL Pin + Active Level Active level is usually 1   <code>lose_vol</code> Under voltage threshold in V    <code>over_cur</code> Overcurrent threshold in mA    <code>over_vol</code> Overvoltage threshold in V    <code>sample_resistor</code> Current shunt resistor value 1 - 1m\u03a92 - 2m\u03a9   <code>vol_def</code> Socket operating voltage 0 - 220V1 - 110V   <code>work_voltage</code> Socket operating voltage    Infrared     <code>irfunc</code> IR Function enabled 0 / 1   <code>infre</code> IR Transmitter Pin    <code>infrr</code><code>ir</code> IR Receiver Pin    <code>irkXfun</code> + <code>irkXval</code> IR Key X Function + Value X in 1..30   <code>irnightt</code>     <code>irstep</code>     <code>wgmod</code>, <code>swgmod</code>, <code>scgmod</code>     PIR     <code>pirmod</code>     <code>pirfreq</code> PWM Operating Frequency (Hz) for PIR 1000   <code>pirlduty</code>  100   <code>pirmduty</code>  50   <code>pirhduty</code>  0   <code>pirin_pin</code> + <code>pirin_lv</code> Motion reporting GPIO + Active Level    <code>pirsense_pin</code> + <code>pirsense_lv</code> PIR sensitivity (PWM) + Active Level    <code>pirrange</code>     <code>pirwarn</code>     Ambient light sensor     <code>day</code> Value to compare against ADC readout ADC value range (0-3300)   <code>dusk</code> Value to compare against ADC readout ADC value range (0-3300)   <code>evenfall</code> Value to compare against ADC readout ADC value range (0-3300)   <code>evening</code> Value to compare against ADC readout ADC value range (0-3300)   <code>night</code> Value to compare against ADC readout ADC value range (0-3300)   Key-controlled     <code>key_pin</code> + <code>key_lv</code> Key Pin + Active Level    <code>kXpin_pin</code> + <code>kXpin_lv</code>     <code>kXdfunc</code>, <code>kXlfunc</code>, <code>kXsfunc</code>     <code>kXldir</code>, <code>kXsdir</code>     <code>keyccfg1</code>, <code>keyccfg2</code>     <code>keyfunc</code>, <code>keyglobefunc</code>     <code>keylt</code>, <code>keynumber</code>     Pairing-related     <code>wfcfg</code> Wi-Fi pairing config <code>spcl</code> / <code>spcl_auto</code> / <code>prod</code> / <code>old</code> / <code>low</code>   <code>remdmode</code> \"light reset pairing mode\" 0 / 1   <code>rstnum</code> On/off cycles to reset    <code>rstcor</code> Light color while connecting <code>c</code> / <code>r</code>   <code>rstbr</code> Light brightness while connecting 10-100   <code>rsttemp</code> Light temperature while connecting 0-100   <code>remdtime</code> Pairing mode timeout seconds   <code>wfptime</code> Light pairing time minutes   <code>cagt</code> Used in prod.tests, not relevant N/A   <code>prodagain</code> Used in prod.tests, not relevant 0 / 1   <code>rstmode</code> Pairing related - not relevant    <code>pairt</code> Pairing related - not relevant 6-600   <code>wt</code> Used in prod.tests, not relevant N/A   Other     <code>buzzer_pwm</code> Buzzer working PWM frequency    <code>ismusic</code>  0 / 1   <code>ledX_pin</code> + <code>ledX_lv</code> LED X Pin + Active Level    <code>led_pin</code> + <code>led_lv</code> LED Pin + Active Level    Unknown     <code>0err</code>     <code>1err</code>     <code>adclimit</code>     <code>aging</code>     <code>alarm1_time</code>     <code>alarm_t1</code>     <code>backlit_dp</code>     <code>backlit_select</code>     <code>bitseq</code>     <code>bleonoff</code>     <code>blindt</code>     <code>buzzer</code>     <code>cctseg</code>     <code>cd_flag2</code>     <code>cdsval</code>     <code>ch1_stat</code>     <code>ch_cddpidX</code>  X in 1..4   <code>ch_dpidX</code>  X in 1..4   <code>ch_flagX</code>  X in 1..4   <code>ch_num</code>     <code>clean_t</code>     <code>cntdown1</code>     <code>ctrl_lv</code>     <code>ctrl_pin</code>     <code>customcode</code>     <code>cyc_dpid</code>     <code>dctrl_select</code>     <code>dimmod</code>     <code>dimt</code>     <code>dimval</code>     <code>door1_magt_lv</code>     <code>door1_magt_pin</code>     <code>door_alarm_st1</code>     <code>door_mag1</code>     <code>ffc_select</code>     <code>inch_dp</code>     <code>indep_cfgbt</code>     <code>init_conf</code>     <code>knum</code>     <code>ktime</code>     <code>leaderr</code>     <code>led_dp</code>     <code>lfunc</code>     <code>light_status_select</code>     <code>lock_dp</code>     <code>lockt</code>     <code>micpin</code>     <code>mixway</code>     <code>mutex</code>     <code>mxcl_led_m</code>     <code>netn_led</code>     <code>netnc</code>     <code>nety_led</code>     <code>netyc</code>     <code>nightbrig</code>     <code>nightcct</code>     <code>nightled</code>     <code>notdisturb</code> Do not disturb (DND) mode enabled 0 / 1   <code>on_off_cnt</code>     <code>onoff1</code>     <code>onoff_clear_t</code>     <code>onoff_n</code>     <code>onoff_rst_m</code>     <code>onoff_rst_type</code>     <code>onoff_type</code>     <code>onofftime</code>     <code>owm</code>     <code>preheatt</code>     <code>rand_dpid</code>     <code>remote_add_dp</code>     <code>remote_list_dp</code>     <code>remote_select</code>     <code>resistor</code>     <code>reuse_led_m</code>     <code>rsthold</code>     <code>scenespct</code>     <code>series_ctrl</code>     <code>sfunc</code>     <code>standtime</code>     <code>starterr</code>     <code>step_rate</code>     <code>switch1</code>     <code>tempmix</code>     <code>tempstep</code>     <code>total_stat</code>     <code>tracetime1</code>     <code>trigdelay</code>     <code>trigmod</code>     <code>trl1_time</code>     <code>voice_ctrl1</code>     <code>voice_ctrl_set1</code>     <code>whiteseg</code>     <code>zero_select</code>"},{"location":"docs/status/supported/","title":"Supported boards, modules and CPUs","text":""},{"location":"docs/status/supported/#board-list","title":"Board list","text":"Name MCU Flash RAM Pins* Wi-Fi BLE ZigBee Family name     Generic           BK7231N (Tuya QFN32) BK7231N 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   BK7231T (Tuya QFN32) BK7231T 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   BK7252 BK7252 4 MiB 512 KiB 38 (38 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7251</code>   LN882HKI LN882HK 2 MiB 295 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   RTL8710BN (2M/468k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BN (2M/788k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BX (4M/980k) RTL8710BX 4 MiB 256 KiB 17 (17 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8720CF (2M/992k) RTL8720CF 2 MiB 256 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   99iot(Shenzhen)co.,ltd           AFW121T RTL8710BX 1 MiB 256 KiB 21 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Ai-Thinker Co., Ltd.           BW12 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   BW15 RTL8720CF 2 MiB 256 KiB 16 (13 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Tuya Inc.           CB1S BK7231N 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2L BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2S BK7231N 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3L BK7231N 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3S BK7231N 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3SE BK7231N 2 MiB 256 KiB 22 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CBLC5 BK7231N 2 MiB 256 KiB 6 (3 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CBU BK7231N 2 MiB 256 KiB 21 (18 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WB2L-M1 BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WA2 BK7231Q 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>beken-7231q</code>   WB1S BK7231T 2 MiB 256 KiB 22 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB2L BK7231T 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB2S BK7231T 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB3L BK7231T 2 MiB 256 KiB 21 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB3S BK7231T 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WBLC5 BK7231T 2 MiB 256 KiB 6 (3 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WR1 RTL8710BN 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR1E RTL8710BN 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2 RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2E RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3 RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3E RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3N RTL8710BN 2 MiB 256 KiB 16 (10 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2L RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2LE RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3L RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3LE RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Unknown           LSC LMA35 N BK7231N 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   LSC LMA35 T BK7231T 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   LN-02 LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   WB02A LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   WL2S LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   T102-V1.1 RTL8710BN 2 MiB 256 KiB 11 (9 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   T112-V1.1 RTL8710BN 2 MiB 256 KiB 14 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   T103-V1.0 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>    <p>* I/O count includes GPIOs, ADCs, PWM outputs and UART, but doesn't count CEN/RST and power pins.</p>"},{"location":"docs/status/supported/#cpu-list","title":"CPU list","text":"<p>Chips currently supported by the project:</p>  <ul> <li>BK7231N</li> <li>BK7231Q</li> <li>BK7231T</li> <li>BK7252</li> <li>LN882HC</li> <li>LN882HF</li> <li>LN882HK</li> <li>RTL8710BL</li> <li>RTL8710BN</li> <li>RTL8710BU</li> <li>RTL8710BX</li> <li>RTL8710L0</li> <li>RTL8711BN</li> <li>RTL8711BU</li> <li>RTL8720CF</li> <li>RTL8720CM</li> <li>BK7231S (BK7231T)</li> <li>BK7231U (BK7231T)</li> <li>BL2028N (BK7231N)</li> <li>MX1290 (RTL8710BN)</li> <li>MX1290V2 (RTL8710BX)</li> <li>RTL8720CX (RTL8720CM)</li> <li>W302 (RTL8710BN)</li> </ul> <p>This list is not exhaustive, i.e. a similar chip (but different package) might work just fine, but there's no board definition for it yet. If you have an unsupported chip, feel free to reach out using Issues or on the Discord server.</p>"},{"location":"docs/status/supported/#families","title":"Families","text":"<p>A list of chip families currently supported by this project.</p>  <p>Note</p> <p>The term family was chosen over platform, in order to reduce possible confusion between LibreTiny supported \"platforms\" and PlatformIO's \"platform\", as an entire package. Family is also more compatible with the UF2 term.</p>  <p>The following list corresponds to UF2 OTA format family names, and is also available as JSON. The IDs are also present in lt_types.h. You can view the family list by using <code>ltchiptool list families</code>.</p>     Title Name Code Short name &amp; ID Supported? Source SDK     Realtek Ameba1 <code>-</code> <code>-</code> <code>RTL8710A</code> (0x9FFFD543) \u274c -   Realtek AmebaZ <code>realtek-ambz</code> <code>ambz</code> <code>RTL8710B</code> (0x22E0D6FC) \u2714\ufe0f <code>framework-realtek-amb1</code>   Realtek AmebaZ2 <code>realtek-ambz2</code> <code>ambz2</code> <code>RTL8720C</code> (0xE08F7564) \u2714\ufe0f <code>framework-realtek-ambz2</code>   Realtek AmebaD <code>-</code> <code>-</code> <code>RTL8720D</code> (0x3379CFE2) \u274c -   Beken 7231Q <code>beken-7231q</code> <code>bk7231q</code> <code>BK7231Q</code> (0xAFE81D49) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7231T <code>beken-7231t</code> <code>bk7231t</code> <code>BK7231T</code> (0x675A40B0) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7231N <code>beken-7231n</code> <code>bk7231n</code> <code>BK7231N</code> (0x7B3EF230) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7251/7252 <code>beken-7251</code> <code>bk7251</code> <code>BK7251</code> (0x6A82CC42) \u2714\ufe0f <code>framework-beken-bdk</code>   Boufallo BL602/BL604 <code>-</code> <code>-</code> <code>BL60X</code> (0xDE1270B7) \u274c -   Lightning LN882H <code>lightning-ln882h</code> <code>ln882h</code> <code>LN882H</code> (0xA38090A8) \u2714\ufe0f <code>framework-lightning-ln882h</code>"},{"location":"docs/status/supported/#feature-support","title":"Feature support","text":"<p>If you notice a feature that you've tested, which works (or not) and doesn't match this table, feel free to submit an issue on GitHub.</p>      <code>BK7231T</code> <code>BK7231N</code> <code>RTL8710B</code> <code>RTL8720C</code> <code>BK7231Q</code> <code>LN882H</code>     Stability 5/5 5/5 4/5 2/5 1/5 3/5   LibreTiny Core \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f   Wiring Core \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f   PERIPHERALS (Core)         UART I/O \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f   Flash I/O \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f   Deep sleep \u2753 \u2714\ufe0f \u274c \u274c \u2753 \u274c   Watchdog timer \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f   PERIPHERALS (Wiring)         Digital I/O \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f   PWM \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u274c   Interrupts \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f   Analog input (ADC) \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f   <code>Wire</code> (I\u00b2C) \u274c \u274c \u2757 \u274c \u274c \u2753   <code>SPI</code> \u274c \u274c \u274c \u274c \u274c \u274c   <code>Serial</code> \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2714\ufe0f   <code>SoftwareSerial</code> \u274c \u274c \u2714\ufe0f \u274c \u274c \u274c   NETWORKING         Wi-Fi STA/AP/Mixed \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u274c \u2714\ufe0f   Wi-Fi Events \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u274c \u2714\ufe0f   OTA updates \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u274c \u274c \u2714\ufe0f   MDNS \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2753 \u2753 \u2714\ufe0f    <p>Symbols:</p> <ul> <li>\u2714\ufe0f working</li> <li>\u2753 untested</li> <li>\u2757 broken</li> <li>\u274c not implemented (yet?)</li> <li>- not applicable</li> </ul>"},{"location":"docs/status/supported/#unsupported-boards","title":"Unsupported boards","text":""},{"location":"docs/status/supported/#tuya-inc","title":"Tuya Inc.","text":"<p>Note</p> <p>Only modules featuring at least Wi-Fi are included in the table. (TY)JW, (TY)WE and (TY)LC Series are omitted, as they contain Espressif chips.</p>      Name MCU Flash RAM Pins Wi-Fi BLE ZigBee     AXY Series          AXY2S ECR6600 2 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3L ECR6600 2 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3S ECR6600 2 MiB 512 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   AXYU ECR6600 2 MiB 512 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CB Series          CB8P  BK7231N 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC9  BK7231N 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   CR Series          CR2S RTL8720CM 4 MiB 4 MiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   CR3L RTL8720CM 4 MiB 4 MiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CRG1 RTL8720CM 4 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   T1 Series          T1-2S T1A 1 MiB 288 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   T2 Series          T2-U  BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   TCS905 Series          TCS905-3S  BK7231N 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   TCS905-U  BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WB Series          WB8P  BK7231T 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC9  BK7231T 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   WBR Series          WBR1  RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2  RTL8720CF 2 MiB 256 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2L  RTL8720CF 2 MiB 256 KiB 7 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3  RTL8720CF 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3L  RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3S  RTL8720CF 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   WBRU  RTL8720CF 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3N RTL8720CS 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBRG1 RTL8720CSM 8 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WBR1D RTL8720DN 4 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2D RTL8720DN 4 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3D RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3T RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WL Series          WL2H-U LN882H ? 296 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WR Series          WR4  RTL8710BN 1 MiB 256 KiB 16 \u2714\ufe0f \u274c \u274c   WR5E  RTL8710BN 2 MiB 256 KiB 15 \u2714\ufe0f \u274c \u274c   WR6  RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WR6-H  RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WRG1 RTL8711AM 4 MiB 2 MiB 25 \u2714\ufe0f \u274c \u274c   WT Series          WT3  BK7231N 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WX Series          WXU T103C-HL 2 MiB 320 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   XR Series          XR1 XR809 2 MiB 384 KiB 18 \u2714\ufe0f \u274c \u274c   XR3 XR809 2 MiB 384 KiB 16 \u2714\ufe0f \u274c \u274c"},{"location":"docs/status/supported_boards/","title":"Supported boards","text":"Name MCU Flash RAM Pins* Wi-Fi BLE ZigBee Family name     Generic           BK7231N (Tuya QFN32) BK7231N 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   BK7231T (Tuya QFN32) BK7231T 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   BK7252 BK7252 4 MiB 512 KiB 38 (38 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7251</code>   LN882HKI LN882HK 2 MiB 295 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   RTL8710BN (2M/468k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BN (2M/788k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BX (4M/980k) RTL8710BX 4 MiB 256 KiB 17 (17 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8720CF (2M/992k) RTL8720CF 2 MiB 256 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   99iot(Shenzhen)co.,ltd           AFW121T RTL8710BX 1 MiB 256 KiB 21 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Ai-Thinker Co., Ltd.           BW12 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   BW15 RTL8720CF 2 MiB 256 KiB 16 (13 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Tuya Inc.           CB1S BK7231N 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2L BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2S BK7231N 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3L BK7231N 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3S BK7231N 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3SE BK7231N 2 MiB 256 KiB 22 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CBLC5 BK7231N 2 MiB 256 KiB 6 (3 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CBU BK7231N 2 MiB 256 KiB 21 (18 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WB2L-M1 BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WA2 BK7231Q 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>beken-7231q</code>   WB1S BK7231T 2 MiB 256 KiB 22 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB2L BK7231T 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB2S BK7231T 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB3L BK7231T 2 MiB 256 KiB 21 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WB3S BK7231T 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WBLC5 BK7231T 2 MiB 256 KiB 6 (3 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   WR1 RTL8710BN 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR1E RTL8710BN 2 MiB 256 KiB 18 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2 RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2E RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3 RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3E RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3N RTL8710BN 2 MiB 256 KiB 16 (10 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2L RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2LE RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3L RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3LE RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Unknown           LSC LMA35 N BK7231N 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   LSC LMA35 T BK7231T 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231t</code>   LN-02 LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   WB02A LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   WL2S LN882HK 2 MiB 295 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>lightning-ln882h</code>   T102-V1.1 RTL8710BN 2 MiB 256 KiB 11 (9 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   T112-V1.1 RTL8710BN 2 MiB 256 KiB 14 (11 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   T103-V1.0 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>"},{"location":"docs/status/supported_chips/","title":"Supported chips","text":"<ul> <li>BK7231N</li> <li>BK7231Q</li> <li>BK7231T</li> <li>BK7252</li> <li>LN882HC</li> <li>LN882HF</li> <li>LN882HK</li> <li>RTL8710BL</li> <li>RTL8710BN</li> <li>RTL8710BU</li> <li>RTL8710BX</li> <li>RTL8710L0</li> <li>RTL8711BN</li> <li>RTL8711BU</li> <li>RTL8720CF</li> <li>RTL8720CM</li> <li>BK7231S (BK7231T)</li> <li>BK7231U (BK7231T)</li> <li>BL2028N (BK7231N)</li> <li>MX1290 (RTL8710BN)</li> <li>MX1290V2 (RTL8710BX)</li> <li>RTL8720CX (RTL8720CM)</li> <li>W302 (RTL8710BN)</li> </ul>"},{"location":"docs/status/supported_families/","title":"Supported families","text":"Title Name Code Short name &amp; ID Supported? Source SDK     Realtek Ameba1 <code>-</code> <code>-</code> <code>RTL8710A</code> (0x9FFFD543) \u274c -   Realtek AmebaZ <code>realtek-ambz</code> <code>ambz</code> <code>RTL8710B</code> (0x22E0D6FC) \u2714\ufe0f <code>framework-realtek-amb1</code>   Realtek AmebaZ2 <code>realtek-ambz2</code> <code>ambz2</code> <code>RTL8720C</code> (0xE08F7564) \u2714\ufe0f <code>framework-realtek-ambz2</code>   Realtek AmebaD <code>-</code> <code>-</code> <code>RTL8720D</code> (0x3379CFE2) \u274c -   Beken 7231Q <code>beken-7231q</code> <code>bk7231q</code> <code>BK7231Q</code> (0xAFE81D49) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7231T <code>beken-7231t</code> <code>bk7231t</code> <code>BK7231T</code> (0x675A40B0) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7231N <code>beken-7231n</code> <code>bk7231n</code> <code>BK7231N</code> (0x7B3EF230) \u2714\ufe0f <code>framework-beken-bdk</code>   Beken 7251/7252 <code>beken-7251</code> <code>bk7251</code> <code>BK7251</code> (0x6A82CC42) \u2714\ufe0f <code>framework-beken-bdk</code>   Boufallo BL602/BL604 <code>-</code> <code>-</code> <code>BL60X</code> (0xDE1270B7) \u274c -   Lightning LN882H <code>lightning-ln882h</code> <code>ln882h</code> <code>LN882H</code> (0xA38090A8) \u2714\ufe0f <code>framework-lightning-ln882h</code>"},{"location":"docs/status/unsupported_boards_tuya_all/","title":"Unsupported boards tuya all","text":"Name MCU Flash RAM Pins Wi-Fi BLE ZigBee     AXY Series          AXY2S ECR6600 2 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3L ECR6600 2 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3S ECR6600 2 MiB 512 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   AXYU ECR6600 2 MiB 512 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CB Series          CB8P  BK7231N 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC9  BK7231N 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   CR Series          CR2S RTL8720CM 4 MiB 4 MiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   CR3L RTL8720CM 4 MiB 4 MiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CRG1 RTL8720CM 4 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   T1 Series          T1-2S T1A 1 MiB 288 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   T2 Series          T2-U  BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   TCS905 Series          TCS905-3S  BK7231N 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   TCS905-U  BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WB Series          WB8P  BK7231T 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC9  BK7231T 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   WBR Series          WBR1  RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2  RTL8720CF 2 MiB 256 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2L  RTL8720CF 2 MiB 256 KiB 7 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3  RTL8720CF 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3L  RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3S  RTL8720CF 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   WBRU  RTL8720CF 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3N RTL8720CS 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBRG1 RTL8720CSM 8 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WBR1D RTL8720DN 4 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2D RTL8720DN 4 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3D RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3T RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WL Series          WL2H-U LN882H ? 296 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WR Series          WR4  RTL8710BN 1 MiB 256 KiB 16 \u2714\ufe0f \u274c \u274c   WR5E  RTL8710BN 2 MiB 256 KiB 15 \u2714\ufe0f \u274c \u274c   WR6  RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WR6-H  RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WRG1 RTL8711AM 4 MiB 2 MiB 25 \u2714\ufe0f \u274c \u274c   WT Series          WT3  BK7231N 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WX Series          WXU T103C-HL 2 MiB 320 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   XR Series          XR1 XR809 2 MiB 384 KiB 18 \u2714\ufe0f \u274c \u274c   XR3 XR809 2 MiB 384 KiB 16 \u2714\ufe0f \u274c \u274c"},{"location":"examples/SUMMARY/","title":"Examples","text":"<ul> <li>PinScan</li> </ul>"},{"location":"examples/PinScan/","title":"PinScan","text":"<p>This example allows to quickly check all digital/analog pins of an IoT device.</p> <p>By using a simple TUI (text user interface), you can check which I/O pins correspond to i.e. button presses, as well as write to one of the pins to see which LED lights up.</p>  <p>Warning</p> <p>Messing with pins in a device can potentially damage some parts of it. Be careful when writing voltages to digital and PWM pins.</p>  <p>Uploading the example and opening up a terminal (e.g. PuTTY) presents this menu: <pre><code>LibreTiny v0.8.0, PinScan v1.0\nBoard: cb2s\nI/O count: 11\nDigital I/O count: 11\nAnalog input count: 1\n-------- UART2 --------\nCommands:\n        d - Check digital pins\n        a - Check analog pins\n        s - Select UART port\n        t - Toggle ANSI control codes\n        r - Reboot (for uploading)\n        q - Go back to menu, at any time\n        ? - Print help text, also for subcommands\n</code></pre></p> <p>The interface expects one-letter commands, without confirmation by <code>Enter</code>. The only part which expects an <code>Enter</code> keypress is inputting pin numbers and UART port numbers.</p> <p>Pressing <code>q</code> at any time goes back to the main menu, terminating the current process.</p>  <p>Note</p> <p>PinScan works best with a terminal supporting ANSI escape codes (PuTTY does), but this behavior can be disabled using <code>t</code>.</p>  <p>Switching to another UART port is possible (for example if the default port is on the pins you want to check) using <code>s</code> command. Do not change the port after using any I/O commands, as it won't work; reboot it using <code>r</code> before.</p> <p>By setting <code>USE_WIFI</code> in <code>main.h</code> to 1, a Telnet server is enabled on port 23. This allows to test I/O pins without having physical, wired access to the device (i.e. using OTA). Make sure to specify correct WiFi credentials.</p>  <p>Tip</p> <p>If your board isn't supported by LT yet, use one of the generic boards.</p> <p>If your board doesn't even have a known pinout, use <code>d</code>/<code>s</code> commands of PinScan to ease the mapping of all board pins.</p>"},{"location":"examples/PinScan/#digital-pins","title":"Digital pins","text":"<pre><code>Digital I/O\n-------- UART2 --------\nCommands:\n        r - Realtime readout of all pins\n        o - Read one pin continuously\n        s - Manual Scan - toggle each pin\n        h - Write HIGH to a pin\n        l - Write LOW to a pin\n        p - Output using pull up/down (default)\n        w - Output using write low/high (less safe)\n</code></pre>"},{"location":"examples/PinScan/#realtime-readout-of-all-pins","title":"Realtime readout of all pins","text":"<pre><code> D0  D1  D2  D3  D4  D5  D6  D7  D8  D9 D10\n LO  LO  HI  HI  HI  HI  LO  LO  --  --  LO\n</code></pre> <p>Screen contents will update when voltage on one of the pins changes. Pins marked with <code>--</code> mean the currently used UART port (which can be changed using <code>s</code> command; after reboot).</p>  <p>TL;DR</p> <p>Try pressing a button to see which pin changes.</p>"},{"location":"examples/PinScan/#read-one-pin-continuously","title":"Read one pin continuously","text":"<p>Enter the pin number, it will be probed until you press <code>q</code>.</p>"},{"location":"examples/PinScan/#manual-scan-toggle-each-pin","title":"Manual Scan - toggle each pin","text":"<pre><code> D0  D1  D2  D3  D4  D5  D6  D7  D8  D9 D10\n HI  LO  LO  LO  LO  LO  LO  LO  --  --  LO\n</code></pre> <p>A pin will be toggled every 500ms, starting with D0. Type <code>n</code> to move to the next pin.</p>  <p>TL;DR</p> <p>Go through the pins to see which lights up an LED.</p>"},{"location":"examples/PinScan/#write-highlow-to-a-pin","title":"Write HIGH/LOW to a pin","text":"<p>Self-explanatory.</p>"},{"location":"examples/PinScan/#output-using-pullwrite","title":"Output using pull/write","text":"<p>Outputs can be toggled by using internal pull-up/pull-down resistors, or by simply writing a voltage. Writing is more current-efficient, but is also less safe if something else supplies different voltage to the pin.</p> <p>This affects scan and write high/low commands.</p>  <p>TL;DR</p> <p>Use <code>write</code> output mode (carefully) if there's an LED which doesn't light up with default pull mode.</p>"},{"location":"examples/PinScan/#analog-pins","title":"Analog pins","text":"<pre><code>Analog inputs\n-------- UART2 --------\nCommands:\n        r - Realtime readout of all pins\n        o - Read one pin once\n</code></pre>"},{"location":"examples/PinScan/#realtime-readout-of-all-pins_1","title":"Realtime readout of all pins","text":"<p>Read voltage (in millivolts) on all available analog pins, until <code>q</code> is pressed.</p>"},{"location":"examples/PinScan/#read-one-pin-once","title":"Read one pin once","text":"<p>No need to explain.</p>"},{"location":"src/mkdoxy/","title":"MkDoxy","text":""},{"location":"src/mkdoxy/#mkdoxy-mkdocs-doxygen-easy-documentation-with-code-snippets","title":"MkDoxy -&gt; MkDocs + Doxygen. Easy documentation with code snippets.","text":""},{"location":"src/mkdoxy/#based-on-matusnovakdoxybook","title":"Based on  matusnovak/doxybook","text":"<p>This python tool is extension for MkDocs. Extension will take your programme source code and runs Doxygen. Than converts exported XML into markdown and create new folder with full generated documentation.  Next usage is by snippets inside documentation markdown.</p>"},{"location":"src/mkdoxy/#example-usage","title":"Example usage","text":"<ol> <li> <p>Generate class with name <code>rb::MotorChangeBuilder</code> <pre><code>::: doxy.Class\n    name: rb::MotorChangeBuilder\n</code></pre></p> </li> <li> <p>Generate method <code>brake (MotorId id, uint16_t brakingPower)</code> from class with name <code>rb::MotorChangeBuilderA</code> <pre><code>::: doxy.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n</code></pre></p> </li> <li> <p>Generate function with name <code>readUltra (bool async)</code> <pre><code>::: doxy.Function\n    name: readUltra (bool async)\n</code></pre></p> </li> <li> <p>Generate code snippet from file <code>RBCXLeds.cpp</code> <pre><code>::: doxy.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n</code></pre></p> </li> </ol>"},{"location":"src/mkdoxy/#requirements","title":"Requirements","text":""},{"location":"src/mkdoxy/#apt","title":"Apt","text":"<ul> <li>python 3.6 or newer -&gt; <code>sudo apt install python3</code> </li> <li>Pip -&gt; <code>sudo apt install python3-pip</code></li> <li>Git -&gt; <code>sudo apt install git</code></li> <li>Doxygen -&gt; <code>sudo apt install doxygen</code></li> </ul>"},{"location":"src/mkdoxy/#pip","title":"Pip","text":"<ul> <li>Jinja2 -&gt; <code>pip install jinja2</code></li> <li>Mkdocs -&gt; <code>pip install mkdocs</code></li> <li>ruamel.yaml -&gt; <code>pip install ruamel.yaml</code></li> </ul>"},{"location":"src/mkdoxy/#optional","title":"Optional:","text":"<ul> <li>mkdocs-material -&gt; <code>pip install mkdocs-material</code></li> </ul>"},{"location":"src/mkdoxy/#installation","title":"Installation","text":"<p>Install using Python Pip: https://pypi.org/project/mkdocs-doxygen-snippets-plugin/</p> <pre><code>pip install mkdocs-doxygen-snippets-plugin\n</code></pre> <p>Or Install manually:</p> <pre><code>git clone https://github.com/JakubAndrysek/mkdocs-doxygen-snippets-plugin.git\ncd mkdocs-doxygen-snippets-plugin\npython setup.py install\n</code></pre>"},{"location":"src/mkdoxy/#license","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2021 Kuba Andr\u00fdsek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/","title":"Snippets example","text":"Error: Did not exist project with name: esp <pre><code>::: doxy.esp.Function\n    name: int testFnc(float a, char b)\n    details: True\n    implements: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Function\n    name: testFnc(float a, char b)\n    details: True\n    implements: True\n</code></pre>    <pre><code>::: doxy.esp.Class\n    name: rb::MotorChangeBuilder\n    description: True\n    include: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_1","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class\n    name: rb::MotorChangeBuilder\n    description: True\n    include: True\n</code></pre>    <pre><code>::: doxy.esp.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n    details: False\n    include: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_2","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n    details: False\n    include: True\n</code></pre>    <pre><code>::: doxy.esp.Class.list\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_3","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.list\n</code></pre>    <pre><code>::: doxy.esp.Class.index          \n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_4","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.index\n</code></pre>    <pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_5","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n</code></pre>    <pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n    header: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_6","title":"Source code","text":"<pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n    header: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/","title":"Markdown test","text":"<p>I highly do not recommend to use markdown through Doxygen! The source markdown file will go through Doxygen to xml and then from xml through doxybook back into markdown. If you REALLY need to use markdown through Doxygen, it is here, but limited. IMHO, just write a simple shell script to copy the necessary markdown files into GitBook directly. Anyway, the markdown below is copied from here: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet and most of it works through doxybook.</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#headers","title":"Headers","text":"<pre><code># H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\n\nAlternatively, for H1 and H2, an underline-ish style:\n\nAlt-H1\n======\n\nAlt-H2\n------\n</code></pre>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h1","title":"H1","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h2","title":"H2","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h3","title":"H3","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h4","title":"H4","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h5","title":"H5","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h6","title":"H6","text":"<p>Alternatively, for H1 and H2, an underline-ish style:</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#alt-h1","title":"Alt-H1","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#alt-h2","title":"Alt-H2","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#emphasis","title":"Emphasis","text":"<pre><code>Emphasis, aka italics, with *asterisks* or _underscores_.\n\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\n\nCombined emphasis with **asterisks and _underscores_**.\n\nStrikethrough uses two tildes. ~~Scratch this.~~\n</code></pre> <p>Emphasis, aka italics, with asterisks or underscores.</p> <p>Strong emphasis, aka bold, with asterisks or underscores.</p> <p>Combined emphasis with asterisks and underscores.</p> <p>Strikethrough uses two tildes. ~~Scratch this.~~</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#lists","title":"Lists","text":"<pre><code>1. First ordered list item\n2. Another item\n  * Unordered sub-list. \n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n4. And another item.\n\n   You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).\n\n   To have a line break without a paragraph, you will need to use two trailing spaces.\n   Note that this line is separate, but within the same paragraph.\n   (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)\n\n* Unordered list can use asterisks\n- Or minuses\n+ Or pluses\n</code></pre> <ol> <li>First ordered list item</li> <li>Another item</li> <li>Unordered sub-list. </li> <li>Actual numbers don't matter, just that it's a number</li> <li>Ordered sub-list</li> <li>And another item.</li> </ol> <p>You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).</p> <p>To have a line break without a paragraph, you will need to use two trailing spaces.    Note that this line is separate, but within the same paragraph.    (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</p> <ul> <li>Unordered list can use asterisks</li> <li>Or minuses</li> <li>Or pluses</li> </ul>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#links","title":"Links","text":"<pre><code>[I'm an inline-style link](https://www.google.com)\n\n[I'm an inline-style link with title](https://www.google.com \"Google's Homepage\")\n\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\n\n[I'm a relative reference to a repository file](../blob/master/LICENSE)\n\n[You can use numbers for reference-style link definitions][1]\n\nOr leave it empty and use the [link text itself].\n\nURLs and URLs in angle brackets will automatically get turned into links. \nhttp://www.example.com or &lt;http://www.example.com&gt; and sometimes \nexample.com (but not on Github, for example).\n\nSome text to show that the reference links can follow later.\n\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\n[1]: http://slashdot.org\n[link text itself]: http://www.reddit.com\n</code></pre> <p>I'm an inline-style link</p> <p>I'm an inline-style link with title</p> <p>I'm a reference-style link</p> <p>I'm a relative reference to a repository file</p> <p>You can use numbers for reference-style link definitions</p> <p>Or leave it empty and use the link text itself.</p> <p>URLs and URLs in angle brackets will automatically get turned into links.  http://www.example.com or http://www.example.com and sometimes  example.com (but not on Github, for example).</p> <p>Some text to show that the reference links can follow later.</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#images","title":"Images","text":"<pre><code>Here's our logo (hover to see the title text):\n\nInline-style: \n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\n\nReference-style: \n![alt text][logo]\n\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\n</code></pre> <p>Here's our logo (hover to see the title text):</p> <p>Inline-style:  </p> <p>Reference-style:  </p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#tables","title":"Tables","text":"<pre><code>Colons can be used to align columns.\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\nThere must be at least 3 dashes separating each header cell.\nThe outer pipes (|) are optional, and you don't need to make the \nraw Markdown line up prettily. You can also use inline Markdown.\n\nMarkdown | Less | Pretty\n--- | --- | ---\n*Still* | `renders` | **nicely**\n1 | 2 | 3\n</code></pre> <p>Colons can be used to align columns.</p>    Tables Are Cool     col 3 is right-aligned $1600   col 2 is centered $12   zebra stripes are neat $1    <p>There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the  raw Markdown line up prettily. You can also use inline Markdown.</p>    Markdown Less Pretty     Still <code>renders</code> nicely   1 2 3"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#blockquotes","title":"Blockquotes","text":"<pre><code>&gt; Blockquotes are very handy in email to emulate reply text.\n&gt; This line is part of the same quote.\n\nQuote break.\n\n&gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. \n</code></pre>  <p>Blockquotes are very handy in email to emulate reply text. This line is part of the same quote.</p>  <p>Quote break.</p>  <p>This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. </p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#inline-html","title":"Inline HTML","text":"<pre><code>&lt;dl&gt;\n  &lt;dt&gt;Definition list&lt;/dt&gt;\n  &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt;\n\n  &lt;dt&gt;Markdown in HTML&lt;/dt&gt;\n  &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre>  Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags."},{"location":"ltapi/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct Cookie </li> <li>class EspClass ESP Arduino Core compatibility class. </li> <li>struct EventHandler_s </li> <li>class FlashClass </li> <li>class FunctionRequestHandler </li> <li>class HTTPClient </li> <li>struct RequestArgument </li> <li>struct HTTPUpload </li> <li>class HardwareI2C </li> <li>class IPreferences </li> <li>class IWiFiClient </li> <li>class IWiFiClientSecure </li> <li>class IWiFiServer </li> <li>class IWiFiUDP </li> <li>class LibreTiny Main LibreTiny API class. </li> <li>class LibreTinyOTA Over-the-Air updates helper class. </li> <li>class LibreTinyWDT Watchdog control class. </li> <li>class LwIPClient </li> <li>class LwIPRxBuffer </li> <li>class LwIPServer </li> <li>class LwIPUDP </li> <li>struct MD5Context </li> <li>class MbedTLSClient </li> <li>struct PinInfo </li> <li>class RequestHandler </li> <li>class SerialClass </li> <li>struct SoftData </li> <li>struct SoftSerial </li> <li>class SoftwareSerial </li> <li>class StaticRequestHandler </li> <li>class StreamString </li> <li>class UpdateClass </li> <li>class Uri </li> <li>class UriBraces </li> <li>class UriGlob </li> <li>class UriRegex </li> <li>class WebServer </li> <li>struct RequestArgument </li> <li>class WiFiClass </li> <li>struct WiFiMacAddr </li> <li>class WiFiMulti </li> <li>struct WiFiNetworkInfo </li> <li>struct WiFiScanAP </li> <li>struct WiFiScanData </li> <li>struct WifiAPlist_t </li> <li>namespace arduino </li> <li>class IPv6Address </li> <li>union arduino_event_info_t </li> <li>struct arduino_event_t </li> <li>class base64 </li> <li>struct base64_decodestate </li> <li>struct base64_encodestate </li> <li>class cbuf </li> <li>struct esp_ip4_addr </li> <li>struct esp_ip6_addr </li> <li>struct esp_netif_ip6_info_t IPV6 IP address information. </li> <li>struct esp_netif_ip_info_t </li> <li>namespace fs </li> <li>class FS </li> <li>class FSImpl </li> <li>class File </li> <li>class FileImpl </li> <li>struct ip_event_ap_staipassigned_t </li> <li>struct ip_event_got_ip6_t </li> <li>struct ip_event_got_ip_t </li> <li>struct lt_flash_id_t Flash chip ID structure. </li> <li>struct lt_ota_ctx_t OTA update process context. </li> <li>class mDNS </li> <li>struct mbedtls_md5_context </li> <li>namespace mime </li> <li>struct Entry </li> <li>struct wifi_event_action_tx_status_t </li> <li>struct wifi_event_ap_probe_req_rx_t </li> <li>struct wifi_event_ap_staconnected_t </li> <li>struct wifi_event_ap_stadisconnected_t </li> <li>struct wifi_event_ftm_report_t </li> <li>struct wifi_event_roc_done_t </li> <li>struct wifi_event_sta_authmode_change_t </li> <li>struct wifi_event_sta_connected_t </li> <li>struct wifi_event_sta_disconnected_t </li> <li>struct wifi_event_sta_scan_done_t </li> <li>struct wifi_event_sta_wps_er_pin_t </li> <li>struct wifi_event_sta_wps_er_success_t </li> <li>struct wifi_ftm_report_entry_t </li> </ul>"},{"location":"ltapi/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir cores </li> <li>dir common <ul> <li>dir arduino </li> <li>dir libraries <ul> <li>dir api </li> <li>dir Serial <ul> <li>file Serial.cpp </li> <li>file Serial.h </li> </ul> </li> <li>dir SoftwareSerial <ul> <li>file SoftwareSerial.cpp </li> <li>file SoftwareSerial.h </li> </ul> </li> <li>dir WiFi <ul> <li>file WiFi.cpp </li> <li>file WiFi.h </li> <li>file WiFiAP.cpp </li> <li>file WiFiEvents.cpp </li> <li>file WiFiEvents.h </li> <li>file WiFiGeneric.cpp </li> <li>file WiFiSTA.cpp </li> <li>file WiFiScan.cpp </li> <li>file WiFiType.h </li> </ul> </li> <li>dir common </li> <li>dir FS <ul> <li>file FS.cpp </li> <li>file FS.h </li> </ul> </li> <li>dir IPv6Address <ul> <li>file IPv6Address.cpp </li> <li>file IPv6Address.h </li> <li>dir api </li> <li>file IPv6Address.h </li> </ul> </li> <li>dir MD5 <ul> <li>file MD5.h </li> <li>file MD5HostapdImpl.h </li> <li>file MD5MbedTLSImpl.cpp </li> <li>file MD5MbedTLSImpl.h </li> </ul> </li> <li>dir Preferences <ul> <li>file Preferences.h </li> </ul> </li> <li>dir Update <ul> <li>file Update.cpp </li> <li>file Update.h </li> <li>file UpdateUtil.cpp </li> </ul> </li> <li>dir WiFiClient <ul> <li>file LwIPClient.cpp </li> <li>file LwIPClient.h </li> <li>file LwIPRxBuffer.cpp </li> <li>file LwIPRxBuffer.h </li> <li>file MbedTLSClient.cpp </li> <li>file MbedTLSClient.h </li> <li>file WiFiClient.h </li> <li>file WiFiClientSecure.h </li> </ul> </li> <li>dir WiFiServer <ul> <li>file LwIPServer.cpp </li> <li>file LwIPServer.h </li> <li>file WiFiServer.h </li> </ul> </li> <li>dir WiFiUdp <ul> <li>file LwIPUdp.cpp </li> <li>file LwIPUdp.h </li> <li>file WiFiUdp.h </li> </ul> </li> <li>dir mDNS <ul> <li>file LwIPmDNS.cpp </li> <li>file mDNS.cpp </li> <li>file mDNS.h </li> </ul> </li> <li>dir ext </li> <li>dir HTTPClient <ul> <li>file HTTPClient.cpp </li> <li>file HTTPClient.h </li> </ul> </li> <li>dir StreamString <ul> <li>file StreamString.cpp </li> <li>file StreamString.h </li> </ul> </li> <li>dir WebServer <ul> <li>file HTTP_Method.h </li> <li>file Parsing.cpp </li> <li>file Uri.h </li> <li>file WebServer.cpp </li> <li>file WebServer.h </li> <li>dir detail </li> <li>file RequestHandler.h </li> <li>file RequestHandlersImpl.h </li> <li>file mimetable.cpp </li> <li>file mimetable.h </li> <li>dir uri </li> <li>file UriBraces.h </li> <li>file UriGlob.h </li> <li>file UriRegex.h </li> </ul> </li> <li>dir WiFiMulti <ul> <li>file WiFiMulti.cpp </li> <li>file WiFiMulti.h </li> </ul> </li> <li>dir base64 <ul> <li>file base64.cpp </li> <li>file base64.h </li> <li>dir libb64 </li> <li>file cdecode.c </li> <li>file cdecode.h </li> <li>file cencode.c </li> <li>file cencode.h </li> </ul> </li> <li>dir cbuf <ul> <li>file cbuf.cpp </li> <li>file cbuf.h </li> </ul> </li> <li>dir inline </li> <li>file Singletons.cpp </li> <li>dir ESP <ul> <li>file ESP.h </li> </ul> </li> <li>dir Flash <ul> <li>file Flash.h </li> </ul> </li> <li>dir LT <ul> <li>file LT.h </li> </ul> </li> <li>dir OTA <ul> <li>file OTA.h </li> </ul> </li> <li>dir WDT <ul> <li>file WDT.h </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file Arduino.h </li> <li>file Events.cpp </li> <li>file Events.h </li> <li>file HardwareI2C.h </li> <li>dir common </li> <li>file abi.cpp </li> <li>file dtostrf.c </li> <li>file serial_event.cpp </li> <li>dir compat </li> <li>file ESPmDNS.h </li> <li>file FS.h </li> <li>file FSImpl.h </li> <li>file WiFiAP.h </li> <li>file md5.h </li> <li>file pgmspace.h </li> <li>file vfs_api.h </li> <li>dir posix </li> <li>file time.c </li> <li>dir wiring </li> <li>file wiring.c </li> <li>file wiring_compat.cpp </li> <li>file wiring_compat.h </li> <li>file wiring_custom.c </li> <li>file wiring_custom.h </li> <li>file wiring_irq.c </li> <li>file wiring_math.cpp </li> <li>file wiring_private.c </li> <li>file wiring_private.h </li> <li>file wiring_shift.c </li> <li>file main.c </li> </ul> </li> <li>dir base </li> <li>dir api <ul> <li>file lt_cpu.c </li> <li>file lt_cpu.h </li> <li>file lt_device.c </li> <li>file lt_device.h </li> <li>file lt_flash.c </li> <li>file lt_flash.h </li> <li>file lt_init.h </li> <li>file lt_mem.c </li> <li>file lt_mem.h </li> <li>file lt_ota.c </li> <li>file lt_ota.h </li> <li>file lt_sleep.c </li> <li>file lt_sleep.h </li> <li>file lt_utils.c </li> <li>file lt_utils.h </li> <li>file lt_wdt.c </li> <li>file lt_wdt.h </li> </ul> </li> <li>dir compat <ul> <li>file certs.h </li> <li>dir lwip </li> <li>file lwip_timers.h </li> <li>file err.h </li> <li>file netdb.h </li> <li>file netif.h </li> <li>file sockets.h </li> <li>file sys.h </li> <li>file tcpip.h </li> <li>file udp.h </li> </ul> </li> <li>dir config <ul> <li>file fal_cfg.h </li> <li>file fdb_cfg.h </li> <li>file lwipopts.h </li> <li>file printf_config.h </li> </ul> </li> <li>dir fixups <ul> <li>dir lwip </li> <li>file errno.h </li> <li>file errno.h </li> <li>file malloc.c </li> </ul> </li> <li>dir posix <ul> <li>file itoa.c </li> <li>file strcasecmp.c </li> <li>file strdup.c </li> <li>file strptime.c </li> </ul> </li> <li>dir wraps <ul> <li>file putchar.c </li> <li>file puts.c </li> </ul> </li> <li>file libretiny.h </li> <li>file lt_api.h </li> <li>file lt_config.h </li> <li>file lt_logger.c </li> <li>file lt_logger.h </li> <li>file lt_main.c </li> <li>file lt_pins.h </li> <li>file lt_posix_api.h </li> <li>file lt_types.h </li> </ul> </li> </ul>"},{"location":"ltapi/struct_cookie/","title":"Struct Cookie","text":"<p>ClassList &gt; Cookie</p>"},{"location":"ltapi/struct_cookie/#public-attributes","title":"Public Attributes","text":"Type Name     time_t date   = = 0   String domain    time_t duration   = = 0   struct Cookie::@2 expires    String host    bool http_only   = = false   struct Cookie::@3 max_age    String name    String path   = = \"\"   bool secure   = = false   bool valid   = = false   String value"},{"location":"ltapi/struct_cookie/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_cookie/#variable-date","title":"variable date","text":"<pre><code>time_t Cookie::date;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-domain","title":"variable domain","text":"<pre><code>String Cookie::domain;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-duration","title":"variable duration","text":"<pre><code>time_t Cookie::duration;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-expires","title":"variable expires","text":"<pre><code>struct Cookie::@2 Cookie::expires;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-host","title":"variable host","text":"<pre><code>String Cookie::host;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-http_only","title":"variable http_only","text":"<pre><code>bool Cookie::http_only;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-max_age","title":"variable max_age","text":"<pre><code>struct Cookie::@3 Cookie::max_age;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-name","title":"variable name","text":"<pre><code>String Cookie::name;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-path","title":"variable path","text":"<pre><code>String Cookie::path;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-secure","title":"variable secure","text":"<pre><code>bool Cookie::secure;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-valid","title":"variable valid","text":"<pre><code>bool Cookie::valid;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-value","title":"variable value","text":"<pre><code>String Cookie::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/class_esp_class/","title":"Class EspClass","text":"<p>ClassList &gt; EspClass</p> <p>ESP Arduino Core compatibility class. More...</p> <ul> <li><code>#include &lt;ESP.h&gt;</code></li> </ul>"},{"location":"ltapi/class_esp_class/#public-functions","title":"Public Functions","text":"Type Name     bool flashEraseSector (uint32_t sector) Erase a single block of flash (usually 4 KiB).   bool flashRead (uint32_t address, uint8_t * data, size_t size) Read data from the flash.   bool flashWrite (uint32_t address, const uint8_t * data, size_t size) Write data to the flash.   uint8_t getBootMode ()    uint8_t getBootVersion ()    uint32_t getChipId () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   String getCoreVersion ()    uint8_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   uint32_t getFlashChipId () Flash chip ID structure.   uint32_t getFlashChipMode ()    uint32_t getFlashChipRealSize () Get flash chip total size.   uint32_t getFlashChipSize () Get flash chip total size.   uint32_t getFlashChipSizeByChipId () Get flash chip total size.   uint8_t getFlashChipVendorId () Flash chip ID structure.   uint32_t getFreeHeap () Get free heap size.   String getFullVersion ()    uint16_t getMaxFreeBlockSize () Get largest block of heap that can be allocated at once.   String getResetInfo () Get a textual representation of a reboot reason.   String getResetReason () Get a textual representation of a reboot reason.   const char * getSdkVersion ()    uint16_t getVcc ()    uint8_t * random (uint8_t * resultArray, const size_t outputSizeBytes) Generate random bytes using rand().   uint32_t random () Generate random bytes using rand().   void rebootIntoUartDownloadMode () Reboot the CPU and stay in download mode (if possible).   void reset () Reboot the CPU.   void restart () Reboot the CPU.   void wdtDisable () Disable the hardware watchdog.   void wdtEnable (uint32_t timeout_ms=0) Enable the hardware watchdog.   void wdtFeed () Feed/reset the hardware watchdog timer."},{"location":"ltapi/class_esp_class/#detailed-description","title":"Detailed Description","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>ESP</code> global object. </p>"},{"location":"ltapi/class_esp_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_esp_class/#function-flasherasesector","title":"function flashEraseSector","text":"<p>Erase a single block of flash (usually 4 KiB). <pre><code>inline bool EspClass::flashEraseSector (\n    uint32_t sector\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> offset of the block (in bytes); must be multiple of the flash chip's block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful  </p>"},{"location":"ltapi/class_esp_class/#function-flashread","title":"function flashRead","text":"<p>Read data from the flash. <pre><code>inline bool EspClass::flashRead (\n    uint32_t address,\n    uint8_t * data,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to where to store the data </li> <li><code>length</code> length of data to read </li> </ul> <p>Returns:</p> <p>length of data successfully read (should equal 'length')  </p>"},{"location":"ltapi/class_esp_class/#function-flashwrite","title":"function flashWrite","text":"<p>Write data to the flash. <pre><code>inline bool EspClass::flashWrite (\n    uint32_t address,\n    const uint8_t * data,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to data to write </li> <li><code>length</code> length of data to write </li> </ul> <p>Returns:</p> <p>length of data successfully written (should equal 'length')  </p>"},{"location":"ltapi/class_esp_class/#function-getbootmode","title":"function getBootMode","text":"<pre><code>inline uint8_t EspClass::getBootMode () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getbootversion","title":"function getBootVersion","text":"<pre><code>inline uint8_t EspClass::getBootVersion () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getchipid","title":"function getChipId","text":"<pre><code>inline uint32_t EspClass::getChipId () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getcoreversion","title":"function getCoreVersion","text":"<pre><code>inline String EspClass::getCoreVersion () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getcpufreqmhz","title":"function getCpuFreqMHz","text":"<pre><code>inline uint8_t EspClass::getCpuFreqMHz () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getcyclecount","title":"function getCycleCount","text":"<pre><code>inline uint32_t EspClass::getCycleCount () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getflashchipid","title":"function getFlashChipId","text":"<pre><code>inline uint32_t EspClass::getFlashChipId () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getflashchipmode","title":"function getFlashChipMode","text":"<pre><code>inline uint32_t EspClass::getFlashChipMode () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getflashchiprealsize","title":"function getFlashChipRealSize","text":"<p>Get flash chip total size. <pre><code>inline uint32_t EspClass::getFlashChipRealSize () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size. </p>"},{"location":"ltapi/class_esp_class/#function-getflashchipsize","title":"function getFlashChipSize","text":"<p>Get flash chip total size. <pre><code>inline uint32_t EspClass::getFlashChipSize () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size.  </p>"},{"location":"ltapi/class_esp_class/#function-getflashchipsizebychipid","title":"function getFlashChipSizeByChipId","text":"<p>Get flash chip total size. <pre><code>inline uint32_t EspClass::getFlashChipSizeByChipId () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size.  </p>"},{"location":"ltapi/class_esp_class/#function-getflashchipvendorid","title":"function getFlashChipVendorId","text":"<pre><code>inline uint8_t EspClass::getFlashChipVendorId () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getfreeheap","title":"function getFreeHeap","text":"<pre><code>inline uint32_t EspClass::getFreeHeap () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getfullversion","title":"function getFullVersion","text":"<pre><code>inline String EspClass::getFullVersion () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getmaxfreeblocksize","title":"function getMaxFreeBlockSize","text":"<pre><code>inline uint16_t EspClass::getMaxFreeBlockSize () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getresetinfo","title":"function getResetInfo","text":"<p>Get a textual representation of a reboot reason. <pre><code>inline String EspClass::getResetInfo () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, pass 0 to read from lt_reboot_get_reason()  </li> </ul>"},{"location":"ltapi/class_esp_class/#function-getresetreason","title":"function getResetReason","text":"<p>Get a textual representation of a reboot reason. <pre><code>inline String EspClass::getResetReason () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, pass 0 to read from lt_reboot_get_reason()  </li> </ul>"},{"location":"ltapi/class_esp_class/#function-getsdkversion","title":"function getSdkVersion","text":"<pre><code>inline const char * EspClass::getSdkVersion () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-getvcc","title":"function getVcc","text":"<pre><code>inline uint16_t EspClass::getVcc () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-random-12","title":"function random [1/2]","text":"<p>Generate random bytes using rand(). <pre><code>inline uint8_t * EspClass::random (\n    uint8_t * resultArray,\n    const size_t outputSizeBytes\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate  </li> </ul>"},{"location":"ltapi/class_esp_class/#function-random-22","title":"function random [2/2]","text":"<p>Generate random bytes using rand(). <pre><code>inline uint32_t EspClass::random () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate  </li> </ul>"},{"location":"ltapi/class_esp_class/#function-rebootintouartdownloadmode","title":"function rebootIntoUartDownloadMode","text":"<p>Reboot the CPU and stay in download mode (if possible). <pre><code>inline void EspClass::rebootIntoUartDownloadMode () \n</code></pre></p> <p>Returns:</p> <p>whether download-mode reboot is possible </p>"},{"location":"ltapi/class_esp_class/#function-reset","title":"function reset","text":"<pre><code>inline void EspClass::reset () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-restart","title":"function restart","text":"<pre><code>inline void EspClass::restart () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-wdtdisable","title":"function wdtDisable","text":"<pre><code>inline void EspClass::wdtDisable () \n</code></pre>"},{"location":"ltapi/class_esp_class/#function-wdtenable","title":"function wdtEnable","text":"<p>Enable the hardware watchdog. <pre><code>inline void EspClass::wdtEnable (\n    uint32_t timeout_ms=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> watchdog timeout, milliseconds </li> </ul> <p>Returns:</p> <p>whether the chip has a hardware watchdog </p>"},{"location":"ltapi/class_esp_class/#function-wdtfeed","title":"function wdtFeed","text":"<pre><code>inline void EspClass::wdtFeed () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/ESP/ESP.h</code></p>"},{"location":"ltapi/struct_event_handler__s/","title":"Struct EventHandler_s","text":"<p>ClassList &gt; EventHandler_s</p>"},{"location":"ltapi/struct_event_handler__s/#public-attributes","title":"Public Attributes","text":"Type Name     EventCb cb    EventId eventId    EventFuncCb fcb    uint16_t id    EventSysCb scb"},{"location":"ltapi/struct_event_handler__s/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     uint16_t lastId   = = 1"},{"location":"ltapi/struct_event_handler__s/#public-functions","title":"Public Functions","text":"Type Name      EventHandler_s ()"},{"location":"ltapi/struct_event_handler__s/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#variable-cb","title":"variable cb","text":"<pre><code>EventCb EventHandler_s::cb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-eventid","title":"variable eventId","text":"<pre><code>EventId EventHandler_s::eventId;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-fcb","title":"variable fcb","text":"<pre><code>EventFuncCb EventHandler_s::fcb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-id","title":"variable id","text":"<pre><code>uint16_t EventHandler_s::id;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-scb","title":"variable scb","text":"<pre><code>EventSysCb EventHandler_s::scb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#variable-lastid","title":"variable lastId","text":"<pre><code>uint16_t EventHandler_s::lastId;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#function-eventhandler_s","title":"function EventHandler_s","text":"<pre><code>inline EventHandler_s::EventHandler_s () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Events.h</code></p>"},{"location":"ltapi/class_flash_class/","title":"Class FlashClass","text":"<p>ClassList &gt; FlashClass</p>"},{"location":"ltapi/class_flash_class/#public-functions","title":"Public Functions","text":"Type Name     bool eraseSector (uint32_t offset) Erase a single block of flash (usually 4 KiB).   FlashId getChipId () Flash chip ID structure.   uint32_t getSize () Get flash chip total size.   bool readBlock (uint32_t offset, uint8_t * data, size_t length) Read data from the flash.   bool writeBlock (uint32_t offset, const uint8_t * data, size_t length) Write data to the flash."},{"location":"ltapi/class_flash_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_flash_class/#function-erasesector","title":"function eraseSector","text":"<p>Erase a single block of flash (usually 4 KiB). <pre><code>inline bool FlashClass::eraseSector (\n    uint32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> offset of the block (in bytes); must be multiple of the flash chip's block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful </p>"},{"location":"ltapi/class_flash_class/#function-getchipid","title":"function getChipId","text":"<pre><code>inline FlashId FlashClass::getChipId () \n</code></pre>"},{"location":"ltapi/class_flash_class/#function-getsize","title":"function getSize","text":"<p>Get flash chip total size. <pre><code>inline uint32_t FlashClass::getSize () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size. </p>"},{"location":"ltapi/class_flash_class/#function-readblock","title":"function readBlock","text":"<p>Read data from the flash. <pre><code>inline bool FlashClass::readBlock (\n    uint32_t offset,\n    uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to where to store the data </li> <li><code>length</code> length of data to read </li> </ul> <p>Returns:</p> <p>length of data successfully read (should equal 'length') </p>"},{"location":"ltapi/class_flash_class/#function-writeblock","title":"function writeBlock","text":"<p>Write data to the flash. <pre><code>inline bool FlashClass::writeBlock (\n    uint32_t offset,\n    const uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to data to write </li> <li><code>length</code> length of data to write </li> </ul> <p>Returns:</p> <p>length of data successfully written (should equal 'length') </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/Flash/Flash.h</code></p>"},{"location":"ltapi/class_function_request_handler/","title":"Class FunctionRequestHandler","text":"<p>ClassList &gt; FunctionRequestHandler</p> <p>Inherits the following classes: RequestHandler</p>"},{"location":"ltapi/class_function_request_handler/#public-functions","title":"Public Functions","text":"Type Name      FunctionRequestHandler (WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn, const Uri &amp; uri, HTTPMethod method)    virtual bool canHandle (HTTPMethod requestMethod, String requestUri) override   virtual bool canUpload (String requestUri) override   virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri) override   virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload) override    ~FunctionRequestHandler ()"},{"location":"ltapi/class_function_request_handler/#public-functions-inherited-from-requesthandler","title":"Public Functions inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_function_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     WebServer::THandlerFunction _fn    HTTPMethod _method    WebServer::THandlerFunction _ufn    Uri * _uri"},{"location":"ltapi/class_function_request_handler/#protected-attributes-inherited-from-requesthandler","title":"Protected Attributes inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_function_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_function_request_handler/#function-functionrequesthandler","title":"function FunctionRequestHandler","text":"<pre><code>inline FunctionRequestHandler::FunctionRequestHandler (\n    WebServer::THandlerFunction fn,\n    WebServer::THandlerFunction ufn,\n    const Uri &amp; uri,\n    HTTPMethod method\n) \n</code></pre>"},{"location":"ltapi/class_function_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool FunctionRequestHandler::canHandle (\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canHandle</p>"},{"location":"ltapi/class_function_request_handler/#function-canupload","title":"function canUpload","text":"<pre><code>inline virtual bool FunctionRequestHandler::canUpload (\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canUpload</p>"},{"location":"ltapi/class_function_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool FunctionRequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::handle</p>"},{"location":"ltapi/class_function_request_handler/#function-upload","title":"function upload","text":"<pre><code>inline virtual void FunctionRequestHandler::upload (\n    WebServer &amp; server,\n    String requestUri,\n    HTTPUpload &amp; upload\n) override\n</code></pre> <p>Implements RequestHandler::upload</p>"},{"location":"ltapi/class_function_request_handler/#function-functionrequesthandler_1","title":"function ~FunctionRequestHandler","text":"<pre><code>inline FunctionRequestHandler::~FunctionRequestHandler () \n</code></pre>"},{"location":"ltapi/class_function_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_function_request_handler/#variable-_fn","title":"variable _fn","text":"<pre><code>WebServer::THandlerFunction FunctionRequestHandler::_fn;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_method","title":"variable _method","text":"<pre><code>HTTPMethod FunctionRequestHandler::_method;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_ufn","title":"variable _ufn","text":"<pre><code>WebServer::THandlerFunction FunctionRequestHandler::_ufn;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_uri","title":"variable _uri","text":"<pre><code>Uri* FunctionRequestHandler::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/class_h_t_t_p_client/","title":"Class HTTPClient","text":"<p>ClassList &gt; HTTPClient</p>"},{"location":"ltapi/class_h_t_t_p_client/#public-functions","title":"Public Functions","text":"Type Name     int GET () request handling    HTTPClient ()    int PATCH (uint8_t * payload, size_t size)    int PATCH (String payload)    int POST (uint8_t * payload, size_t size)    int POST (String payload)    int PUT (uint8_t * payload, size_t size)    int PUT (String payload)    void addHeader (const String &amp; name, const String &amp; value, bool first=false, bool replace=true)    bool begin (WiFiClient &amp; client, String url)    bool begin (WiFiClient &amp; client, String host, uint16_t port, String uri=\"/\", bool https=false)    bool begin (String url)    bool begin (String url, const char * CAcert)    bool begin (String host, uint16_t port, String uri=\"/\")    bool begin (String host, uint16_t port, String uri, const char * CAcert)    bool begin (String host, uint16_t port, String uri, const char * CAcert, const char * cli_cert, const char * cli_key)    void clearAllCookies ()    void collectHeaders (const char * headerKeys, const size_t headerKeysCount) Response handling.   bool connected (void)    void end (void)    const String &amp; getLocation (void)    int getSize (void)    WiFiClient &amp; getStream (void)    WiFiClient * getStreamPtr (void)    bool hasHeader (const char * name)    String header (const char * name)    String header (size_t i)    String headerName (size_t i)    int headers ()    void resetCookieJar ()    int sendRequest (const char * type, String payload)    int sendRequest (const char * type, uint8_t * payload=NULL, size_t size=0)    int sendRequest (const char * type, Stream * stream, size_t size=0)    void setAuthorization (const char * user, const char * password)    void setAuthorization (const char * auth)    void setAuthorizationType (const char * authType)    void setConnectTimeout (int32_t connectTimeout)    void setCookieJar (CookieJar * cookieJar) Cookie jar support.   void setFollowRedirects (followRedirects_t follow)    void setRedirectLimit (uint16_t limit)    void setReuse (bool reuse)    void setTimeout (uint16_t timeout)    bool setURL (const String &amp; url)    void setUserAgent (const String &amp; userAgent) keep-alive   void useHTTP10 (bool usehttp10=true)    int writeToStream (Stream * stream)     ~HTTPClient ()"},{"location":"ltapi/class_h_t_t_p_client/#public-static-functions","title":"Public Static Functions","text":"Type Name     String errorToString (int error)"},{"location":"ltapi/class_h_t_t_p_client/#protected-attributes","title":"Protected Attributes","text":"Type Name     String _authorizationType   = = \"Basic\"   String _base64Authorization    bool _canReuse   = = false   WiFiClient * _client   = = nullptr   int32_t _connectTimeout   = = -1   CookieJar * _cookieJar   = = nullptrCookie jar support.   RequestArgument * _currentHeaders   = = nullptrResponse handling.   followRedirects_t _followRedirects   = = HTTPC_DISABLE_FOLLOW_REDIRECTS   size_t _headerKeysCount   = = 0   String _headers    String _host request handling   String _location    uint16_t _port   = = 0   String _protocol    uint16_t _redirectLimit   = = 10   int _returnCode   = = 0   bool _reuse   = = true   bool _secure   = = false   int _size   = = -1   std::unique_ptr&lt; WiFiClient &gt; _tcpDeprecated    uint16_t _tcpTimeout   = = HTTPCLIENT_DEFAULT_TCP_TIMEOUT   transferEncoding_t _transferEncoding   = = HTTPC_TE_IDENTITY   TransportTraitsPtr _transportTraits    String _uri    bool _useHTTP10   = = false   String _userAgent   = = \"ESP32HTTPClient\""},{"location":"ltapi/class_h_t_t_p_client/#protected-functions","title":"Protected Functions","text":"Type Name     bool beginInternal (String url, const char * expectedProtocol)    void clear ()    bool connect (void)    void disconnect (bool preserveClient=false)    bool generateCookieString (String * cookieString)    int handleHeaderResponse ()    int returnError (int error)    bool sendHeader (const char * type)    void setCookie (String date, String headerValue) Cookie jar support.   int writeToStreamDataBlock (Stream * stream, int len)"},{"location":"ltapi/class_h_t_t_p_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-get","title":"function GET","text":"<pre><code>int HTTPClient::GET () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-httpclient","title":"function HTTPClient","text":"<pre><code>HTTPClient::HTTPClient () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-patch-12","title":"function PATCH [1/2]","text":"<pre><code>int HTTPClient::PATCH (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-patch-22","title":"function PATCH [2/2]","text":"<pre><code>int HTTPClient::PATCH (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-post-12","title":"function POST [1/2]","text":"<pre><code>int HTTPClient::POST (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-post-22","title":"function POST [2/2]","text":"<pre><code>int HTTPClient::POST (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-put-12","title":"function PUT [1/2]","text":"<pre><code>int HTTPClient::PUT (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-put-22","title":"function PUT [2/2]","text":"<pre><code>int HTTPClient::PUT (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-addheader","title":"function addHeader","text":"<pre><code>void HTTPClient::addHeader (\n    const String &amp; name,\n    const String &amp; value,\n    bool first=false,\n    bool replace=true\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-17","title":"function begin [1/7]","text":"<pre><code>bool HTTPClient::begin (\n    WiFiClient &amp; client,\n    String url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-27","title":"function begin [2/7]","text":"<pre><code>bool HTTPClient::begin (\n    WiFiClient &amp; client,\n    String host,\n    uint16_t port,\n    String uri=\"/\",\n    bool https=false\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-37","title":"function begin [3/7]","text":"<pre><code>bool HTTPClient::begin (\n    String url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-47","title":"function begin [4/7]","text":"<pre><code>bool HTTPClient::begin (\n    String url,\n    const char * CAcert\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-57","title":"function begin [5/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri=\"/\"\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-67","title":"function begin [6/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri,\n    const char * CAcert\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-77","title":"function begin [7/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri,\n    const char * CAcert,\n    const char * cli_cert,\n    const char * cli_key\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-clearallcookies","title":"function clearAllCookies","text":"<pre><code>void HTTPClient::clearAllCookies () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-collectheaders","title":"function collectHeaders","text":"<pre><code>void HTTPClient::collectHeaders (\n    const char * headerKeys,\n    const size_t headerKeysCount\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-connected","title":"function connected","text":"<pre><code>bool HTTPClient::connected (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-end","title":"function end","text":"<pre><code>void HTTPClient::end (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getlocation","title":"function getLocation","text":"<pre><code>const String &amp; HTTPClient::getLocation (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getsize","title":"function getSize","text":"<pre><code>int HTTPClient::getSize (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getstream","title":"function getStream","text":"<pre><code>WiFiClient &amp; HTTPClient::getStream (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getstreamptr","title":"function getStreamPtr","text":"<pre><code>WiFiClient * HTTPClient::getStreamPtr (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-hasheader","title":"function hasHeader","text":"<pre><code>bool HTTPClient::hasHeader (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-header-12","title":"function header [1/2]","text":"<pre><code>String HTTPClient::header (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-header-22","title":"function header [2/2]","text":"<pre><code>String HTTPClient::header (\n    size_t i\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-headername","title":"function headerName","text":"<pre><code>String HTTPClient::headerName (\n    size_t i\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-headers","title":"function headers","text":"<pre><code>int HTTPClient::headers () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-resetcookiejar","title":"function resetCookieJar","text":"<pre><code>void HTTPClient::resetCookieJar () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-13","title":"function sendRequest [1/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-23","title":"function sendRequest [2/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    uint8_t * payload=NULL,\n    size_t size=0\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-33","title":"function sendRequest [3/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    Stream * stream,\n    size_t size=0\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorization-12","title":"function setAuthorization [1/2]","text":"<pre><code>void HTTPClient::setAuthorization (\n    const char * user,\n    const char * password\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorization-22","title":"function setAuthorization [2/2]","text":"<pre><code>void HTTPClient::setAuthorization (\n    const char * auth\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorizationtype","title":"function setAuthorizationType","text":"<pre><code>void HTTPClient::setAuthorizationType (\n    const char * authType\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setconnecttimeout","title":"function setConnectTimeout","text":"<pre><code>void HTTPClient::setConnectTimeout (\n    int32_t connectTimeout\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setcookiejar","title":"function setCookieJar","text":"<pre><code>void HTTPClient::setCookieJar (\n    CookieJar * cookieJar\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setfollowredirects","title":"function setFollowRedirects","text":"<pre><code>void HTTPClient::setFollowRedirects (\n    followRedirects_t follow\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setredirectlimit","title":"function setRedirectLimit","text":"<pre><code>void HTTPClient::setRedirectLimit (\n    uint16_t limit\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setreuse","title":"function setReuse","text":"<pre><code>void HTTPClient::setReuse (\n    bool reuse\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>void HTTPClient::setTimeout (\n    uint16_t timeout\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-seturl","title":"function setURL","text":"<pre><code>bool HTTPClient::setURL (\n    const String &amp; url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setuseragent","title":"function setUserAgent","text":"<pre><code>void HTTPClient::setUserAgent (\n    const String &amp; userAgent\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-usehttp10","title":"function useHTTP10","text":"<pre><code>void HTTPClient::useHTTP10 (\n    bool usehttp10=true\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-writetostream","title":"function writeToStream","text":"<pre><code>int HTTPClient::writeToStream (\n    Stream * stream\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-httpclient_1","title":"function ~HTTPClient","text":"<pre><code>HTTPClient::~HTTPClient () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-errortostring","title":"function errorToString","text":"<pre><code>static String HTTPClient::errorToString (\n    int error\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#variable-_authorizationtype","title":"variable _authorizationType","text":"<pre><code>String HTTPClient::_authorizationType;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_base64authorization","title":"variable _base64Authorization","text":"<pre><code>String HTTPClient::_base64Authorization;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_canreuse","title":"variable _canReuse","text":"<pre><code>bool HTTPClient::_canReuse;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_client","title":"variable _client","text":"<pre><code>WiFiClient* HTTPClient::_client;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_connecttimeout","title":"variable _connectTimeout","text":"<pre><code>int32_t HTTPClient::_connectTimeout;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_cookiejar","title":"variable _cookieJar","text":"<pre><code>CookieJar* HTTPClient::_cookieJar;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_currentheaders","title":"variable _currentHeaders","text":"<pre><code>RequestArgument* HTTPClient::_currentHeaders;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_followredirects","title":"variable _followRedirects","text":"<pre><code>followRedirects_t HTTPClient::_followRedirects;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_headerkeyscount","title":"variable _headerKeysCount","text":"<pre><code>size_t HTTPClient::_headerKeysCount;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_headers","title":"variable _headers","text":"<pre><code>String HTTPClient::_headers;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_host","title":"variable _host","text":"<pre><code>String HTTPClient::_host;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_location","title":"variable _location","text":"<pre><code>String HTTPClient::_location;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_port","title":"variable _port","text":"<pre><code>uint16_t HTTPClient::_port;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_protocol","title":"variable _protocol","text":"<pre><code>String HTTPClient::_protocol;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_redirectlimit","title":"variable _redirectLimit","text":"<pre><code>uint16_t HTTPClient::_redirectLimit;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_returncode","title":"variable _returnCode","text":"<pre><code>int HTTPClient::_returnCode;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_reuse","title":"variable _reuse","text":"<pre><code>bool HTTPClient::_reuse;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_secure","title":"variable _secure","text":"<pre><code>bool HTTPClient::_secure;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_size","title":"variable _size","text":"<pre><code>int HTTPClient::_size;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_tcpdeprecated","title":"variable _tcpDeprecated","text":"<pre><code>std::unique_ptr&lt;WiFiClient&gt; HTTPClient::_tcpDeprecated;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_tcptimeout","title":"variable _tcpTimeout","text":"<pre><code>uint16_t HTTPClient::_tcpTimeout;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_transferencoding","title":"variable _transferEncoding","text":"<pre><code>transferEncoding_t HTTPClient::_transferEncoding;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_transporttraits","title":"variable _transportTraits","text":"<pre><code>TransportTraitsPtr HTTPClient::_transportTraits;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_uri","title":"variable _uri","text":"<pre><code>String HTTPClient::_uri;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_usehttp10","title":"variable _useHTTP10","text":"<pre><code>bool HTTPClient::_useHTTP10;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_useragent","title":"variable _userAgent","text":"<pre><code>String HTTPClient::_userAgent;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-begininternal","title":"function beginInternal","text":"<pre><code>bool HTTPClient::beginInternal (\n    String url,\n    const char * expectedProtocol\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-clear","title":"function clear","text":"<pre><code>void HTTPClient::clear () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-connect","title":"function connect","text":"<pre><code>bool HTTPClient::connect (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-disconnect","title":"function disconnect","text":"<pre><code>void HTTPClient::disconnect (\n    bool preserveClient=false\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-generatecookiestring","title":"function generateCookieString","text":"<pre><code>bool HTTPClient::generateCookieString (\n    String * cookieString\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-handleheaderresponse","title":"function handleHeaderResponse","text":"<pre><code>int HTTPClient::handleHeaderResponse () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-returnerror","title":"function returnError","text":"<pre><code>int HTTPClient::returnError (\n    int error\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendheader","title":"function sendHeader","text":"<pre><code>bool HTTPClient::sendHeader (\n    const char * type\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setcookie","title":"function setCookie","text":"<pre><code>void HTTPClient::setCookie (\n    String date,\n    String headerValue\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-writetostreamdatablock","title":"function writeToStreamDataBlock","text":"<pre><code>int HTTPClient::writeToStreamDataBlock (\n    Stream * stream,\n    int len\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/","title":"Struct HTTPClient::RequestArgument","text":"<p>ClassList &gt; HTTPClient &gt; RequestArgument</p>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#public-attributes","title":"Public Attributes","text":"Type Name     String key    String value"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#variable-key","title":"variable key","text":"<pre><code>String HTTPClient::RequestArgument::key;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#variable-value","title":"variable value","text":"<pre><code>String HTTPClient::RequestArgument::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/struct_h_t_t_p_upload/","title":"Struct HTTPUpload","text":"<p>ClassList &gt; HTTPUpload</p>"},{"location":"ltapi/struct_h_t_t_p_upload/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t buf    size_t currentSize    String filename    String name    HTTPUploadStatus status    size_t totalSize    String type"},{"location":"ltapi/struct_h_t_t_p_upload/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_h_t_t_p_upload/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t HTTPUpload::buf[HTTP_UPLOAD_BUFLEN];\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-currentsize","title":"variable currentSize","text":"<pre><code>size_t HTTPUpload::currentSize;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-filename","title":"variable filename","text":"<pre><code>String HTTPUpload::filename;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-name","title":"variable name","text":"<pre><code>String HTTPUpload::name;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-status","title":"variable status","text":"<pre><code>HTTPUploadStatus HTTPUpload::status;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-totalsize","title":"variable totalSize","text":"<pre><code>size_t HTTPUpload::totalSize;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-type","title":"variable type","text":"<pre><code>String HTTPUpload::type;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/WebServer.h</code></p>"},{"location":"ltapi/class_hardware_i2_c/","title":"Class HardwareI2C","text":"<p>ClassList &gt; HardwareI2C</p> <p>Inherits the following classes: Stream</p>"},{"location":"ltapi/class_hardware_i2_c/#public-functions","title":"Public Functions","text":"Type Name     virtual int available () = 0   bool begin ()    bool begin (uint8_t address)    virtual bool begin (int8_t sda, int8_t scl, uint32_t frequency=0) = 0   virtual bool begin (uint8_t address, int8_t sda, int8_t scl, uint32_t frequency=0) = 0   virtual void beginTransmission (uint8_t address) = 0   virtual bool end () = 0   virtual uint8_t endTransmission (bool stopBit) = 0   uint8_t endTransmission ()    virtual void flush () = 0   uint32_t getClock ()    void onReceive (void(*)(int) cb)    void onRequest (void(*)(void) cb)    virtual int peek () = 0   virtual int read () = 0   virtual size_t requestFrom (uint8_t address, size_t len, bool stopBit) = 0   size_t requestFrom (uint8_t address, size_t len)    virtual bool setClock (uint32_t freq) = 0   virtual bool setPins (int8_t sda, int8_t scl) = 0   virtual size_t write (const uint8_t * data, size_t len) = 0   virtual size_t write (uint8_t data)"},{"location":"ltapi/class_hardware_i2_c/#protected-attributes","title":"Protected Attributes","text":"Type Name     uint32_t _freq   = = 0   int8_t _scl   = = -1   int8_t _sda   = = -1   void(* onReceiveCallback    void(* onRequestCallback"},{"location":"ltapi/class_hardware_i2_c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_hardware_i2_c/#function-available","title":"function available","text":"<pre><code>virtual int HardwareI2C::available () = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-begin-14","title":"function begin [1/4]","text":"<pre><code>inline bool HardwareI2C::begin () \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-begin-24","title":"function begin [2/4]","text":"<pre><code>inline bool HardwareI2C::begin (\n    uint8_t address\n) \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-begin-34","title":"function begin [3/4]","text":"<pre><code>virtual bool HardwareI2C::begin (\n    int8_t sda,\n    int8_t scl,\n    uint32_t frequency=0\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-begin-44","title":"function begin [4/4]","text":"<pre><code>virtual bool HardwareI2C::begin (\n    uint8_t address,\n    int8_t sda,\n    int8_t scl,\n    uint32_t frequency=0\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-begintransmission","title":"function beginTransmission","text":"<pre><code>virtual void HardwareI2C::beginTransmission (\n    uint8_t address\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-end","title":"function end","text":"<pre><code>virtual bool HardwareI2C::end () = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-endtransmission-12","title":"function endTransmission [1/2]","text":"<pre><code>virtual uint8_t HardwareI2C::endTransmission (\n    bool stopBit\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-endtransmission-22","title":"function endTransmission [2/2]","text":"<pre><code>inline uint8_t HardwareI2C::endTransmission () \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-flush","title":"function flush","text":"<pre><code>virtual void HardwareI2C::flush () = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-getclock","title":"function getClock","text":"<pre><code>inline uint32_t HardwareI2C::getClock () \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-onreceive","title":"function onReceive","text":"<pre><code>inline void HardwareI2C::onReceive (\n    void(*)(int) cb\n) \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-onrequest","title":"function onRequest","text":"<pre><code>inline void HardwareI2C::onRequest (\n    void(*)(void) cb\n) \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-peek","title":"function peek","text":"<pre><code>virtual int HardwareI2C::peek () = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-read","title":"function read","text":"<pre><code>virtual int HardwareI2C::read () = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-requestfrom-12","title":"function requestFrom [1/2]","text":"<pre><code>virtual size_t HardwareI2C::requestFrom (\n    uint8_t address,\n    size_t len,\n    bool stopBit\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-requestfrom-22","title":"function requestFrom [2/2]","text":"<pre><code>inline size_t HardwareI2C::requestFrom (\n    uint8_t address,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-setclock","title":"function setClock","text":"<pre><code>virtual bool HardwareI2C::setClock (\n    uint32_t freq\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-setpins","title":"function setPins","text":"<pre><code>virtual bool HardwareI2C::setPins (\n    int8_t sda,\n    int8_t scl\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t HardwareI2C::write (\n    const uint8_t * data,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#function-write-22","title":"function write [2/2]","text":"<pre><code>inline virtual size_t HardwareI2C::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_hardware_i2_c/#variable-_freq","title":"variable _freq","text":"<pre><code>uint32_t HardwareI2C::_freq;\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#variable-_scl","title":"variable _scl","text":"<pre><code>int8_t HardwareI2C::_scl;\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#variable-_sda","title":"variable _sda","text":"<pre><code>int8_t HardwareI2C::_sda;\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#variable-onreceivecallback","title":"variable onReceiveCallback","text":"<pre><code>void(* HardwareI2C::onReceiveCallback) (int);\n</code></pre>"},{"location":"ltapi/class_hardware_i2_c/#variable-onrequestcallback","title":"variable onRequestCallback","text":"<pre><code>void(* HardwareI2C::onRequestCallback) (void);\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/HardwareI2C.h</code></p>"},{"location":"ltapi/class_i_preferences/","title":"Class IPreferences","text":"<p>ClassList &gt; IPreferences</p>"},{"location":"ltapi/class_i_preferences/#public-functions","title":"Public Functions","text":"Type Name      IPreferences ()    bool begin (const char * name, bool readOnly=false, const char * partition_label=NULL)    bool clear ()    void end ()    size_t freeEntries ()    bool getBool (const char * key, bool defaultValue=false)    size_t getBytes (const char * key, void * buf, size_t maxLen)    size_t getBytesLength (const char * key)    int8_t getChar (const char * key, int8_t defaultValue=0)    double_t getDouble (const char * key, double_t defaultValue=NAN)    float_t getFloat (const char * key, float_t defaultValue=NAN)    int32_t getInt (const char * key, int32_t defaultValue=0)    int32_t getLong (const char * key, int32_t defaultValue=0)    int64_t getLong64 (const char * key, int64_t defaultValue=0)    int16_t getShort (const char * key, int16_t defaultValue=0)    size_t getString (const char * key, char * value, size_t maxLen)    String getString (const char * key, String defaultValue=String())    PreferenceType getType (const char * key)    uint8_t getUChar (const char * key, uint8_t defaultValue=0)    uint32_t getUInt (const char * key, uint32_t defaultValue=0)    uint32_t getULong (const char * key, uint32_t defaultValue=0)    uint64_t getULong64 (const char * key, uint64_t defaultValue=0)    uint16_t getUShort (const char * key, uint16_t defaultValue=0)    bool isKey (const char * key)    size_t putBool (const char * key, bool value)    size_t putBytes (const char * key, const void * value, size_t len)    size_t putChar (const char * key, int8_t value)    size_t putDouble (const char * key, double_t value)    size_t putFloat (const char * key, float_t value)    size_t putInt (const char * key, int32_t value)    size_t putLong (const char * key, int32_t value)    size_t putLong64 (const char * key, int64_t value)    size_t putShort (const char * key, int16_t value)    size_t putString (const char * key, const char * value)    size_t putString (const char * key, String value)    size_t putUChar (const char * key, uint8_t value)    size_t putUInt (const char * key, uint32_t value)    size_t putULong (const char * key, uint32_t value)    size_t putULong64 (const char * key, uint64_t value)    size_t putUShort (const char * key, uint16_t value)    bool remove (const char * key)     ~IPreferences ()"},{"location":"ltapi/class_i_preferences/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_preferences/#function-ipreferences","title":"function IPreferences","text":"<pre><code>inline IPreferences::IPreferences () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-begin","title":"function begin","text":"<pre><code>bool IPreferences::begin (\n    const char * name,\n    bool readOnly=false,\n    const char * partition_label=NULL\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-clear","title":"function clear","text":"<pre><code>bool IPreferences::clear () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-end","title":"function end","text":"<pre><code>void IPreferences::end () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-freeentries","title":"function freeEntries","text":"<pre><code>size_t IPreferences::freeEntries () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbool","title":"function getBool","text":"<pre><code>bool IPreferences::getBool (\n    const char * key,\n    bool defaultValue=false\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbytes","title":"function getBytes","text":"<pre><code>size_t IPreferences::getBytes (\n    const char * key,\n    void * buf,\n    size_t maxLen\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbyteslength","title":"function getBytesLength","text":"<pre><code>size_t IPreferences::getBytesLength (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getchar","title":"function getChar","text":"<pre><code>int8_t IPreferences::getChar (\n    const char * key,\n    int8_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getdouble","title":"function getDouble","text":"<pre><code>double_t IPreferences::getDouble (\n    const char * key,\n    double_t defaultValue=NAN\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getfloat","title":"function getFloat","text":"<pre><code>float_t IPreferences::getFloat (\n    const char * key,\n    float_t defaultValue=NAN\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getint","title":"function getInt","text":"<pre><code>int32_t IPreferences::getInt (\n    const char * key,\n    int32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getlong","title":"function getLong","text":"<pre><code>int32_t IPreferences::getLong (\n    const char * key,\n    int32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getlong64","title":"function getLong64","text":"<pre><code>int64_t IPreferences::getLong64 (\n    const char * key,\n    int64_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getshort","title":"function getShort","text":"<pre><code>int16_t IPreferences::getShort (\n    const char * key,\n    int16_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getstring-12","title":"function getString [1/2]","text":"<pre><code>size_t IPreferences::getString (\n    const char * key,\n    char * value,\n    size_t maxLen\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getstring-22","title":"function getString [2/2]","text":"<pre><code>String IPreferences::getString (\n    const char * key,\n    String defaultValue=String()\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-gettype","title":"function getType","text":"<pre><code>PreferenceType IPreferences::getType (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getuchar","title":"function getUChar","text":"<pre><code>uint8_t IPreferences::getUChar (\n    const char * key,\n    uint8_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getuint","title":"function getUInt","text":"<pre><code>uint32_t IPreferences::getUInt (\n    const char * key,\n    uint32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getulong","title":"function getULong","text":"<pre><code>uint32_t IPreferences::getULong (\n    const char * key,\n    uint32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getulong64","title":"function getULong64","text":"<pre><code>uint64_t IPreferences::getULong64 (\n    const char * key,\n    uint64_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getushort","title":"function getUShort","text":"<pre><code>uint16_t IPreferences::getUShort (\n    const char * key,\n    uint16_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-iskey","title":"function isKey","text":"<pre><code>bool IPreferences::isKey (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putbool","title":"function putBool","text":"<pre><code>size_t IPreferences::putBool (\n    const char * key,\n    bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putbytes","title":"function putBytes","text":"<pre><code>size_t IPreferences::putBytes (\n    const char * key,\n    const void * value,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putchar","title":"function putChar","text":"<pre><code>size_t IPreferences::putChar (\n    const char * key,\n    int8_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putdouble","title":"function putDouble","text":"<pre><code>size_t IPreferences::putDouble (\n    const char * key,\n    double_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putfloat","title":"function putFloat","text":"<pre><code>size_t IPreferences::putFloat (\n    const char * key,\n    float_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putint","title":"function putInt","text":"<pre><code>size_t IPreferences::putInt (\n    const char * key,\n    int32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putlong","title":"function putLong","text":"<pre><code>size_t IPreferences::putLong (\n    const char * key,\n    int32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putlong64","title":"function putLong64","text":"<pre><code>size_t IPreferences::putLong64 (\n    const char * key,\n    int64_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putshort","title":"function putShort","text":"<pre><code>size_t IPreferences::putShort (\n    const char * key,\n    int16_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putstring-12","title":"function putString [1/2]","text":"<pre><code>size_t IPreferences::putString (\n    const char * key,\n    const char * value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putstring-22","title":"function putString [2/2]","text":"<pre><code>size_t IPreferences::putString (\n    const char * key,\n    String value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putuchar","title":"function putUChar","text":"<pre><code>size_t IPreferences::putUChar (\n    const char * key,\n    uint8_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putuint","title":"function putUInt","text":"<pre><code>size_t IPreferences::putUInt (\n    const char * key,\n    uint32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putulong","title":"function putULong","text":"<pre><code>size_t IPreferences::putULong (\n    const char * key,\n    uint32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putulong64","title":"function putULong64","text":"<pre><code>size_t IPreferences::putULong64 (\n    const char * key,\n    uint64_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putushort","title":"function putUShort","text":"<pre><code>size_t IPreferences::putUShort (\n    const char * key,\n    uint16_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-remove","title":"function remove","text":"<pre><code>bool IPreferences::remove (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-ipreferences_1","title":"function ~IPreferences","text":"<pre><code>inline IPreferences::~IPreferences () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Preferences/Preferences.h</code></p>"},{"location":"ltapi/class_i_wi_fi_client/","title":"Class IWiFiClient","text":"<p>ClassList &gt; IWiFiClient</p> <p>Inherits the following classes: Client</p> <p>Inherited by the following classes: LwIPClient</p>"},{"location":"ltapi/class_i_wi_fi_client/#public-functions","title":"Public Functions","text":"Type Name      IWiFiClient ()     IWiFiClient (int sock)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout) = 0   virtual int connect (const char * host, uint16_t port, int32_t timeout) = 0   virtual int fd () const = 0   virtual IPAddress localIP () const = 0   virtual IPAddress localIP (int sock) const = 0   virtual uint16_t localPort () const = 0   virtual uint16_t localPort (int sock) const = 0    operator bool ()    virtual bool operator!= (const bool value)    virtual bool operator!= (const IWiFiClient &amp; other)    bool operator== (const IWiFiClient &amp; other) const   virtual bool operator== (const bool value)    virtual IPAddress remoteIP () const = 0   virtual IPAddress remoteIP (int sock) const = 0   virtual uint16_t remotePort () const = 0   virtual uint16_t remotePort (int sock) const = 0   virtual int setTimeout (uint32_t seconds) = 0   virtual int socket () = 0   virtual size_t write (Stream &amp; stream) = 0   size_t write_P (PGM_P buffer, size_t size)     ~IWiFiClient ()"},{"location":"ltapi/class_i_wi_fi_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient-12","title":"function IWiFiClient [1/2]","text":"<pre><code>inline IWiFiClient::IWiFiClient () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient-22","title":"function IWiFiClient [2/2]","text":"<pre><code>inline IWiFiClient::IWiFiClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-connect-12","title":"function connect [1/2]","text":"<pre><code>virtual int IWiFiClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-connect-22","title":"function connect [2/2]","text":"<pre><code>virtual int IWiFiClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-fd","title":"function fd","text":"<pre><code>virtual int IWiFiClient::fd () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localip-12","title":"function localIP [1/2]","text":"<pre><code>virtual IPAddress IWiFiClient::localIP () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localip-22","title":"function localIP [2/2]","text":"<pre><code>virtual IPAddress IWiFiClient::localIP (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localport-12","title":"function localPort [1/2]","text":"<pre><code>virtual uint16_t IWiFiClient::localPort () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localport-22","title":"function localPort [2/2]","text":"<pre><code>virtual uint16_t IWiFiClient::localPort (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline IWiFiClient::operator bool () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator","title":"function operator!=","text":"<pre><code>inline virtual bool IWiFiClient::operator!= (\n    const bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_1","title":"function operator!=","text":"<pre><code>inline virtual bool IWiFiClient::operator!= (\n    const IWiFiClient &amp; other\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_2","title":"function operator==","text":"<pre><code>bool IWiFiClient::operator== (\n    const IWiFiClient &amp; other\n) const\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_3","title":"function operator==","text":"<pre><code>inline virtual bool IWiFiClient::operator== (\n    const bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteip-12","title":"function remoteIP [1/2]","text":"<pre><code>virtual IPAddress IWiFiClient::remoteIP () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteip-22","title":"function remoteIP [2/2]","text":"<pre><code>virtual IPAddress IWiFiClient::remoteIP (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteport-12","title":"function remotePort [1/2]","text":"<pre><code>virtual uint16_t IWiFiClient::remotePort () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteport-22","title":"function remotePort [2/2]","text":"<pre><code>virtual uint16_t IWiFiClient::remotePort (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int IWiFiClient::setTimeout (\n    uint32_t seconds\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-socket","title":"function socket","text":"<pre><code>virtual int IWiFiClient::socket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-write","title":"function write","text":"<pre><code>virtual size_t IWiFiClient::write (\n    Stream &amp; stream\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-write_p","title":"function write_P","text":"<pre><code>inline size_t IWiFiClient::write_P (\n    PGM_P buffer,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient","title":"function ~IWiFiClient","text":"<pre><code>inline IWiFiClient::~IWiFiClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/WiFiClient.h</code></p>"},{"location":"ltapi/class_i_wi_fi_client_secure/","title":"Class IWiFiClientSecure","text":"<p>ClassList &gt; IWiFiClientSecure</p> <p>Inherited by the following classes: MbedTLSClient</p>"},{"location":"ltapi/class_i_wi_fi_client_secure/#public-functions","title":"Public Functions","text":"Type Name     virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual bool getFingerprintSHA256 (uint8_t result) = 0   virtual int lastError (char * buf, const size_t size) = 0   virtual bool loadCACert (Stream &amp; stream, size_t size) = 0   virtual bool loadCertificate (Stream &amp; stream, size_t size) = 0   virtual bool loadPrivateKey (Stream &amp; stream, size_t size) = 0   virtual void setAlpnProtocols (const char ** alpnProtocols) = 0   virtual void setCACert (const char * rootCA) = 0   virtual void setCertificate (const char * clientCA) = 0   virtual void setHandshakeTimeout (unsigned long handshakeTimeout) = 0   virtual void setInsecure () = 0   virtual void setPreSharedKey (const char * pskIdent, const char * psk) = 0   virtual void setPrivateKey (const char * privateKey) = 0   virtual bool verify (const char * fingerprint, const char * domainName) = 0"},{"location":"ltapi/class_i_wi_fi_client_secure/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-14","title":"function connect [1/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-24","title":"function connect [2/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    const char * host,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-34","title":"function connect [3/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-44","title":"function connect [4/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    const char * host,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-getfingerprintsha256","title":"function getFingerprintSHA256","text":"<pre><code>virtual bool IWiFiClientSecure::getFingerprintSHA256 (\n    uint8_t result\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-lasterror","title":"function lastError","text":"<pre><code>virtual int IWiFiClientSecure::lastError (\n    char * buf,\n    const size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadcacert","title":"function loadCACert","text":"<pre><code>virtual bool IWiFiClientSecure::loadCACert (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadcertificate","title":"function loadCertificate","text":"<pre><code>virtual bool IWiFiClientSecure::loadCertificate (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadprivatekey","title":"function loadPrivateKey","text":"<pre><code>virtual bool IWiFiClientSecure::loadPrivateKey (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setalpnprotocols","title":"function setAlpnProtocols","text":"<pre><code>virtual void IWiFiClientSecure::setAlpnProtocols (\n    const char ** alpnProtocols\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setcacert","title":"function setCACert","text":"<pre><code>virtual void IWiFiClientSecure::setCACert (\n    const char * rootCA\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setcertificate","title":"function setCertificate","text":"<pre><code>virtual void IWiFiClientSecure::setCertificate (\n    const char * clientCA\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-sethandshaketimeout","title":"function setHandshakeTimeout","text":"<pre><code>virtual void IWiFiClientSecure::setHandshakeTimeout (\n    unsigned long handshakeTimeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setinsecure","title":"function setInsecure","text":"<pre><code>virtual void IWiFiClientSecure::setInsecure () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setpresharedkey","title":"function setPreSharedKey","text":"<pre><code>virtual void IWiFiClientSecure::setPreSharedKey (\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setprivatekey","title":"function setPrivateKey","text":"<pre><code>virtual void IWiFiClientSecure::setPrivateKey (\n    const char * privateKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-verify","title":"function verify","text":"<pre><code>virtual bool IWiFiClientSecure::verify (\n    const char * fingerprint,\n    const char * domainName\n) = 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/WiFiClientSecure.h</code></p>"},{"location":"ltapi/class_i_wi_fi_server/","title":"Class IWiFiServer","text":"<p>template &lt;typename TWiFiClient typename TWiFiClient, typename typename&gt;</p> <p>ClassList &gt; IWiFiServer</p> <p>Inherits the following classes: Print</p>"},{"location":"ltapi/class_i_wi_fi_server/#public-functions","title":"Public Functions","text":"Type Name      IWiFiServer (uint16_t port=80, uint8_t maxClients=4)     IWiFiServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual TWiFiClient accept () = 0   TWiFiClient available ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true) = 0   void close ()    virtual void end () = 0   virtual bool getNoDelay () = 0   virtual bool hasClient () = 0   void listenOnLocalhost ()    virtual operator bool () = 0   virtual void setNoDelay (bool noDelay) = 0   virtual int setTimeout (uint32_t seconds) = 0   void stop ()    virtual void stopAll () = 0   size_t write (uint8_t data)     ~IWiFiServer ()"},{"location":"ltapi/class_i_wi_fi_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver-12","title":"function IWiFiServer [1/2]","text":"<pre><code>inline IWiFiServer::IWiFiServer (\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver-22","title":"function IWiFiServer [2/2]","text":"<pre><code>inline IWiFiServer::IWiFiServer (\n    const IPAddress &amp; addr,\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-accept","title":"function accept","text":"<pre><code>virtual TWiFiClient IWiFiServer::accept () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-available","title":"function available","text":"<pre><code>inline TWiFiClient IWiFiServer::available () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-begin","title":"function begin","text":"<pre><code>virtual bool IWiFiServer::begin (\n    uint16_t port=0,\n    bool reuseAddr=true\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-close","title":"function close","text":"<pre><code>inline void IWiFiServer::close () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-end","title":"function end","text":"<pre><code>virtual void IWiFiServer::end () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-getnodelay","title":"function getNoDelay","text":"<pre><code>virtual bool IWiFiServer::getNoDelay () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-hasclient","title":"function hasClient","text":"<pre><code>virtual bool IWiFiServer::hasClient () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-listenonlocalhost","title":"function listenOnLocalhost","text":"<pre><code>inline void IWiFiServer::listenOnLocalhost () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual IWiFiServer::operator bool () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-setnodelay","title":"function setNoDelay","text":"<pre><code>virtual void IWiFiServer::setNoDelay (\n    bool noDelay\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int IWiFiServer::setTimeout (\n    uint32_t seconds\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-stop","title":"function stop","text":"<pre><code>inline void IWiFiServer::stop () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-stopall","title":"function stopAll","text":"<pre><code>virtual void IWiFiServer::stopAll () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-write","title":"function write","text":"<pre><code>inline size_t IWiFiServer::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver","title":"function ~IWiFiServer","text":"<pre><code>inline IWiFiServer::~IWiFiServer () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/WiFiServer.h</code></p>"},{"location":"ltapi/class_i_wi_fi_u_d_p/","title":"Class IWiFiUDP","text":"<p>ClassList &gt; IWiFiUDP</p> <p>Inherits the following classes: UDP</p> <p>Inherited by the following classes: LwIPUDP</p>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#public-functions","title":"Public Functions","text":"Type Name      IWiFiUDP ()    virtual int available () = 0   virtual uint8_t begin (IPAddress ip, uint16_t port) = 0   virtual uint8_t begin (uint16_t port) = 0   virtual uint8_t beginMulticast (IPAddress ip, uint16_t port) = 0   virtual int beginMulticastPacket () = 0   virtual int beginPacket () = 0   virtual int beginPacket (IPAddress ip, uint16_t port) = 0   virtual int beginPacket (const char * host, uint16_t port) = 0   virtual int endPacket () = 0   virtual void flush () = 0   virtual int parsePacket () = 0   virtual int peek () = 0   virtual int read () = 0   virtual int read (unsigned char * buffer, size_t len) = 0   virtual int read (char * buffer, size_t len) = 0   virtual IPAddress remoteIP () = 0   virtual uint16_t remotePort () = 0   virtual void stop () = 0   virtual size_t write (uint8_t) = 0   virtual size_t write (const uint8_t * buffer, size_t size) = 0    ~IWiFiUDP ()"},{"location":"ltapi/class_i_wi_fi_u_d_p/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-iwifiudp","title":"function IWiFiUDP","text":"<pre><code>inline IWiFiUDP::IWiFiUDP () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-available","title":"function available","text":"<pre><code>virtual int IWiFiUDP::available () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual uint8_t IWiFiUDP::begin (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual uint8_t IWiFiUDP::begin (\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginmulticast","title":"function beginMulticast","text":"<pre><code>virtual uint8_t IWiFiUDP::beginMulticast (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginmulticastpacket","title":"function beginMulticastPacket","text":"<pre><code>virtual int IWiFiUDP::beginMulticastPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-13","title":"function beginPacket [1/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-23","title":"function beginPacket [2/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-33","title":"function beginPacket [3/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket (\n    const char * host,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-endpacket","title":"function endPacket","text":"<pre><code>virtual int IWiFiUDP::endPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-flush","title":"function flush","text":"<pre><code>virtual void IWiFiUDP::flush () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-parsepacket","title":"function parsePacket","text":"<pre><code>virtual int IWiFiUDP::parsePacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-peek","title":"function peek","text":"<pre><code>virtual int IWiFiUDP::peek () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-13","title":"function read [1/3]","text":"<pre><code>virtual int IWiFiUDP::read () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-23","title":"function read [2/3]","text":"<pre><code>virtual int IWiFiUDP::read (\n    unsigned char * buffer,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-33","title":"function read [3/3]","text":"<pre><code>virtual int IWiFiUDP::read (\n    char * buffer,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-remoteip","title":"function remoteIP","text":"<pre><code>virtual IPAddress IWiFiUDP::remoteIP () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-remoteport","title":"function remotePort","text":"<pre><code>virtual uint16_t IWiFiUDP::remotePort () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-stop","title":"function stop","text":"<pre><code>virtual void IWiFiUDP::stop () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t IWiFiUDP::write (\n    uint8_t\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-write-22","title":"function write [2/2]","text":"<pre><code>virtual size_t IWiFiUDP::write (\n    const uint8_t * buffer,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-iwifiudp_1","title":"function ~IWiFiUDP","text":"<pre><code>inline IWiFiUDP::~IWiFiUDP () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/WiFiUdp.h</code></p>"},{"location":"ltapi/class_libre_tiny/","title":"Class LibreTiny","text":"<p>ClassList &gt; LibreTiny</p> <p>Main LibreTiny API class.More...</p> <ul> <li><code>#include &lt;LT.h&gt;</code></li> </ul>"},{"location":"ltapi/class_libre_tiny/#public-functions","title":"Public Functions","text":"Type Name     const char * getBoard () Get board code.   const char * getChipCoreType () Get CPU core type name as string.   uint8_t getChipCores () Get CPU core count.   ChipFamily getChipFamily () Get CPU family ID (as lt_cpu_family_t enum member).   const char * getChipFamilyName () Get CPU family name as string.   uint32_t getChipId () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   const char * getChipModel () Get CPU model name as string (uppercase).   ChipType getChipType () Get CPU model ID (as lt_cpu_model_t enum member).   uint32_t getCpuFreq () Get CPU frequency in Hz.   uint32_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   const char * getDeviceName () Get device friendly name in format \"LT-&lt;chip model&gt;-&lt;MAC ID&gt;\". Can be used as hostname.   FlashId getFlashChipId () Read flash chip ID and return a lt_flash_id_t struct.   uint32_t getFlashChipSize () Get flash chip total size.   uint32_t getFreeHeap () Get free heap size.   uint32_t getHeapSize () Get total heap size.   uint32_t getMaxAllocHeap () Get largest block of heap that can be allocated at once.   uint32_t getMaxFreeBlockSize () Get largest block of heap that can be allocated at once.   uint32_t getMinFreeHeap () Get lowest level of free heap memory.   uint32_t getRamSize () Get total RAM size.   ResetReason getResetReason () Get the reason of last chip reboot.   const char * getResetReasonName (ResetReason reason=lt_get_reboot_reason()) Get a textual representation of a reboot reason.   const char * getVersion () Reset reason enumeration.   void gpioRecover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   void restart () Reboot the CPU.   void restartDownloadMode () Reboot the CPU and stay in download mode (if possible)."},{"location":"ltapi/class_libre_tiny/#detailed-description","title":"Detailed Description","text":"<p>Since v1.0.0, this class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>LT</code> global object. </p>"},{"location":"ltapi/class_libre_tiny/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_libre_tiny/#function-getboard","title":"function getBoard","text":"<pre><code>inline const char * LibreTiny::getBoard () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipcoretype","title":"function getChipCoreType","text":"<pre><code>inline const char * LibreTiny::getChipCoreType () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipcores","title":"function getChipCores","text":"<pre><code>inline uint8_t LibreTiny::getChipCores () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipfamily","title":"function getChipFamily","text":"<pre><code>inline ChipFamily LibreTiny::getChipFamily () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipfamilyname","title":"function getChipFamilyName","text":"<pre><code>inline const char * LibreTiny::getChipFamilyName () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipid","title":"function getChipId","text":"<pre><code>inline uint32_t LibreTiny::getChipId () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchipmodel","title":"function getChipModel","text":"<pre><code>inline const char * LibreTiny::getChipModel () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getchiptype","title":"function getChipType","text":"<pre><code>inline ChipType LibreTiny::getChipType () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getcpufreq","title":"function getCpuFreq","text":"<pre><code>inline uint32_t LibreTiny::getCpuFreq () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getcpufreqmhz","title":"function getCpuFreqMHz","text":"<pre><code>inline uint32_t LibreTiny::getCpuFreqMHz () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getcyclecount","title":"function getCycleCount","text":"<pre><code>inline uint32_t LibreTiny::getCycleCount () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getdevicename","title":"function getDeviceName","text":"<pre><code>inline const char * LibreTiny::getDeviceName () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getflashchipid","title":"function getFlashChipId","text":"<pre><code>inline FlashId LibreTiny::getFlashChipId () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getflashchipsize","title":"function getFlashChipSize","text":"<p>Get flash chip total size. <pre><code>inline uint32_t LibreTiny::getFlashChipSize () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size.  </p>"},{"location":"ltapi/class_libre_tiny/#function-getfreeheap","title":"function getFreeHeap","text":"<pre><code>inline uint32_t LibreTiny::getFreeHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getheapsize","title":"function getHeapSize","text":"<pre><code>inline uint32_t LibreTiny::getHeapSize () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getmaxallocheap","title":"function getMaxAllocHeap","text":"<pre><code>inline uint32_t LibreTiny::getMaxAllocHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getmaxfreeblocksize","title":"function getMaxFreeBlockSize","text":"<pre><code>inline uint32_t LibreTiny::getMaxFreeBlockSize () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getminfreeheap","title":"function getMinFreeHeap","text":"<pre><code>inline uint32_t LibreTiny::getMinFreeHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getramsize","title":"function getRamSize","text":"<pre><code>inline uint32_t LibreTiny::getRamSize () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getresetreason","title":"function getResetReason","text":"<pre><code>inline ResetReason LibreTiny::getResetReason () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-getresetreasonname","title":"function getResetReasonName","text":"<p>Get a textual representation of a reboot reason. <pre><code>inline const char * LibreTiny::getResetReasonName (\n    ResetReason reason=lt_get_reboot_reason()\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, pass 0 to read from lt_reboot_get_reason()  </li> </ul>"},{"location":"ltapi/class_libre_tiny/#function-getversion","title":"function getVersion","text":"<pre><code>inline const char * LibreTiny::getVersion () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-gpiorecover","title":"function gpioRecover","text":"<pre><code>inline void LibreTiny::gpioRecover () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-restart","title":"function restart","text":"<pre><code>inline void LibreTiny::restart () \n</code></pre>"},{"location":"ltapi/class_libre_tiny/#function-restartdownloadmode","title":"function restartDownloadMode","text":"<p>Reboot the CPU and stay in download mode (if possible). <pre><code>inline void LibreTiny::restartDownloadMode () \n</code></pre></p> <p>Returns:</p> <p>whether download-mode reboot is possible </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/LT/LT.h</code></p>"},{"location":"ltapi/class_libre_tiny_o_t_a/","title":"Class LibreTinyOTA","text":"<p>ClassList &gt; LibreTinyOTA</p> <p>Over-the-Air updates helper class. More...</p> <ul> <li><code>#include &lt;OTA.h&gt;</code></li> </ul>"},{"location":"ltapi/class_libre_tiny_o_t_a/#public-functions","title":"Public Functions","text":"Type Name     bool canRollback () Check if OTA rollback is possible (switching the stored index to another partition).   uint8_t getCurrentIndex () Get the currently running firmware's OTA index.   uint8_t getStoredIndex () Read the currently active OTA index, i.e. the one that will boot upon restart.   lt_ota_type_t getType () Get OTA type of the device's chip.   uf2_ota_scheme_t getUF2Scheme () Check which UF2 OTA scheme should be used for applying firmware updates.   bool isValid (uint8_t index) Check if the specified OTA image is valid.   bool switchImage (bool revert=false) Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid."},{"location":"ltapi/class_libre_tiny_o_t_a/#detailed-description","title":"Detailed Description","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>OTA</code> global object. </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_libre_tiny_o_t_a/#function-canrollback","title":"function canRollback","text":"<p>Check if OTA rollback is possible (switching the stored index to another partition). <pre><code>inline bool LibreTinyOTA::canRollback () \n</code></pre></p> <p>Note that this is not the same as \"switching\" OTA with revert=true.</p> <p>Returns:</p> <p>true if 2nd image is valid and the chip is dual-OTA; false otherwise </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-getcurrentindex","title":"function getCurrentIndex","text":"<p>Get the currently running firmware's OTA index. <pre><code>inline uint8_t LibreTinyOTA::getCurrentIndex () \n</code></pre></p> <p>Returns:</p> <p>OTA index if dual-OTA is supported, 0 otherwise </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-getstoredindex","title":"function getStoredIndex","text":"<p>Read the currently active OTA index, i.e. the one that will boot upon restart. <pre><code>inline uint8_t LibreTinyOTA::getStoredIndex () \n</code></pre></p> <p>Returns:</p> <p>OTA index if dual-OTA is supported, 0 otherwise </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-gettype","title":"function getType","text":"<pre><code>inline lt_ota_type_t LibreTinyOTA::getType () \n</code></pre>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-getuf2scheme","title":"function getUF2Scheme","text":"<p>Check which UF2 OTA scheme should be used for applying firmware updates. <pre><code>inline uf2_ota_scheme_t LibreTinyOTA::getUF2Scheme () \n</code></pre></p> <p>Returns:</p> <p>OTA scheme of the target partition </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-isvalid","title":"function isValid","text":"<p>Check if the specified OTA image is valid. <pre><code>inline bool LibreTinyOTA::isValid (\n    uint8_t index\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>index</code> OTA index to check; 0 for single-OTA chips, 1 or 2 for dual-OTA chips </li> </ul> <p>Returns:</p> <p>true if index is valid for the chip's OTA type, and there is a valid image; false otherwise </p>"},{"location":"ltapi/class_libre_tiny_o_t_a/#function-switchimage","title":"function switchImage","text":"<p>Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid. <pre><code>inline bool LibreTinyOTA::switchImage (\n    bool revert=false\n) \n</code></pre></p> <p>This can be used to \"activate\" the upgrade after flashing.</p> <p>Parameters:</p> <ul> <li><code>revert</code> switch if (and only if) the other image is already marked as active (i.e. switch back to the running image) </li> </ul> <p>Returns:</p> <p>false if the second image (or upgrade image) is not valid; false if writing failed; true otherwise </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/OTA/OTA.h</code></p>"},{"location":"ltapi/class_libre_tiny_w_d_t/","title":"Class LibreTinyWDT","text":"<p>ClassList &gt; LibreTinyWDT</p> <p>Watchdog control class. More...</p> <ul> <li><code>#include &lt;WDT.h&gt;</code></li> </ul>"},{"location":"ltapi/class_libre_tiny_w_d_t/#public-functions","title":"Public Functions","text":"Type Name     void disable () Disable the hardware watchdog.   bool enable (uint32_t timeout=10000) Enable the hardware watchdog.   void feed () Feed/reset the hardware watchdog timer."},{"location":"ltapi/class_libre_tiny_w_d_t/#detailed-description","title":"Detailed Description","text":"<p>This class only consists of inline functions, which wrap the LibreTiny C API (lt_api.h). Refer to the docs of the C API for more information.</p> <p>The class is accessible using the <code>WDT</code> global object. </p>"},{"location":"ltapi/class_libre_tiny_w_d_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_libre_tiny_w_d_t/#function-disable","title":"function disable","text":"<pre><code>inline void LibreTinyWDT::disable () \n</code></pre>"},{"location":"ltapi/class_libre_tiny_w_d_t/#function-enable","title":"function enable","text":"<p>Enable the hardware watchdog. <pre><code>inline bool LibreTinyWDT::enable (\n    uint32_t timeout=10000\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> watchdog timeout, milliseconds </li> </ul> <p>Returns:</p> <p>whether the chip has a hardware watchdog </p>"},{"location":"ltapi/class_libre_tiny_w_d_t/#function-feed","title":"function feed","text":"<pre><code>inline void LibreTinyWDT::feed () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/WDT/WDT.h</code></p>"},{"location":"ltapi/class_lw_i_p_client/","title":"Class LwIPClient","text":"<p>ClassList &gt; LwIPClient</p> <p>Inherits the following classes: IWiFiClient</p> <p>Inherited by the following classes: MbedTLSClient</p>"},{"location":"ltapi/class_lw_i_p_client/#public-functions","title":"Public Functions","text":"Type Name      LwIPClient ()     LwIPClient (int sock)    int available ()    int connect (IPAddress ip, uint16_t port)    int connect (const char * host, uint16_t port)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout)    virtual int connect (const char * host, uint16_t port, int32_t timeout)    uint8_t connected ()    virtual int fd () const   void flush ()    virtual IPAddress localIP () const   virtual IPAddress localIP (int sock) const   virtual uint16_t localPort () const   virtual uint16_t localPort (int sock) const   LwIPClient &amp; operator= (const LwIPClient &amp; other)    int peek ()    int read ()    int read (uint8_t * buf, size_t size)    virtual IPAddress remoteIP () const   virtual IPAddress remoteIP (int sock) const   virtual uint16_t remotePort () const   virtual uint16_t remotePort (int sock) const   virtual int setTimeout (uint32_t seconds)    virtual int socket ()    void stop ()    size_t write (uint8_t data)    size_t write (const uint8_t * buf, size_t size)    virtual size_t write (Stream &amp; stream)     ~LwIPClient ()"},{"location":"ltapi/class_lw_i_p_client/#public-functions-inherited-from-iwificlient","title":"Public Functions inherited from IWiFiClient","text":"<p>See IWiFiClient</p>    Type Name      IWiFiClient ()     IWiFiClient (int sock)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout) = 0   virtual int connect (const char * host, uint16_t port, int32_t timeout) = 0   virtual int fd () const = 0   virtual IPAddress localIP () const = 0   virtual IPAddress localIP (int sock) const = 0   virtual uint16_t localPort () const = 0   virtual uint16_t localPort (int sock) const = 0    operator bool ()    virtual bool operator!= (const bool value)    virtual bool operator!= (const IWiFiClient &amp; other)    bool operator== (const IWiFiClient &amp; other) const   virtual bool operator== (const bool value)    virtual IPAddress remoteIP () const = 0   virtual IPAddress remoteIP (int sock) const = 0   virtual uint16_t remotePort () const = 0   virtual uint16_t remotePort (int sock) const = 0   virtual int setTimeout (uint32_t seconds) = 0   virtual int socket () = 0   virtual size_t write (Stream &amp; stream) = 0   size_t write_P (PGM_P buffer, size_t size)     ~IWiFiClient ()"},{"location":"ltapi/class_lw_i_p_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient-12","title":"function LwIPClient [1/2]","text":"<pre><code>LwIPClient::LwIPClient () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient-22","title":"function LwIPClient [2/2]","text":"<pre><code>LwIPClient::LwIPClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-available","title":"function available","text":"<pre><code>int LwIPClient::available () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-14","title":"function connect [1/4]","text":"<pre><code>int LwIPClient::connect (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-24","title":"function connect [2/4]","text":"<pre><code>int LwIPClient::connect (\n    const char * host,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-34","title":"function connect [3/4]","text":"<pre><code>virtual int LwIPClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements IWiFiClient::connect</p>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-44","title":"function connect [4/4]","text":"<pre><code>virtual int LwIPClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements IWiFiClient::connect</p>"},{"location":"ltapi/class_lw_i_p_client/#function-connected","title":"function connected","text":"<pre><code>uint8_t LwIPClient::connected () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-fd","title":"function fd","text":"<pre><code>virtual int LwIPClient::fd () const\n</code></pre> <p>Implements IWiFiClient::fd</p>"},{"location":"ltapi/class_lw_i_p_client/#function-flush","title":"function flush","text":"<pre><code>void LwIPClient::flush () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-localip-12","title":"function localIP [1/2]","text":"<pre><code>virtual IPAddress LwIPClient::localIP () const\n</code></pre> <p>Implements IWiFiClient::localIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localip-22","title":"function localIP [2/2]","text":"<pre><code>virtual IPAddress LwIPClient::localIP (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::localIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localport-12","title":"function localPort [1/2]","text":"<pre><code>virtual uint16_t LwIPClient::localPort () const\n</code></pre> <p>Implements IWiFiClient::localPort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localport-22","title":"function localPort [2/2]","text":"<pre><code>virtual uint16_t LwIPClient::localPort (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::localPort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-operator","title":"function operator=","text":"<pre><code>LwIPClient &amp; LwIPClient::operator= (\n    const LwIPClient &amp; other\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-peek","title":"function peek","text":"<pre><code>int LwIPClient::peek () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-read-12","title":"function read [1/2]","text":"<pre><code>int LwIPClient::read () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-read-22","title":"function read [2/2]","text":"<pre><code>int LwIPClient::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteip-12","title":"function remoteIP [1/2]","text":"<pre><code>virtual IPAddress LwIPClient::remoteIP () const\n</code></pre> <p>Implements IWiFiClient::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteip-22","title":"function remoteIP [2/2]","text":"<pre><code>virtual IPAddress LwIPClient::remoteIP (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteport-12","title":"function remotePort [1/2]","text":"<pre><code>virtual uint16_t LwIPClient::remotePort () const\n</code></pre> <p>Implements IWiFiClient::remotePort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteport-22","title":"function remotePort [2/2]","text":"<pre><code>virtual uint16_t LwIPClient::remotePort (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::remotePort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int LwIPClient::setTimeout (\n    uint32_t seconds\n) \n</code></pre> <p>Implements IWiFiClient::setTimeout</p>"},{"location":"ltapi/class_lw_i_p_client/#function-socket","title":"function socket","text":"<pre><code>virtual int LwIPClient::socket () \n</code></pre> <p>Implements IWiFiClient::socket</p>"},{"location":"ltapi/class_lw_i_p_client/#function-stop","title":"function stop","text":"<pre><code>void LwIPClient::stop () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-13","title":"function write [1/3]","text":"<pre><code>size_t LwIPClient::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-23","title":"function write [2/3]","text":"<pre><code>size_t LwIPClient::write (\n    const uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-33","title":"function write [3/3]","text":"<pre><code>virtual size_t LwIPClient::write (\n    Stream &amp; stream\n) \n</code></pre> <p>Implements IWiFiClient::write</p>"},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient","title":"function ~LwIPClient","text":"<pre><code>LwIPClient::~LwIPClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPClient.h</code></p>"},{"location":"ltapi/class_lw_i_p_rx_buffer/","title":"Class LwIPRxBuffer","text":"<p>ClassList &gt; LwIPRxBuffer</p>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#public-functions","title":"Public Functions","text":"Type Name      LwIPRxBuffer (int sock, size_t size=1436)    size_t available ()    bool failed ()    int peek ()    int read (uint8_t * dst, size_t len)     ~LwIPRxBuffer ()"},{"location":"ltapi/class_lw_i_p_rx_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-lwiprxbuffer","title":"function LwIPRxBuffer","text":"<pre><code>LwIPRxBuffer::LwIPRxBuffer (\n    int sock,\n    size_t size=1436\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-available","title":"function available","text":"<pre><code>size_t LwIPRxBuffer::available () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-failed","title":"function failed","text":"<pre><code>bool LwIPRxBuffer::failed () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-peek","title":"function peek","text":"<pre><code>int LwIPRxBuffer::peek () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-read","title":"function read","text":"<pre><code>int LwIPRxBuffer::read (\n    uint8_t * dst,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-lwiprxbuffer_1","title":"function ~LwIPRxBuffer","text":"<pre><code>LwIPRxBuffer::~LwIPRxBuffer () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPRxBuffer.h</code></p>"},{"location":"ltapi/class_lw_i_p_server/","title":"Class LwIPServer","text":"<p>ClassList &gt; LwIPServer</p> <p>Inherits the following classes: IWiFiServer</p>"},{"location":"ltapi/class_lw_i_p_server/#public-functions","title":"Public Functions","text":"Type Name      LwIPServer (uint16_t port=80, uint8_t maxClients=4)     LwIPServer (int port=80, uint8_t maxClients=4)     LwIPServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual WiFiClient accept ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true)    virtual void end ()    virtual bool getNoDelay ()    virtual bool hasClient ()    virtual operator bool ()    virtual void setNoDelay (bool noDelay)    virtual int setTimeout (uint32_t seconds)    virtual void stopAll ()    size_t write (const uint8_t * buffer, size_t size)"},{"location":"ltapi/class_lw_i_p_server/#public-functions-inherited-from-iwifiserver","title":"Public Functions inherited from IWiFiServer","text":"<p>See IWiFiServer</p>    Type Name      IWiFiServer (uint16_t port=80, uint8_t maxClients=4)     IWiFiServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual TWiFiClient accept () = 0   TWiFiClient available ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true) = 0   void close ()    virtual void end () = 0   virtual bool getNoDelay () = 0   virtual bool hasClient () = 0   void listenOnLocalhost ()    virtual operator bool () = 0   virtual void setNoDelay (bool noDelay) = 0   virtual int setTimeout (uint32_t seconds) = 0   void stop ()    virtual void stopAll () = 0   size_t write (uint8_t data)     ~IWiFiServer ()"},{"location":"ltapi/class_lw_i_p_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-24","title":"function LwIPServer [2/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-34","title":"function LwIPServer [3/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    int port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-44","title":"function LwIPServer [4/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    const IPAddress &amp; addr,\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-accept","title":"function accept","text":"<pre><code>virtual WiFiClient LwIPServer::accept () \n</code></pre> <p>Implements IWiFiServer::accept</p>"},{"location":"ltapi/class_lw_i_p_server/#function-begin","title":"function begin","text":"<pre><code>virtual bool LwIPServer::begin (\n    uint16_t port=0,\n    bool reuseAddr=true\n) \n</code></pre> <p>Implements IWiFiServer::begin</p>"},{"location":"ltapi/class_lw_i_p_server/#function-end","title":"function end","text":"<pre><code>virtual void LwIPServer::end () \n</code></pre> <p>Implements IWiFiServer::end</p>"},{"location":"ltapi/class_lw_i_p_server/#function-getnodelay","title":"function getNoDelay","text":"<pre><code>virtual bool LwIPServer::getNoDelay () \n</code></pre> <p>Implements IWiFiServer::getNoDelay</p>"},{"location":"ltapi/class_lw_i_p_server/#function-hasclient","title":"function hasClient","text":"<pre><code>virtual bool LwIPServer::hasClient () \n</code></pre> <p>Implements IWiFiServer::hasClient</p>"},{"location":"ltapi/class_lw_i_p_server/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual LwIPServer::operator bool () \n</code></pre> <p>Implements IWiFiServer::operator bool</p>"},{"location":"ltapi/class_lw_i_p_server/#function-setnodelay","title":"function setNoDelay","text":"<pre><code>virtual void LwIPServer::setNoDelay (\n    bool noDelay\n) \n</code></pre> <p>Implements IWiFiServer::setNoDelay</p>"},{"location":"ltapi/class_lw_i_p_server/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int LwIPServer::setTimeout (\n    uint32_t seconds\n) \n</code></pre> <p>Implements IWiFiServer::setTimeout</p>"},{"location":"ltapi/class_lw_i_p_server/#function-stopall","title":"function stopAll","text":"<pre><code>inline virtual void LwIPServer::stopAll () \n</code></pre> <p>Implements IWiFiServer::stopAll</p>"},{"location":"ltapi/class_lw_i_p_server/#function-write","title":"function write","text":"<pre><code>inline size_t LwIPServer::write (\n    const uint8_t * buffer,\n    size_t size\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/LwIPServer.h</code></p>"},{"location":"ltapi/class_lw_i_p_u_d_p/","title":"Class LwIPUDP","text":"<p>ClassList &gt; LwIPUDP</p> <p>Inherits the following classes: IWiFiUDP</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions","title":"Public Functions","text":"Type Name      LwIPUDP ()    virtual int available ()    virtual uint8_t begin (IPAddress ip, uint16_t port)    virtual uint8_t begin (uint16_t port)    virtual uint8_t beginMulticast (IPAddress ip, uint16_t port)    virtual int beginMulticastPacket ()    virtual int beginPacket ()    virtual int beginPacket (IPAddress ip, uint16_t port)    virtual int beginPacket (const char * host, uint16_t port)    virtual int endPacket ()    virtual void flush ()    virtual int parsePacket ()    virtual int peek ()    virtual int read ()    virtual int read (unsigned char * buffer, size_t len)    virtual int read (char * buffer, size_t len)    virtual IPAddress remoteIP ()    virtual uint16_t remotePort ()    virtual void stop ()    virtual size_t write (uint8_t)    virtual size_t write (const uint8_t * buffer, size_t size)     ~LwIPUDP ()"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions-inherited-from-iwifiudp","title":"Public Functions inherited from IWiFiUDP","text":"<p>See IWiFiUDP</p>    Type Name      IWiFiUDP ()    virtual int available () = 0   virtual uint8_t begin (IPAddress ip, uint16_t port) = 0   virtual uint8_t begin (uint16_t port) = 0   virtual uint8_t beginMulticast (IPAddress ip, uint16_t port) = 0   virtual int beginMulticastPacket () = 0   virtual int beginPacket () = 0   virtual int beginPacket (IPAddress ip, uint16_t port) = 0   virtual int beginPacket (const char * host, uint16_t port) = 0   virtual int endPacket () = 0   virtual void flush () = 0   virtual int parsePacket () = 0   virtual int peek () = 0   virtual int read () = 0   virtual int read (unsigned char * buffer, size_t len) = 0   virtual int read (char * buffer, size_t len) = 0   virtual IPAddress remoteIP () = 0   virtual uint16_t remotePort () = 0   virtual void stop () = 0   virtual size_t write (uint8_t) = 0   virtual size_t write (const uint8_t * buffer, size_t size) = 0    ~IWiFiUDP ()"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_u_d_p/#function-lwipudp","title":"function LwIPUDP","text":"<pre><code>LwIPUDP::LwIPUDP () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-available","title":"function available","text":"<pre><code>virtual int LwIPUDP::available () \n</code></pre> <p>Implements IWiFiUDP::available</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual uint8_t LwIPUDP::begin (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::begin</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual uint8_t LwIPUDP::begin (\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::begin</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginmulticast","title":"function beginMulticast","text":"<pre><code>virtual uint8_t LwIPUDP::beginMulticast (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginMulticast</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginmulticastpacket","title":"function beginMulticastPacket","text":"<pre><code>virtual int LwIPUDP::beginMulticastPacket () \n</code></pre> <p>Implements IWiFiUDP::beginMulticastPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-13","title":"function beginPacket [1/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket () \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-23","title":"function beginPacket [2/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-33","title":"function beginPacket [3/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket (\n    const char * host,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-endpacket","title":"function endPacket","text":"<pre><code>virtual int LwIPUDP::endPacket () \n</code></pre> <p>Implements IWiFiUDP::endPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-flush","title":"function flush","text":"<pre><code>virtual void LwIPUDP::flush () \n</code></pre> <p>Implements IWiFiUDP::flush</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-parsepacket","title":"function parsePacket","text":"<pre><code>virtual int LwIPUDP::parsePacket () \n</code></pre> <p>Implements IWiFiUDP::parsePacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-peek","title":"function peek","text":"<pre><code>virtual int LwIPUDP::peek () \n</code></pre> <p>Implements IWiFiUDP::peek</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-13","title":"function read [1/3]","text":"<pre><code>virtual int LwIPUDP::read () \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-23","title":"function read [2/3]","text":"<pre><code>virtual int LwIPUDP::read (\n    unsigned char * buffer,\n    size_t len\n) \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-33","title":"function read [3/3]","text":"<pre><code>virtual int LwIPUDP::read (\n    char * buffer,\n    size_t len\n) \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-remoteip","title":"function remoteIP","text":"<pre><code>virtual IPAddress LwIPUDP::remoteIP () \n</code></pre> <p>Implements IWiFiUDP::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-remoteport","title":"function remotePort","text":"<pre><code>virtual uint16_t LwIPUDP::remotePort () \n</code></pre> <p>Implements IWiFiUDP::remotePort</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-stop","title":"function stop","text":"<pre><code>virtual void LwIPUDP::stop () \n</code></pre> <p>Implements IWiFiUDP::stop</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t LwIPUDP::write (\n    uint8_t\n) \n</code></pre> <p>Implements IWiFiUDP::write</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-write-22","title":"function write [2/2]","text":"<pre><code>virtual size_t LwIPUDP::write (\n    const uint8_t * buffer,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiUDP::write</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-lwipudp_1","title":"function ~LwIPUDP","text":"<pre><code>LwIPUDP::~LwIPUDP () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/LwIPUdp.h</code></p>"},{"location":"ltapi/struct_m_d5_context/","title":"Struct MD5Context","text":"<p>ClassList &gt; MD5Context</p>"},{"location":"ltapi/struct_m_d5_context/#public-attributes","title":"Public Attributes","text":"Type Name     unsigned long bits    unsigned long buf    unsigned char in"},{"location":"ltapi/struct_m_d5_context/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_m_d5_context/#variable-bits","title":"variable bits","text":"<pre><code>unsigned long MD5Context::bits[2];\n</code></pre>"},{"location":"ltapi/struct_m_d5_context/#variable-buf","title":"variable buf","text":"<pre><code>unsigned long MD5Context::buf[4];\n</code></pre>"},{"location":"ltapi/struct_m_d5_context/#variable-in","title":"variable in","text":"<pre><code>unsigned char MD5Context::in[64];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5HostapdImpl.h</code></p>"},{"location":"ltapi/class_mbed_t_l_s_client/","title":"Class MbedTLSClient","text":"<p>ClassList &gt; MbedTLSClient</p> <p>Inherits the following classes: LwIPClient,  IWiFiClientSecure</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions","title":"Public Functions","text":"Type Name      MbedTLSClient ()     MbedTLSClient (int sock)    int available ()    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout)    virtual int connect (const char * host, uint16_t port, int32_t timeout)    virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey)    virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey)    virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk)    virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk)    int connect (IPAddress ip, uint16_t port)    int connect (const char * host, uint16_t port)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout)    virtual int connect (const char * host, uint16_t port, int32_t timeout)    void flush ()    virtual bool getFingerprintSHA256 (uint8_t result)    virtual int lastError (char * buf, const size_t size)    virtual bool loadCACert (Stream &amp; stream, size_t size)    virtual bool loadCertificate (Stream &amp; stream, size_t size)    virtual bool loadPrivateKey (Stream &amp; stream, size_t size)    int peek ()    int read (uint8_t * buf, size_t size)    int read ()    int read (uint8_t * buf, size_t size)    virtual void setAlpnProtocols (const char ** alpnProtocols)    virtual void setCACert (const char * rootCA)    virtual void setCertificate (const char * clientCA)    virtual void setHandshakeTimeout (unsigned long handshakeTimeout)    virtual void setInsecure ()    virtual void setPreSharedKey (const char * pskIdent, const char * psk)    virtual void setPrivateKey (const char * privateKey)    void stop ()    virtual bool verify (const char * fingerprint, const char * domainName)    size_t write (const uint8_t * buf, size_t size)     ~MbedTLSClient ()"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-inherited-from-lwipclient","title":"Public Functions inherited from LwIPClient","text":"<p>See LwIPClient</p>    Type Name      LwIPClient ()     LwIPClient (int sock)    int available ()    int connect (IPAddress ip, uint16_t port)    int connect (const char * host, uint16_t port)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout)    virtual int connect (const char * host, uint16_t port, int32_t timeout)    uint8_t connected ()    virtual int fd () const   void flush ()    virtual IPAddress localIP () const   virtual IPAddress localIP (int sock) const   virtual uint16_t localPort () const   virtual uint16_t localPort (int sock) const   LwIPClient &amp; operator= (const LwIPClient &amp; other)    int peek ()    int read ()    int read (uint8_t * buf, size_t size)    virtual IPAddress remoteIP () const   virtual IPAddress remoteIP (int sock) const   virtual uint16_t remotePort () const   virtual uint16_t remotePort (int sock) const   virtual int setTimeout (uint32_t seconds)    virtual int socket ()    void stop ()    size_t write (uint8_t data)    size_t write (const uint8_t * buf, size_t size)    virtual size_t write (Stream &amp; stream)     ~LwIPClient ()"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-inherited-from-iwificlient","title":"Public Functions inherited from IWiFiClient","text":"<p>See IWiFiClient</p>    Type Name      IWiFiClient ()     IWiFiClient (int sock)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout) = 0   virtual int connect (const char * host, uint16_t port, int32_t timeout) = 0   virtual int fd () const = 0   virtual IPAddress localIP () const = 0   virtual IPAddress localIP (int sock) const = 0   virtual uint16_t localPort () const = 0   virtual uint16_t localPort (int sock) const = 0    operator bool ()    virtual bool operator!= (const bool value)    virtual bool operator!= (const IWiFiClient &amp; other)    bool operator== (const IWiFiClient &amp; other) const   virtual bool operator== (const bool value)    virtual IPAddress remoteIP () const = 0   virtual IPAddress remoteIP (int sock) const = 0   virtual uint16_t remotePort () const = 0   virtual uint16_t remotePort (int sock) const = 0   virtual int setTimeout (uint32_t seconds) = 0   virtual int socket () = 0   virtual size_t write (Stream &amp; stream) = 0   size_t write_P (PGM_P buffer, size_t size)     ~IWiFiClient ()"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-inherited-from-iwificlientsecure","title":"Public Functions inherited from IWiFiClientSecure","text":"<p>See IWiFiClientSecure</p>    Type Name     virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual bool getFingerprintSHA256 (uint8_t result) = 0   virtual int lastError (char * buf, const size_t size) = 0   virtual bool loadCACert (Stream &amp; stream, size_t size) = 0   virtual bool loadCertificate (Stream &amp; stream, size_t size) = 0   virtual bool loadPrivateKey (Stream &amp; stream, size_t size) = 0   virtual void setAlpnProtocols (const char ** alpnProtocols) = 0   virtual void setCACert (const char * rootCA) = 0   virtual void setCertificate (const char * clientCA) = 0   virtual void setHandshakeTimeout (unsigned long handshakeTimeout) = 0   virtual void setInsecure () = 0   virtual void setPreSharedKey (const char * pskIdent, const char * psk) = 0   virtual void setPrivateKey (const char * privateKey) = 0   virtual bool verify (const char * fingerprint, const char * domainName) = 0"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient-12","title":"function MbedTLSClient [1/2]","text":"<pre><code>MbedTLSClient::MbedTLSClient () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient-22","title":"function MbedTLSClient [2/2]","text":"<pre><code>MbedTLSClient::MbedTLSClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-available","title":"function available","text":"<pre><code>int MbedTLSClient::available () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-211","title":"function connect [2/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements LwIPClient::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-311","title":"function connect [3/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements LwIPClient::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-411","title":"function connect [4/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-511","title":"function connect [5/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-611","title":"function connect [6/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-711","title":"function connect [7/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-811","title":"function connect [8/11]","text":"<pre><code>int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-911","title":"function connect [9/11]","text":"<pre><code>int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-1011","title":"function connect [10/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements LwIPClient::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-1111","title":"function connect [11/11]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements LwIPClient::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-flush","title":"function flush","text":"<pre><code>void MbedTLSClient::flush () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-getfingerprintsha256","title":"function getFingerprintSHA256","text":"<pre><code>virtual bool MbedTLSClient::getFingerprintSHA256 (\n    uint8_t result\n) \n</code></pre> <p>Implements IWiFiClientSecure::getFingerprintSHA256</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-lasterror","title":"function lastError","text":"<pre><code>virtual int MbedTLSClient::lastError (\n    char * buf,\n    const size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::lastError</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadcacert","title":"function loadCACert","text":"<pre><code>virtual bool MbedTLSClient::loadCACert (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadCACert</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadcertificate","title":"function loadCertificate","text":"<pre><code>virtual bool MbedTLSClient::loadCertificate (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadCertificate</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadprivatekey","title":"function loadPrivateKey","text":"<pre><code>virtual bool MbedTLSClient::loadPrivateKey (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadPrivateKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-peek","title":"function peek","text":"<pre><code>int MbedTLSClient::peek () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-read-13","title":"function read [1/3]","text":"<pre><code>int MbedTLSClient::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-read-23","title":"function read [2/3]","text":"<pre><code>int MbedTLSClient::read () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-read-33","title":"function read [3/3]","text":"<pre><code>int MbedTLSClient::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setalpnprotocols","title":"function setAlpnProtocols","text":"<pre><code>virtual void MbedTLSClient::setAlpnProtocols (\n    const char ** alpnProtocols\n) \n</code></pre> <p>Implements IWiFiClientSecure::setAlpnProtocols</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setcacert","title":"function setCACert","text":"<pre><code>virtual void MbedTLSClient::setCACert (\n    const char * rootCA\n) \n</code></pre> <p>Implements IWiFiClientSecure::setCACert</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setcertificate","title":"function setCertificate","text":"<pre><code>virtual void MbedTLSClient::setCertificate (\n    const char * clientCA\n) \n</code></pre> <p>Implements IWiFiClientSecure::setCertificate</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-sethandshaketimeout","title":"function setHandshakeTimeout","text":"<pre><code>virtual void MbedTLSClient::setHandshakeTimeout (\n    unsigned long handshakeTimeout\n) \n</code></pre> <p>Implements IWiFiClientSecure::setHandshakeTimeout</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setinsecure","title":"function setInsecure","text":"<pre><code>virtual void MbedTLSClient::setInsecure () \n</code></pre> <p>Implements IWiFiClientSecure::setInsecure</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setpresharedkey","title":"function setPreSharedKey","text":"<pre><code>virtual void MbedTLSClient::setPreSharedKey (\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::setPreSharedKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setprivatekey","title":"function setPrivateKey","text":"<pre><code>virtual void MbedTLSClient::setPrivateKey (\n    const char * privateKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::setPrivateKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-stop","title":"function stop","text":"<pre><code>void MbedTLSClient::stop () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-verify","title":"function verify","text":"<pre><code>virtual bool MbedTLSClient::verify (\n    const char * fingerprint,\n    const char * domainName\n) \n</code></pre> <p>Implements IWiFiClientSecure::verify</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-write","title":"function write","text":"<pre><code>size_t MbedTLSClient::write (\n    const uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient","title":"function ~MbedTLSClient","text":"<pre><code>MbedTLSClient::~MbedTLSClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/MbedTLSClient.h</code></p>"},{"location":"ltapi/struct_pin_info/","title":"Struct PinInfo","text":"<p>ClassList &gt; PinInfo</p>"},{"location":"ltapi/struct_pin_info/#public-attributes","title":"Public Attributes","text":"Type Name     PinData * data Pin data (direction, IRQ level, etc.). The structure is family-specific.   uint32_t enabled Enabled pin functions. Used values are family-specific.   uint32_t gpio GPIO name in the family SDK.   uint32_t supported Supported pin functions."},{"location":"ltapi/struct_pin_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_pin_info/#variable-data","title":"variable data","text":"<pre><code>PinData* PinInfo::data;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-enabled","title":"variable enabled","text":"<pre><code>uint32_t PinInfo::enabled;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-gpio","title":"variable gpio","text":"<pre><code>uint32_t PinInfo::gpio;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-supported","title":"variable supported","text":"<pre><code>uint32_t PinInfo::supported;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_custom.h</code></p>"},{"location":"ltapi/class_request_handler/","title":"Class RequestHandler","text":"<p>ClassList &gt; RequestHandler</p> <p>Inherited by the following classes: FunctionRequestHandler,  StaticRequestHandler</p>"},{"location":"ltapi/class_request_handler/#public-functions","title":"Public Functions","text":"Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool RequestHandler::canHandle (\n    HTTPMethod method,\n    String uri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-canupload","title":"function canUpload","text":"<pre><code>inline virtual bool RequestHandler::canUpload (\n    String uri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool RequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-next-12","title":"function next [1/2]","text":"<pre><code>inline RequestHandler * RequestHandler::next () \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-next-22","title":"function next [2/2]","text":"<pre><code>inline void RequestHandler::next (\n    RequestHandler * r\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-patharg","title":"function pathArg","text":"<pre><code>inline const String &amp; RequestHandler::pathArg (\n    unsigned int i\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-upload","title":"function upload","text":"<pre><code>inline virtual void RequestHandler::upload (\n    WebServer &amp; server,\n    String requestUri,\n    HTTPUpload &amp; upload\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-requesthandler","title":"function ~RequestHandler","text":"<pre><code>inline virtual RequestHandler::~RequestHandler () \n</code></pre>"},{"location":"ltapi/class_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_request_handler/#variable-pathargs","title":"variable pathArgs","text":"<pre><code>std::vector&lt;String&gt; RequestHandler::pathArgs;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/RequestHandler.h</code></p>"},{"location":"ltapi/class_serial_class/","title":"Class SerialClass","text":"<p>ClassList &gt; SerialClass</p> <p>Inherits the following classes: HardwareSerial</p>"},{"location":"ltapi/class_serial_class/#public-attributes","title":"Public Attributes","text":"Type Name     void * data"},{"location":"ltapi/class_serial_class/#public-functions","title":"Public Functions","text":"Type Name      SerialClass (uint32_t port, pin_size_t rx=PIN_INVALID, pin_size_t tx=PIN_INVALID)    int available ()    void begin (unsigned long baudrate)    void begin (unsigned long baudrate, uint16_t config)    void configure (unsigned long baudrate)    void configure (unsigned long baudrate, uint16_t config)    void end ()    void flush ()     operator bool ()    int peek ()    int read ()    size_t write (uint8_t c)"},{"location":"ltapi/class_serial_class/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/class_serial_class/#variable-data","title":"variable data","text":"<pre><code>void* SerialClass::data;\n</code></pre>"},{"location":"ltapi/class_serial_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_serial_class/#function-serialclass","title":"function SerialClass","text":"<pre><code>SerialClass::SerialClass (\n    uint32_t port,\n    pin_size_t rx=PIN_INVALID,\n    pin_size_t tx=PIN_INVALID\n) \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-available","title":"function available","text":"<pre><code>int SerialClass::available () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>inline void SerialClass::begin (\n    unsigned long baudrate\n) \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>void SerialClass::begin (\n    unsigned long baudrate,\n    uint16_t config\n) \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-configure-12","title":"function configure [1/2]","text":"<pre><code>inline void SerialClass::configure (\n    unsigned long baudrate\n) \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-configure-22","title":"function configure [2/2]","text":"<pre><code>void SerialClass::configure (\n    unsigned long baudrate,\n    uint16_t config\n) \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-end","title":"function end","text":"<pre><code>void SerialClass::end () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-flush","title":"function flush","text":"<pre><code>void SerialClass::flush () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline SerialClass::operator bool () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-peek","title":"function peek","text":"<pre><code>int SerialClass::peek () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-read","title":"function read","text":"<pre><code>int SerialClass::read () \n</code></pre>"},{"location":"ltapi/class_serial_class/#function-write","title":"function write","text":"<pre><code>size_t SerialClass::write (\n    uint8_t c\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/Serial/Serial.h</code></p>"},{"location":"ltapi/struct_soft_data/","title":"Struct SoftData","text":"<p>ClassList &gt; SoftData</p>"},{"location":"ltapi/struct_soft_data/#public-attributes","title":"Public Attributes","text":"Type Name     SerialRingBuffer * buf    uint8_t byte    void * param    pin_size_t pin    SoftState state"},{"location":"ltapi/struct_soft_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_soft_data/#variable-buf","title":"variable buf","text":"<pre><code>SerialRingBuffer* SoftData::buf;\n</code></pre>"},{"location":"ltapi/struct_soft_data/#variable-byte","title":"variable byte","text":"<pre><code>uint8_t SoftData::byte;\n</code></pre>"},{"location":"ltapi/struct_soft_data/#variable-param","title":"variable param","text":"<pre><code>void* SoftData::param;\n</code></pre>"},{"location":"ltapi/struct_soft_data/#variable-pin","title":"variable pin","text":"<pre><code>pin_size_t SoftData::pin;\n</code></pre>"},{"location":"ltapi/struct_soft_data/#variable-state","title":"variable state","text":"<pre><code>SoftState SoftData::state;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/SoftwareSerial.h</code></p>"},{"location":"ltapi/struct_soft_serial/","title":"Struct SoftSerial","text":"<p>ClassList &gt; SoftSerial</p>"},{"location":"ltapi/struct_soft_serial/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t invert    void * param    SoftData rx    SoftData tx"},{"location":"ltapi/struct_soft_serial/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_soft_serial/#variable-invert","title":"variable invert","text":"<pre><code>uint8_t SoftSerial::invert;\n</code></pre>"},{"location":"ltapi/struct_soft_serial/#variable-param","title":"variable param","text":"<pre><code>void* SoftSerial::param;\n</code></pre>"},{"location":"ltapi/struct_soft_serial/#variable-rx","title":"variable rx","text":"<pre><code>SoftData SoftSerial::rx;\n</code></pre>"},{"location":"ltapi/struct_soft_serial/#variable-tx","title":"variable tx","text":"<pre><code>SoftData SoftSerial::tx;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/SoftwareSerial.h</code></p>"},{"location":"ltapi/class_software_serial/","title":"Class SoftwareSerial","text":"<p>ClassList &gt; SoftwareSerial</p> <p>Inherits the following classes: HardwareSerial</p>"},{"location":"ltapi/class_software_serial/#public-functions","title":"Public Functions","text":"Type Name      SoftwareSerial (pin_size_t receivePin, pin_size_t transmitPin, bool inverted=false)    int available ()    void begin (unsigned long baudrate)    void begin (unsigned long baudrate, uint16_t config)    void end ()    void flush ()     operator bool ()    int peek ()    int read ()    size_t write (uint8_t c)"},{"location":"ltapi/class_software_serial/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_software_serial/#function-softwareserial","title":"function SoftwareSerial","text":"<pre><code>SoftwareSerial::SoftwareSerial (\n    pin_size_t receivePin,\n    pin_size_t transmitPin,\n    bool inverted=false\n) \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-available","title":"function available","text":"<pre><code>int SoftwareSerial::available () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>inline void SoftwareSerial::begin (\n    unsigned long baudrate\n) \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>void SoftwareSerial::begin (\n    unsigned long baudrate,\n    uint16_t config\n) \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-end","title":"function end","text":"<pre><code>void SoftwareSerial::end () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-flush","title":"function flush","text":"<pre><code>void SoftwareSerial::flush () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline SoftwareSerial::operator bool () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-peek","title":"function peek","text":"<pre><code>int SoftwareSerial::peek () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-read","title":"function read","text":"<pre><code>int SoftwareSerial::read () \n</code></pre>"},{"location":"ltapi/class_software_serial/#function-write","title":"function write","text":"<pre><code>size_t SoftwareSerial::write (\n    uint8_t c\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/SoftwareSerial.h</code></p>"},{"location":"ltapi/class_static_request_handler/","title":"Class StaticRequestHandler","text":"<p>ClassList &gt; StaticRequestHandler</p> <p>Inherits the following classes: RequestHandler</p>"},{"location":"ltapi/class_static_request_handler/#public-functions","title":"Public Functions","text":"Type Name      StaticRequestHandler (FS &amp; fs, const char * path, const char * uri, const char * cache_header)    virtual bool canHandle (HTTPMethod requestMethod, String requestUri) override   virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri) override"},{"location":"ltapi/class_static_request_handler/#public-functions-inherited-from-requesthandler","title":"Public Functions inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_static_request_handler/#public-static-functions","title":"Public Static Functions","text":"Type Name     String getContentType (const String &amp; path)"},{"location":"ltapi/class_static_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     size_t _baseUriLength    String _cache_header    FS _fs    bool _isFile    String _path    String _uri"},{"location":"ltapi/class_static_request_handler/#protected-attributes-inherited-from-requesthandler","title":"Protected Attributes inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_static_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_static_request_handler/#function-staticrequesthandler","title":"function StaticRequestHandler","text":"<pre><code>inline StaticRequestHandler::StaticRequestHandler (\n    FS &amp; fs,\n    const char * path,\n    const char * uri,\n    const char * cache_header\n) \n</code></pre>"},{"location":"ltapi/class_static_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool StaticRequestHandler::canHandle (\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canHandle</p>"},{"location":"ltapi/class_static_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool StaticRequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::handle</p>"},{"location":"ltapi/class_static_request_handler/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_static_request_handler/#function-getcontenttype","title":"function getContentType","text":"<pre><code>static inline String StaticRequestHandler::getContentType (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/class_static_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_static_request_handler/#variable-_baseurilength","title":"variable _baseUriLength","text":"<pre><code>size_t StaticRequestHandler::_baseUriLength;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_cache_header","title":"variable _cache_header","text":"<pre><code>String StaticRequestHandler::_cache_header;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_fs","title":"variable _fs","text":"<pre><code>FS StaticRequestHandler::_fs;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_isfile","title":"variable _isFile","text":"<pre><code>bool StaticRequestHandler::_isFile;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_path","title":"variable _path","text":"<pre><code>String StaticRequestHandler::_path;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_uri","title":"variable _uri","text":"<pre><code>String StaticRequestHandler::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/class_stream_string/","title":"Class StreamString","text":"<p>ClassList &gt; StreamString</p> <p>More...</p> <ul> <li><code>#include &lt;StreamString.h&gt;</code></li> </ul> <p>Inherits the following classes: Stream,  String</p>"},{"location":"ltapi/class_stream_string/#public-functions","title":"Public Functions","text":"Type Name     int available () override   void flush () override   int peek () override   int read () override   size_t write (const uint8_t * buffer, size_t size) override   size_t write (uint8_t data) override"},{"location":"ltapi/class_stream_string/#detailed-description","title":"Detailed Description","text":"<p>StreamString.h</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/class_stream_string/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_stream_string/#function-available","title":"function available","text":"<pre><code>int StreamString::available () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-flush","title":"function flush","text":"<pre><code>void StreamString::flush () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-peek","title":"function peek","text":"<pre><code>int StreamString::peek () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-read","title":"function read","text":"<pre><code>int StreamString::read () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t StreamString::write (\n    const uint8_t * buffer,\n    size_t size\n) override\n</code></pre> <p>StreamString.cpp</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the esp8266 core for Arduino environment.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/class_stream_string/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t StreamString::write (\n    uint8_t data\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/StreamString/StreamString.h</code></p>"},{"location":"ltapi/class_update_class/","title":"Class UpdateClass","text":"<p>ClassList &gt; UpdateClass</p>"},{"location":"ltapi/class_update_class/#public-types","title":"Public Types","text":"Type Name     typedef std::function&lt; void(size_t, size_t)&gt; THandlerFunction_Progress"},{"location":"ltapi/class_update_class/#public-functions","title":"Public Functions","text":"Type Name     void abort () Same as end() .   bool begin (size_t size=UPDATE_SIZE_UNKNOWN, int command=U_FLASH, int ledPin=-1, uint8_t ledOn=LOW, const char * label=nullptr) Initialize the update process.   void clearError () Clear all errors. This is NOT recommended.   bool end (bool evenIfRemaining=false) Finalize the update process. Check for errors and update completion, then activate the new firmware image.   const char * errorString () constGet a textual description of the error.   const char * getBoardName () Get target board name from UF2 info.   UpdateError getError () constGet Arduino error code of the update.   uint16_t getErrorCode () constGet combined error code of the update.   const char * getFirmwareName () Get firmware name from UF2 info.   const char * getFirmwareVersion () Get firmware version from UF2 info.   const char * getLibreTinyVersion () Get LibreTiny version from UF2 info.   uf2_err_t getUF2Error () constGet UF2OTA error code of the update.   bool hasError () constCheck if any error has occurred (incl. aborting the update).   bool isFinished () Check if the update process hasn't been started or has been completed.   bool isRunning () Check if the update process has been started.   void md5 (uint8_t * result) Get calculated MD5 digest of the firmware.   String md5String () Return a hexadecimal string of calculated firmware MD5 sum.   UpdateClass &amp; onProgress (THandlerFunction_Progress handler) Set the callback invoked after writing data to flash.   void printError (Print &amp; out) constPrint string error info to the stream.   size_t progress () Return amount of bytes already written.   size_t remaining () Return amount of bytes remaining to write.   bool setMD5 (const char * md5) Set the expected MD5 of the firmware (hexadecimal string).   size_t size () Return complete update image size.   size_t write (const uint8_t * data, size_t len) Write a chunk of data to the buffer or flash memory.   size_t writeStream (Stream &amp; data) Write all data remaining in the given stream."},{"location":"ltapi/class_update_class/#public-static-functions","title":"Public Static Functions","text":"Type Name     bool canRollBack () Check if OTA rollback is possible (switching the stored index to another partition).   bool rollBack () Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid."},{"location":"ltapi/class_update_class/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/class_update_class/#typedef-thandlerfunction_progress","title":"typedef THandlerFunction_Progress","text":"<pre><code>typedef std::function&lt;void(size_t, size_t)&gt; UpdateClass::THandlerFunction_Progress;\n</code></pre>"},{"location":"ltapi/class_update_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_update_class/#function-abort","title":"function abort","text":"<pre><code>inline void UpdateClass::abort () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-begin","title":"function begin","text":"<p>Initialize the update process. <pre><code>bool UpdateClass::begin (\n    size_t size=UPDATE_SIZE_UNKNOWN,\n    int command=U_FLASH,\n    int ledPin=-1,\n    uint8_t ledOn=LOW,\n    const char * label=nullptr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> total UF2 file size </li> <li><code>command</code> must be U_FLASH </li> </ul> <p>Returns:</p> <p>false if parameters are invalid or update is running, true otherwise </p>"},{"location":"ltapi/class_update_class/#function-clearerror","title":"function clearError","text":"<pre><code>void UpdateClass::clearError () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-end","title":"function end","text":"<p>Finalize the update process. Check for errors and update completion, then activate the new firmware image. <pre><code>bool UpdateClass::end (\n    bool evenIfRemaining=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>evenIfRemaining</code> don't raise errors if still in progress </li> </ul> <p>Returns:</p> <p>false in case of errors or no update running; true otherwise </p>"},{"location":"ltapi/class_update_class/#function-errorstring","title":"function errorString","text":"<pre><code>const char * UpdateClass::errorString () const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-getboardname","title":"function getBoardName","text":"<pre><code>inline const char * UpdateClass::getBoardName () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-geterror","title":"function getError","text":"<pre><code>inline UpdateError UpdateClass::getError () const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-geterrorcode","title":"function getErrorCode","text":"<pre><code>uint16_t UpdateClass::getErrorCode () const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-getfirmwarename","title":"function getFirmwareName","text":"<pre><code>inline const char * UpdateClass::getFirmwareName () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getfirmwareversion","title":"function getFirmwareVersion","text":"<pre><code>inline const char * UpdateClass::getFirmwareVersion () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getlibretinyversion","title":"function getLibreTinyVersion","text":"<pre><code>inline const char * UpdateClass::getLibreTinyVersion () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getuf2error","title":"function getUF2Error","text":"<pre><code>inline uf2_err_t UpdateClass::getUF2Error () const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-haserror","title":"function hasError","text":"<pre><code>bool UpdateClass::hasError () const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-isfinished","title":"function isFinished","text":"<pre><code>inline bool UpdateClass::isFinished () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-isrunning","title":"function isRunning","text":"<pre><code>inline bool UpdateClass::isRunning () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-md5","title":"function md5","text":"<pre><code>void UpdateClass::md5 (\n    uint8_t * result\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-md5string","title":"function md5String","text":"<pre><code>String UpdateClass::md5String () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-onprogress","title":"function onProgress","text":"<pre><code>UpdateClass &amp; UpdateClass::onProgress (\n    THandlerFunction_Progress handler\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-printerror","title":"function printError","text":"<pre><code>void UpdateClass::printError (\n    Print &amp; out\n) const\n</code></pre>"},{"location":"ltapi/class_update_class/#function-progress","title":"function progress","text":"<pre><code>inline size_t UpdateClass::progress () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-remaining","title":"function remaining","text":"<pre><code>inline size_t UpdateClass::remaining () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-setmd5","title":"function setMD5","text":"<pre><code>bool UpdateClass::setMD5 (\n    const char * md5\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-size","title":"function size","text":"<pre><code>inline size_t UpdateClass::size () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-write","title":"function write","text":"<p>Write a chunk of data to the buffer or flash memory. <pre><code>size_t UpdateClass::write (\n    const uint8_t * data,\n    size_t len\n) \n</code></pre></p> <p>It's advised to write in 512-byte chunks (or its multiples).</p> <p>Parameters:</p> <ul> <li><code>data</code> chunk of data </li> <li><code>len</code> length of the chunk </li> </ul> <p>Returns:</p> <p>size_t amount of bytes written </p>"},{"location":"ltapi/class_update_class/#function-writestream","title":"function writeStream","text":"<p>Write all data remaining in the given stream. <pre><code>size_t UpdateClass::writeStream (\n    Stream &amp; data\n) \n</code></pre></p> <p>If the stream doesn't produce any data within UPDATE_TIMEOUT_MS, the update process will be aborted.</p> <p>Parameters:</p> <ul> <li><code>data</code> stream to read from </li> </ul> <p>Returns:</p> <p>size_t amount of bytes written </p>"},{"location":"ltapi/class_update_class/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_update_class/#function-canrollback","title":"function canRollBack","text":"<p>Check if OTA rollback is possible (switching the stored index to another partition). <pre><code>static bool UpdateClass::canRollBack () \n</code></pre></p> <p>Note that this is not the same as \"switching\" OTA with revert=true.</p> <p>Returns:</p> <p>true if 2nd image is valid and the chip is dual-OTA; false otherwise </p>"},{"location":"ltapi/class_update_class/#function-rollback","title":"function rollBack","text":"<p>Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid. <pre><code>static bool UpdateClass::rollBack () \n</code></pre></p> <p>This can be used to \"activate\" the upgrade after flashing.</p> <p>Parameters:</p> <ul> <li><code>revert</code> switch if (and only if) the other image is already marked as active (i.e. switch back to the running image) </li> </ul> <p>Returns:</p> <p>false if the second image (or upgrade image) is not valid; false if writing failed; true otherwise </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Update/Update.h</code></p>"},{"location":"ltapi/class_uri/","title":"Class Uri","text":"<p>ClassList &gt; Uri</p> <p>Inherited by the following classes: UriBraces,  UriGlob,  UriRegex</p>"},{"location":"ltapi/class_uri/#public-functions","title":"Public Functions","text":"Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri/#protected-attributes","title":"Protected Attributes","text":"Type Name     const String _uri"},{"location":"ltapi/class_uri/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri/#function-uri-13","title":"function Uri [1/3]","text":"<pre><code>inline Uri::Uri (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri-23","title":"function Uri [2/3]","text":"<pre><code>inline Uri::Uri (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri-33","title":"function Uri [3/3]","text":"<pre><code>inline Uri::Uri (\n    const __FlashStringHelper * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool Uri::canHandle (\n    const String &amp; requestUri,\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * Uri::clone () const\n</code></pre>"},{"location":"ltapi/class_uri/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline virtual void Uri::initPathArgs (\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri","title":"function ~Uri","text":"<pre><code>inline virtual Uri::~Uri () \n</code></pre>"},{"location":"ltapi/class_uri/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_uri/#variable-_uri","title":"variable _uri","text":"<pre><code>const String Uri::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/Uri.h</code></p>"},{"location":"ltapi/class_uri_braces/","title":"Class UriBraces","text":"<p>ClassList &gt; UriBraces</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_braces/#public-functions","title":"Public Functions","text":"Type Name      UriBraces (const char * uri)     UriBraces (const String &amp; uri)    bool canHandle (const String &amp; requestUri, std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const   void initPathArgs (std::vector&lt; String &gt; &amp; pathArgs) override"},{"location":"ltapi/class_uri_braces/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_braces/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_braces/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_braces/#function-uribraces-12","title":"function UriBraces [1/2]","text":"<pre><code>inline explicit UriBraces::UriBraces (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-uribraces-22","title":"function UriBraces [2/2]","text":"<pre><code>inline explicit UriBraces::UriBraces (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-canhandle","title":"function canHandle","text":"<pre><code>inline bool UriBraces::canHandle (\n    const String &amp; requestUri,\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriBraces::clone () override const\n</code></pre> <p>Implements Uri::clone</p>"},{"location":"ltapi/class_uri_braces/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline void UriBraces::initPathArgs (\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriBraces.h</code></p>"},{"location":"ltapi/class_uri_glob/","title":"Class UriGlob","text":"<p>ClassList &gt; UriGlob</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_glob/#public-functions","title":"Public Functions","text":"Type Name      UriGlob (const char * uri)     UriGlob (const String &amp; uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const"},{"location":"ltapi/class_uri_glob/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_glob/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_glob/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_glob/#function-uriglob-12","title":"function UriGlob [1/2]","text":"<pre><code>inline explicit UriGlob::UriGlob (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_glob/#function-uriglob-22","title":"function UriGlob [2/2]","text":"<pre><code>inline explicit UriGlob::UriGlob (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_glob/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool UriGlob::canHandle (\n    const String &amp; requestUri,\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre> <p>Implements Uri::canHandle</p>"},{"location":"ltapi/class_uri_glob/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriGlob::clone () override const\n</code></pre> <p>Implements Uri::clone</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriGlob.h</code></p>"},{"location":"ltapi/class_uri_regex/","title":"Class UriRegex","text":"<p>ClassList &gt; UriRegex</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_regex/#public-functions","title":"Public Functions","text":"Type Name      UriRegex (const char * uri)     UriRegex (const String &amp; uri)    bool canHandle (const String &amp; requestUri, std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const   void initPathArgs (std::vector&lt; String &gt; &amp; pathArgs) override"},{"location":"ltapi/class_uri_regex/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_regex/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_regex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_regex/#function-uriregex-12","title":"function UriRegex [1/2]","text":"<pre><code>inline explicit UriRegex::UriRegex (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-uriregex-22","title":"function UriRegex [2/2]","text":"<pre><code>inline explicit UriRegex::UriRegex (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-canhandle","title":"function canHandle","text":"<pre><code>inline bool UriRegex::canHandle (\n    const String &amp; requestUri,\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriRegex::clone () override const\n</code></pre> <p>Implements Uri::clone</p>"},{"location":"ltapi/class_uri_regex/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline void UriRegex::initPathArgs (\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriRegex.h</code></p>"},{"location":"ltapi/class_web_server/","title":"Class WebServer","text":"<p>ClassList &gt; WebServer</p>"},{"location":"ltapi/class_web_server/#public-types","title":"Public Types","text":"Type Name     typedef std::function&lt; void(void)&gt; THandlerFunction"},{"location":"ltapi/class_web_server/#public-functions","title":"Public Functions","text":"Type Name      WebServer (IPAddress addr, int port=80)     WebServer (int port=80)    void addHandler (RequestHandler * handler)    String arg (String name)    String arg (int i)    String argName (int i)    int args ()    bool authenticate (const char * username, const char * password)    virtual void begin ()    virtual void begin (uint16_t port)    virtual WiFiClient client ()    virtual void close ()    void collectHeaders (const char * headerKeys, const size_t headerKeysCount)    void enableCORS (boolean value=true)    void enableCrossOrigin (boolean value=true)    void enableDelay (boolean value)    virtual void handleClient ()    bool hasArg (String name)    bool hasHeader (String name)    String header (String name)    String header (int i)    String headerName (int i)    int headers ()    String hostHeader ()    HTTPMethod method ()    void on (const Uri &amp; uri, THandlerFunction fn)    void on (const Uri &amp; uri, HTTPMethod method, THandlerFunction fn)    void on (const Uri &amp; uri, HTTPMethod method, THandlerFunction fn, THandlerFunction ufn)    void onFileUpload (THandlerFunction ufn)    void onNotFound (THandlerFunction fn)    String pathArg (unsigned int i)    void requestAuthentication (HTTPAuthMethod mode=BASIC_AUTH, const char * realm=NULL, const String &amp; authFailMsg=String(\"\"))    void send (int code, const char * content_type=NULL, const String &amp; content=String(\"\"))    void send (int code, char * content_type, const String &amp; content)    void send (int code, const String &amp; content_type, const String &amp; content)    void sendContent (const String &amp; content)    void sendContent (const char * content, size_t contentLength)    void sendContent_P (PGM_P content)    void sendContent_P (PGM_P content, size_t size)    void sendHeader (const String &amp; name, const String &amp; value, bool first=false)    void send_P (int code, PGM_P content_type, PGM_P content)    void send_P (int code, PGM_P content_type, PGM_P content, size_t contentLength)    void serveStatic (const char * uri, fs::FS &amp; fs, const char * path, const char * cache_header=NULL)    void setContentLength (const size_t contentLength)    void stop ()    size_t streamFile (T &amp; file, const String &amp; contentType)    HTTPUpload &amp; upload ()    String uri ()    virtual ~WebServer ()"},{"location":"ltapi/class_web_server/#public-static-functions","title":"Public Static Functions","text":"Type Name     String urlDecode (const String &amp; text)"},{"location":"ltapi/class_web_server/#protected-attributes","title":"Protected Attributes","text":"Type Name     bool _chunked    size_t _contentLength    boolean _corsEnabled    int _currentArgCount    RequestArgument * _currentArgs    WiFiClient _currentClient    RequestHandler * _currentHandler    RequestArgument * _currentHeaders    HTTPMethod _currentMethod    HTTPClientStatus _currentStatus    std::unique_ptr&lt; HTTPUpload &gt; _currentUpload    String _currentUri    uint8_t _currentVersion    THandlerFunction _fileUploadHandler    RequestHandler * _firstHandler    int _headerKeysCount    String _hostHeader    RequestHandler * _lastHandler    THandlerFunction _notFoundHandler    boolean _nullDelay    RequestArgument * _postArgs    int _postArgsLen    String _responseHeaders    WiFiServer _server    String _snonce    String _sopaque    String _srealm    unsigned long _statusChange"},{"location":"ltapi/class_web_server/#protected-functions","title":"Protected Functions","text":"Type Name     void _addRequestHandler (RequestHandler * handler)    bool _collectHeader (const char * headerName, const char * headerValue)    virtual size_t _currentClientWrite (const char * b, size_t l)    virtual size_t _currentClientWrite_P (PGM_P b, size_t l)    String _extractParam (String &amp; authReq, const String &amp; param, const char delimit='\"')    void _finalizeResponse ()    String _getRandomHexString ()    void _handleRequest ()    void _parseArguments (String data)    bool _parseForm (WiFiClient &amp; client, String boundary, uint32_t len)    bool _parseFormUploadAborted ()    bool _parseRequest (WiFiClient &amp; client)    void _prepareHeader (String &amp; response, int code, const char * content_type, size_t contentLength)    void _streamFileCore (const size_t fileSize, const String &amp; fileName, const String &amp; contentType)    int _uploadReadByte (WiFiClient &amp; client)    void _uploadWriteByte (uint8_t b)"},{"location":"ltapi/class_web_server/#protected-static-functions","title":"Protected Static Functions","text":"Type Name     String _responseCodeToString (int code)"},{"location":"ltapi/class_web_server/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/class_web_server/#typedef-thandlerfunction","title":"typedef THandlerFunction","text":"<pre><code>typedef std::function&lt;void(void)&gt; WebServer::THandlerFunction;\n</code></pre>"},{"location":"ltapi/class_web_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-webserver-12","title":"function WebServer [1/2]","text":"<pre><code>WebServer::WebServer (\n    IPAddress addr,\n    int port=80\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-webserver-22","title":"function WebServer [2/2]","text":"<pre><code>WebServer::WebServer (\n    int port=80\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-addhandler","title":"function addHandler","text":"<pre><code>void WebServer::addHandler (\n    RequestHandler * handler\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-arg-12","title":"function arg [1/2]","text":"<pre><code>String WebServer::arg (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-arg-22","title":"function arg [2/2]","text":"<pre><code>String WebServer::arg (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-argname","title":"function argName","text":"<pre><code>String WebServer::argName (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-args","title":"function args","text":"<pre><code>int WebServer::args () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-authenticate","title":"function authenticate","text":"<pre><code>bool WebServer::authenticate (\n    const char * username,\n    const char * password\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual void WebServer::begin () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual void WebServer::begin (\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-client","title":"function client","text":"<pre><code>inline virtual WiFiClient WebServer::client () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-close","title":"function close","text":"<pre><code>virtual void WebServer::close () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-collectheaders","title":"function collectHeaders","text":"<pre><code>void WebServer::collectHeaders (\n    const char * headerKeys,\n    const size_t headerKeysCount\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enablecors","title":"function enableCORS","text":"<pre><code>void WebServer::enableCORS (\n    boolean value=true\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enablecrossorigin","title":"function enableCrossOrigin","text":"<pre><code>void WebServer::enableCrossOrigin (\n    boolean value=true\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enabledelay","title":"function enableDelay","text":"<pre><code>void WebServer::enableDelay (\n    boolean value\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-handleclient","title":"function handleClient","text":"<pre><code>virtual void WebServer::handleClient () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hasarg","title":"function hasArg","text":"<pre><code>bool WebServer::hasArg (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hasheader","title":"function hasHeader","text":"<pre><code>bool WebServer::hasHeader (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-header-12","title":"function header [1/2]","text":"<pre><code>String WebServer::header (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-header-22","title":"function header [2/2]","text":"<pre><code>String WebServer::header (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-headername","title":"function headerName","text":"<pre><code>String WebServer::headerName (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-headers","title":"function headers","text":"<pre><code>int WebServer::headers () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hostheader","title":"function hostHeader","text":"<pre><code>String WebServer::hostHeader () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-method","title":"function method","text":"<pre><code>inline HTTPMethod WebServer::method () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-13","title":"function on [1/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-23","title":"function on [2/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    HTTPMethod method,\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-33","title":"function on [3/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    HTTPMethod method,\n    THandlerFunction fn,\n    THandlerFunction ufn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-onfileupload","title":"function onFileUpload","text":"<pre><code>void WebServer::onFileUpload (\n    THandlerFunction ufn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-onnotfound","title":"function onNotFound","text":"<pre><code>void WebServer::onNotFound (\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-patharg","title":"function pathArg","text":"<pre><code>String WebServer::pathArg (\n    unsigned int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-requestauthentication","title":"function requestAuthentication","text":"<pre><code>void WebServer::requestAuthentication (\n    HTTPAuthMethod mode=BASIC_AUTH,\n    const char * realm=NULL,\n    const String &amp; authFailMsg=String(\"\")\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-13","title":"function send [1/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    const char * content_type=NULL,\n    const String &amp; content=String(\"\")\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-23","title":"function send [2/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    char * content_type,\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-33","title":"function send [3/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    const String &amp; content_type,\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent-12","title":"function sendContent [1/2]","text":"<pre><code>void WebServer::sendContent (\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent-22","title":"function sendContent [2/2]","text":"<pre><code>void WebServer::sendContent (\n    const char * content,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent_p-12","title":"function sendContent_P [1/2]","text":"<pre><code>void WebServer::sendContent_P (\n    PGM_P content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent_p-22","title":"function sendContent_P [2/2]","text":"<pre><code>void WebServer::sendContent_P (\n    PGM_P content,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendheader","title":"function sendHeader","text":"<pre><code>void WebServer::sendHeader (\n    const String &amp; name,\n    const String &amp; value,\n    bool first=false\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send_p-12","title":"function send_P [1/2]","text":"<pre><code>void WebServer::send_P (\n    int code,\n    PGM_P content_type,\n    PGM_P content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send_p-22","title":"function send_P [2/2]","text":"<pre><code>void WebServer::send_P (\n    int code,\n    PGM_P content_type,\n    PGM_P content,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-servestatic","title":"function serveStatic","text":"<pre><code>void WebServer::serveStatic (\n    const char * uri,\n    fs::FS &amp; fs,\n    const char * path,\n    const char * cache_header=NULL\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-setcontentlength","title":"function setContentLength","text":"<pre><code>void WebServer::setContentLength (\n    const size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-stop","title":"function stop","text":"<pre><code>void WebServer::stop () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-streamfile","title":"function streamFile","text":"<pre><code>template&lt;typename T typename T&gt;\ninline size_t WebServer::streamFile (\n    T &amp; file,\n    const String &amp; contentType\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-upload","title":"function upload","text":"<pre><code>inline HTTPUpload &amp; WebServer::upload () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-uri","title":"function uri","text":"<pre><code>inline String WebServer::uri () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-webserver","title":"function ~WebServer","text":"<pre><code>virtual WebServer::~WebServer () \n</code></pre>"},{"location":"ltapi/class_web_server/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-urldecode","title":"function urlDecode","text":"<pre><code>static String WebServer::urlDecode (\n    const String &amp; text\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_web_server/#variable-_chunked","title":"variable _chunked","text":"<pre><code>bool WebServer::_chunked;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_contentlength","title":"variable _contentLength","text":"<pre><code>size_t WebServer::_contentLength;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_corsenabled","title":"variable _corsEnabled","text":"<pre><code>boolean WebServer::_corsEnabled;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentargcount","title":"variable _currentArgCount","text":"<pre><code>int WebServer::_currentArgCount;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentargs","title":"variable _currentArgs","text":"<pre><code>RequestArgument* WebServer::_currentArgs;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentclient","title":"variable _currentClient","text":"<pre><code>WiFiClient WebServer::_currentClient;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currenthandler","title":"variable _currentHandler","text":"<pre><code>RequestHandler* WebServer::_currentHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentheaders","title":"variable _currentHeaders","text":"<pre><code>RequestArgument* WebServer::_currentHeaders;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentmethod","title":"variable _currentMethod","text":"<pre><code>HTTPMethod WebServer::_currentMethod;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentstatus","title":"variable _currentStatus","text":"<pre><code>HTTPClientStatus WebServer::_currentStatus;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentupload","title":"variable _currentUpload","text":"<pre><code>std::unique_ptr&lt;HTTPUpload&gt; WebServer::_currentUpload;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currenturi","title":"variable _currentUri","text":"<pre><code>String WebServer::_currentUri;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentversion","title":"variable _currentVersion","text":"<pre><code>uint8_t WebServer::_currentVersion;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_fileuploadhandler","title":"variable _fileUploadHandler","text":"<pre><code>THandlerFunction WebServer::_fileUploadHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_firsthandler","title":"variable _firstHandler","text":"<pre><code>RequestHandler* WebServer::_firstHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_headerkeyscount","title":"variable _headerKeysCount","text":"<pre><code>int WebServer::_headerKeysCount;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_hostheader","title":"variable _hostHeader","text":"<pre><code>String WebServer::_hostHeader;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_lasthandler","title":"variable _lastHandler","text":"<pre><code>RequestHandler* WebServer::_lastHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_notfoundhandler","title":"variable _notFoundHandler","text":"<pre><code>THandlerFunction WebServer::_notFoundHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_nulldelay","title":"variable _nullDelay","text":"<pre><code>boolean WebServer::_nullDelay;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_postargs","title":"variable _postArgs","text":"<pre><code>RequestArgument* WebServer::_postArgs;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_postargslen","title":"variable _postArgsLen","text":"<pre><code>int WebServer::_postArgsLen;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_responseheaders","title":"variable _responseHeaders","text":"<pre><code>String WebServer::_responseHeaders;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_server","title":"variable _server","text":"<pre><code>WiFiServer WebServer::_server;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_snonce","title":"variable _snonce","text":"<pre><code>String WebServer::_snonce;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_sopaque","title":"variable _sopaque","text":"<pre><code>String WebServer::_sopaque;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_srealm","title":"variable _srealm","text":"<pre><code>String WebServer::_srealm;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_statuschange","title":"variable _statusChange","text":"<pre><code>unsigned long WebServer::_statusChange;\n</code></pre>"},{"location":"ltapi/class_web_server/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-_addrequesthandler","title":"function _addRequestHandler","text":"<pre><code>void WebServer::_addRequestHandler (\n    RequestHandler * handler\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_collectheader","title":"function _collectHeader","text":"<pre><code>bool WebServer::_collectHeader (\n    const char * headerName,\n    const char * headerValue\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_currentclientwrite","title":"function _currentClientWrite","text":"<pre><code>inline virtual size_t WebServer::_currentClientWrite (\n    const char * b,\n    size_t l\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_currentclientwrite_p","title":"function _currentClientWrite_P","text":"<pre><code>inline virtual size_t WebServer::_currentClientWrite_P (\n    PGM_P b,\n    size_t l\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_extractparam","title":"function _extractParam","text":"<pre><code>String WebServer::_extractParam (\n    String &amp; authReq,\n    const String &amp; param,\n    const char delimit='\"'\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_finalizeresponse","title":"function _finalizeResponse","text":"<pre><code>void WebServer::_finalizeResponse () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_getrandomhexstring","title":"function _getRandomHexString","text":"<pre><code>String WebServer::_getRandomHexString () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_handlerequest","title":"function _handleRequest","text":"<pre><code>void WebServer::_handleRequest () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parsearguments","title":"function _parseArguments","text":"<pre><code>void WebServer::_parseArguments (\n    String data\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parseform","title":"function _parseForm","text":"<pre><code>bool WebServer::_parseForm (\n    WiFiClient &amp; client,\n    String boundary,\n    uint32_t len\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parseformuploadaborted","title":"function _parseFormUploadAborted","text":"<pre><code>bool WebServer::_parseFormUploadAborted () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parserequest","title":"function _parseRequest","text":"<pre><code>bool WebServer::_parseRequest (\n    WiFiClient &amp; client\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_prepareheader","title":"function _prepareHeader","text":"<pre><code>void WebServer::_prepareHeader (\n    String &amp; response,\n    int code,\n    const char * content_type,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_streamfilecore","title":"function _streamFileCore","text":"<pre><code>void WebServer::_streamFileCore (\n    const size_t fileSize,\n    const String &amp; fileName,\n    const String &amp; contentType\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_uploadreadbyte","title":"function _uploadReadByte","text":"<pre><code>int WebServer::_uploadReadByte (\n    WiFiClient &amp; client\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_uploadwritebyte","title":"function _uploadWriteByte","text":"<pre><code>void WebServer::_uploadWriteByte (\n    uint8_t b\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-_responsecodetostring","title":"function _responseCodeToString","text":"<pre><code>static String WebServer::_responseCodeToString (\n    int code\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/WebServer.h</code></p>"},{"location":"ltapi/struct_web_server_1_1_request_argument/","title":"Struct WebServer::RequestArgument","text":"<p>ClassList &gt; WebServer &gt; RequestArgument</p>"},{"location":"ltapi/struct_web_server_1_1_request_argument/#public-attributes","title":"Public Attributes","text":"Type Name     String key    String value"},{"location":"ltapi/struct_web_server_1_1_request_argument/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_web_server_1_1_request_argument/#variable-key","title":"variable key","text":"<pre><code>String WebServer::RequestArgument::key;\n</code></pre>"},{"location":"ltapi/struct_web_server_1_1_request_argument/#variable-value","title":"variable value","text":"<pre><code>String WebServer::RequestArgument::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/WebServer.h</code></p>"},{"location":"ltapi/class_wi_fi_class/","title":"Class WiFiClass","text":"<p>ClassList &gt; WiFiClass</p>"},{"location":"ltapi/class_wi_fi_class/#public-attributes","title":"Public Attributes","text":"Type Name     void * data    WiFiScanData * scan   = = NULL"},{"location":"ltapi/class_wi_fi_class/#public-functions","title":"Public Functions","text":"Type Name     uint8_t * BSSID ()    uint8_t * BSSID (uint8_t networkItem)    String BSSIDstr ()    String BSSIDstr (uint8_t networkItem)    int8_t RSSI ()    int32_t RSSI (uint8_t networkItem)    const String SSID ()    String SSID (uint8_t networkItem)     WiFiClass ()    std::vector&lt; IPv6Address &gt; allLocalIPv6 ()    WiFiStatus begin (const char * ssid, const char * passphrase=NULL, int32_t channel=0, const uint8_t * bssid=NULL, bool connect=true)    WiFiStatus begin (char * ssid, char * passphrase=NULL, int32_t channel=0, const uint8_t * bssid=NULL, bool connect=true)    IPAddress broadcastIP ()    int32_t channel ()    int32_t channel (uint8_t networkItem)    bool config (IPAddress localIP, IPAddress gateway, IPAddress subnet, IPAddress dns1=(uint32_t) 0x00000000, IPAddress dns2=(uint32_t) 0x00000000)    void dataFree ()    void dataInitialize ()    bool disconnect (bool wifiOff=false)    IPAddress dnsIP (uint8_t dns_no=0)    bool enableAP (bool enable)    bool enableIpV6 ()    bool enableSTA (bool enable)    WiFiAuthMode encryptionType (uint8_t networkItem)    IPAddress gatewayIP ()    bool getAutoReconnect ()    WiFiAuthMode getEncryption ()    const char * getHostname ()    WiFiMode getMode ()    bool getNetworkInfo (uint8_t networkItem, String &amp; ssid, WiFiAuthMode &amp; encryptionType, int32_t &amp; RSSI, uint8_t *&amp; BSSID, int32_t &amp; channel)    bool getSleep ()    int getTxPower ()    int hostByName (const char * hostname, IPAddress &amp; aResult)    IPAddress hostByName (const char * hostname)    bool hostname (const String &amp; aHostname)    bool isConnected ()    IPAddress localIP ()    IPv6Address localIPv6 ()    uint8_t * macAddress (uint8_t * mac)    String macAddress ()    bool mode (WiFiMode mode)    bool modePriv (WiFiMode mode, WiFiModeAction sta, WiFiModeAction ap)    IPAddress networkID ()    uint16_t onEvent (EventCb callback, EventId eventId=ARDUINO_EVENT_MAX)    uint16_t onEvent (EventFuncCb callback, EventId eventId=ARDUINO_EVENT_MAX)    uint16_t onEvent (EventSysCb callback, EventId eventId=ARDUINO_EVENT_MAX)    void printDiag (Print &amp; dest)    const String psk ()    bool reconnect (const uint8_t * bssid=NULL)    void removeEvent (EventCb callback, EventId eventId)    void removeEvent (EventSysCb callback, EventId eventId)    void removeEvent (uint16_t id)    uint8_t scanAlloc (uint8_t count)    int16_t scanComplete ()    void scanDelete ()    void scanInit ()    int16_t scanNetworks (bool async=false, bool showHidden=false, bool passive=false, uint32_t maxMsPerChannel=300, uint8_t channel=0)    bool setAutoReconnect (bool autoReconnect)    bool setHostname (const char * hostname)    bool setMacAddress (const uint8_t * mac)    bool setSleep (bool enable)    bool setTxPower (int power)    bool softAP (const char * ssid, const char * passphrase=NULL, int channel=1, bool ssidHidden=false, int maxClients=4)    IPAddress softAPBroadcastIP ()    bool softAPConfig (IPAddress localIP, IPAddress gateway, IPAddress subnet)    IPAddress softAPIP ()    IPv6Address softAPIPv6 ()    IPAddress softAPNetworkID ()    const String softAPSSID (void)    uint8_t softAPSubnetCIDR ()    IPAddress softAPSubnetMask ()    bool softAPdisconnect (bool wifiOff=false)    bool softAPenableIpV6 ()    const char * softAPgetHostname ()    uint8_t softAPgetStationNum ()    uint8_t * softAPmacAddress (uint8_t * mac)    String softAPmacAddress (void)    bool softAPsetHostname (const char * hostname)    WiFiStatus status ()    uint8_t subnetCIDR ()    IPAddress subnetMask ()    bool validate (const char * ssid, const char * passphrase)    WiFiStatus waitForConnectResult (unsigned long timeout)     ~WiFiClass ()"},{"location":"ltapi/class_wi_fi_class/#public-static-functions","title":"Public Static Functions","text":"Type Name     IPAddress calculateBroadcast (IPAddress ip, IPAddress subnet)    IPAddress calculateNetworkID (IPAddress ip, IPAddress subnet)    uint8_t calculateSubnetCIDR (IPAddress subnetMask)    String macToString (uint8_t * mac)    void postEvent (EventId eventId, EventInfo eventInfo)    void resetNetworkInfo (WiFiNetworkInfo &amp; info)"},{"location":"ltapi/class_wi_fi_class/#protected-static-attributes","title":"Protected Static Attributes","text":"Type Name     std::vector&lt; EventHandler &gt; handlers"},{"location":"ltapi/class_wi_fi_class/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#variable-data","title":"variable data","text":"<pre><code>void* WiFiClass::data;\n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#variable-scan","title":"variable scan","text":"<pre><code>WiFiScanData* WiFiClass::scan;\n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#function-bssid-12","title":"function BSSID [1/2]","text":"<pre><code>uint8_t * WiFiClass::BSSID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssid-22","title":"function BSSID [2/2]","text":"<pre><code>uint8_t * WiFiClass::BSSID (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssidstr-12","title":"function BSSIDstr [1/2]","text":"<pre><code>String WiFiClass::BSSIDstr () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssidstr-22","title":"function BSSIDstr [2/2]","text":"<pre><code>String WiFiClass::BSSIDstr (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-rssi-12","title":"function RSSI [1/2]","text":"<pre><code>int8_t WiFiClass::RSSI () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-rssi-22","title":"function RSSI [2/2]","text":"<pre><code>int32_t WiFiClass::RSSI (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-ssid-12","title":"function SSID [1/2]","text":"<pre><code>const String WiFiClass::SSID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-ssid-22","title":"function SSID [2/2]","text":"<pre><code>String WiFiClass::SSID (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-wificlass","title":"function WiFiClass","text":"<pre><code>WiFiClass::WiFiClass () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-alllocalipv6","title":"function allLocalIPv6","text":"<pre><code>std::vector&lt; IPv6Address &gt; WiFiClass::allLocalIPv6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>WiFiStatus WiFiClass::begin (\n    const char * ssid,\n    const char * passphrase=NULL,\n    int32_t channel=0,\n    const uint8_t * bssid=NULL,\n    bool connect=true\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>WiFiStatus WiFiClass::begin (\n    char * ssid,\n    char * passphrase=NULL,\n    int32_t channel=0,\n    const uint8_t * bssid=NULL,\n    bool connect=true\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-broadcastip","title":"function broadcastIP","text":"<pre><code>IPAddress WiFiClass::broadcastIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-channel-12","title":"function channel [1/2]","text":"<pre><code>int32_t WiFiClass::channel () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-channel-22","title":"function channel [2/2]","text":"<pre><code>int32_t WiFiClass::channel (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-config","title":"function config","text":"<pre><code>bool WiFiClass::config (\n    IPAddress localIP,\n    IPAddress gateway,\n    IPAddress subnet,\n    IPAddress dns1=(uint32_t) 0x00000000,\n    IPAddress dns2=(uint32_t) 0x00000000\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-datafree","title":"function dataFree","text":"<pre><code>void WiFiClass::dataFree () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-datainitialize","title":"function dataInitialize","text":"<pre><code>void WiFiClass::dataInitialize () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-disconnect","title":"function disconnect","text":"<pre><code>bool WiFiClass::disconnect (\n    bool wifiOff=false\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-dnsip","title":"function dnsIP","text":"<pre><code>IPAddress WiFiClass::dnsIP (\n    uint8_t dns_no=0\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enableap","title":"function enableAP","text":"<pre><code>bool WiFiClass::enableAP (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enableipv6","title":"function enableIpV6","text":"<pre><code>bool WiFiClass::enableIpV6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enablesta","title":"function enableSTA","text":"<pre><code>bool WiFiClass::enableSTA (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-encryptiontype","title":"function encryptionType","text":"<pre><code>WiFiAuthMode WiFiClass::encryptionType (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gatewayip","title":"function gatewayIP","text":"<pre><code>IPAddress WiFiClass::gatewayIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getautoreconnect","title":"function getAutoReconnect","text":"<pre><code>bool WiFiClass::getAutoReconnect () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getencryption","title":"function getEncryption","text":"<pre><code>WiFiAuthMode WiFiClass::getEncryption () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gethostname","title":"function getHostname","text":"<pre><code>const char * WiFiClass::getHostname () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getmode","title":"function getMode","text":"<pre><code>WiFiMode WiFiClass::getMode () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getnetworkinfo","title":"function getNetworkInfo","text":"<pre><code>bool WiFiClass::getNetworkInfo (\n    uint8_t networkItem,\n    String &amp; ssid,\n    WiFiAuthMode &amp; encryptionType,\n    int32_t &amp; RSSI,\n    uint8_t *&amp; BSSID,\n    int32_t &amp; channel\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getsleep","title":"function getSleep","text":"<pre><code>bool WiFiClass::getSleep () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gettxpower","title":"function getTxPower","text":"<pre><code>int WiFiClass::getTxPower () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostbyname-12","title":"function hostByName [1/2]","text":"<pre><code>int WiFiClass::hostByName (\n    const char * hostname,\n    IPAddress &amp; aResult\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostbyname-22","title":"function hostByName [2/2]","text":"<pre><code>IPAddress WiFiClass::hostByName (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostname","title":"function hostname","text":"<pre><code>inline bool WiFiClass::hostname (\n    const String &amp; aHostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-isconnected","title":"function isConnected","text":"<pre><code>bool WiFiClass::isConnected () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-localip","title":"function localIP","text":"<pre><code>IPAddress WiFiClass::localIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-localipv6","title":"function localIPv6","text":"<pre><code>IPv6Address WiFiClass::localIPv6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-macaddress-12","title":"function macAddress [1/2]","text":"<pre><code>uint8_t * WiFiClass::macAddress (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-macaddress-22","title":"function macAddress [2/2]","text":"<pre><code>String WiFiClass::macAddress () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-mode","title":"function mode","text":"<pre><code>bool WiFiClass::mode (\n    WiFiMode mode\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-modepriv","title":"function modePriv","text":"<pre><code>bool WiFiClass::modePriv (\n    WiFiMode mode,\n    WiFiModeAction sta,\n    WiFiModeAction ap\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-networkid","title":"function networkID","text":"<pre><code>IPAddress WiFiClass::networkID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-13","title":"function onEvent [1/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-23","title":"function onEvent [2/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventFuncCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-33","title":"function onEvent [3/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventSysCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-printdiag","title":"function printDiag","text":"<pre><code>void WiFiClass::printDiag (\n    Print &amp; dest\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-psk","title":"function psk","text":"<pre><code>const String WiFiClass::psk () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-reconnect","title":"function reconnect","text":"<pre><code>bool WiFiClass::reconnect (\n    const uint8_t * bssid=NULL\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-13","title":"function removeEvent [1/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    EventCb callback,\n    EventId eventId\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-23","title":"function removeEvent [2/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    EventSysCb callback,\n    EventId eventId\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-33","title":"function removeEvent [3/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    uint16_t id\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scanalloc","title":"function scanAlloc","text":"<pre><code>uint8_t WiFiClass::scanAlloc (\n    uint8_t count\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scancomplete","title":"function scanComplete","text":"<pre><code>int16_t WiFiClass::scanComplete () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scandelete","title":"function scanDelete","text":"<pre><code>void WiFiClass::scanDelete () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scaninit","title":"function scanInit","text":"<pre><code>void WiFiClass::scanInit () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scannetworks","title":"function scanNetworks","text":"<pre><code>int16_t WiFiClass::scanNetworks (\n    bool async=false,\n    bool showHidden=false,\n    bool passive=false,\n    uint32_t maxMsPerChannel=300,\n    uint8_t channel=0\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setautoreconnect","title":"function setAutoReconnect","text":"<pre><code>bool WiFiClass::setAutoReconnect (\n    bool autoReconnect\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-sethostname","title":"function setHostname","text":"<pre><code>bool WiFiClass::setHostname (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setmacaddress","title":"function setMacAddress","text":"<pre><code>bool WiFiClass::setMacAddress (\n    const uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setsleep","title":"function setSleep","text":"<pre><code>bool WiFiClass::setSleep (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-settxpower","title":"function setTxPower","text":"<pre><code>bool WiFiClass::setTxPower (\n    int power\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softap","title":"function softAP","text":"<pre><code>bool WiFiClass::softAP (\n    const char * ssid,\n    const char * passphrase=NULL,\n    int channel=1,\n    bool ssidHidden=false,\n    int maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapbroadcastip","title":"function softAPBroadcastIP","text":"<pre><code>IPAddress WiFiClass::softAPBroadcastIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapconfig","title":"function softAPConfig","text":"<pre><code>bool WiFiClass::softAPConfig (\n    IPAddress localIP,\n    IPAddress gateway,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapip","title":"function softAPIP","text":"<pre><code>IPAddress WiFiClass::softAPIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapipv6","title":"function softAPIPv6","text":"<pre><code>IPv6Address WiFiClass::softAPIPv6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapnetworkid","title":"function softAPNetworkID","text":"<pre><code>IPAddress WiFiClass::softAPNetworkID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapssid","title":"function softAPSSID","text":"<pre><code>const String WiFiClass::softAPSSID (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsubnetcidr","title":"function softAPSubnetCIDR","text":"<pre><code>uint8_t WiFiClass::softAPSubnetCIDR () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsubnetmask","title":"function softAPSubnetMask","text":"<pre><code>IPAddress WiFiClass::softAPSubnetMask () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapdisconnect","title":"function softAPdisconnect","text":"<pre><code>bool WiFiClass::softAPdisconnect (\n    bool wifiOff=false\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapenableipv6","title":"function softAPenableIpV6","text":"<pre><code>bool WiFiClass::softAPenableIpV6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapgethostname","title":"function softAPgetHostname","text":"<pre><code>const char * WiFiClass::softAPgetHostname () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapgetstationnum","title":"function softAPgetStationNum","text":"<pre><code>uint8_t WiFiClass::softAPgetStationNum () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapmacaddress-12","title":"function softAPmacAddress [1/2]","text":"<pre><code>uint8_t * WiFiClass::softAPmacAddress (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapmacaddress-22","title":"function softAPmacAddress [2/2]","text":"<pre><code>String WiFiClass::softAPmacAddress (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsethostname","title":"function softAPsetHostname","text":"<pre><code>bool WiFiClass::softAPsetHostname (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-status","title":"function status","text":"<pre><code>WiFiStatus WiFiClass::status () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-subnetcidr","title":"function subnetCIDR","text":"<pre><code>uint8_t WiFiClass::subnetCIDR () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-subnetmask","title":"function subnetMask","text":"<pre><code>IPAddress WiFiClass::subnetMask () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-validate","title":"function validate","text":"<pre><code>bool WiFiClass::validate (\n    const char * ssid,\n    const char * passphrase\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-waitforconnectresult","title":"function waitForConnectResult","text":"<pre><code>WiFiStatus WiFiClass::waitForConnectResult (\n    unsigned long timeout\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-wificlass_1","title":"function ~WiFiClass","text":"<pre><code>WiFiClass::~WiFiClass () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#function-calculatebroadcast","title":"function calculateBroadcast","text":"<pre><code>static IPAddress WiFiClass::calculateBroadcast (\n    IPAddress ip,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-calculatenetworkid","title":"function calculateNetworkID","text":"<pre><code>static IPAddress WiFiClass::calculateNetworkID (\n    IPAddress ip,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-calculatesubnetcidr","title":"function calculateSubnetCIDR","text":"<pre><code>static uint8_t WiFiClass::calculateSubnetCIDR (\n    IPAddress subnetMask\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-mactostring","title":"function macToString","text":"<pre><code>static String WiFiClass::macToString (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-postevent","title":"function postEvent","text":"<pre><code>static void WiFiClass::postEvent (\n    EventId eventId,\n    EventInfo eventInfo\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-resetnetworkinfo","title":"function resetNetworkInfo","text":"<pre><code>static void WiFiClass::resetNetworkInfo (\n    WiFiNetworkInfo &amp; info\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#protected-static-attributes-documentation","title":"Protected Static Attributes Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#variable-handlers","title":"variable handlers","text":"<pre><code>std::vector&lt; EventHandler &gt; WiFiClass::handlers;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFi.h</code></p>"},{"location":"ltapi/struct_wi_fi_mac_addr/","title":"Struct WiFiMacAddr","text":"<p>ClassList &gt; WiFiMacAddr</p>"},{"location":"ltapi/struct_wi_fi_mac_addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t addr"},{"location":"ltapi/struct_wi_fi_mac_addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_mac_addr/#variable-addr","title":"variable addr","text":"<pre><code>uint8_t WiFiMacAddr::addr[6];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/class_wi_fi_multi/","title":"Class WiFiMulti","text":"<p>ClassList &gt; WiFiMulti</p>"},{"location":"ltapi/class_wi_fi_multi/#public-functions","title":"Public Functions","text":"Type Name      WiFiMulti ()    bool addAP (const char * ssid, const char * passphrase=NULL)    uint8_t run (uint32_t connectTimeout=10000)     ~WiFiMulti ()"},{"location":"ltapi/class_wi_fi_multi/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_multi/#function-wifimulti","title":"function WiFiMulti","text":"<pre><code>WiFiMulti::WiFiMulti () \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-addap","title":"function addAP","text":"<pre><code>bool WiFiMulti::addAP (\n    const char * ssid,\n    const char * passphrase=NULL\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-run","title":"function run","text":"<pre><code>uint8_t WiFiMulti::run (\n    uint32_t connectTimeout=10000\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-wifimulti_1","title":"function ~WiFiMulti","text":"<pre><code>WiFiMulti::~WiFiMulti () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/struct_wi_fi_network_info/","title":"Struct WiFiNetworkInfo","text":"<p>ClassList &gt; WiFiNetworkInfo</p>"},{"location":"ltapi/struct_wi_fi_network_info/#public-attributes","title":"Public Attributes","text":"Type Name     int auth    uint8_t * bssid    int channel    uint32_t dns1    uint32_t dns2    uint32_t gateway    uint32_t localIP    char * password    char * ssid    bool ssidHidden    uint32_t subnet"},{"location":"ltapi/struct_wi_fi_network_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_network_info/#variable-auth","title":"variable auth","text":"<pre><code>int WiFiNetworkInfo::auth;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-bssid","title":"variable bssid","text":"<pre><code>uint8_t* WiFiNetworkInfo::bssid;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-channel","title":"variable channel","text":"<pre><code>int WiFiNetworkInfo::channel;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-dns1","title":"variable dns1","text":"<pre><code>uint32_t WiFiNetworkInfo::dns1;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-dns2","title":"variable dns2","text":"<pre><code>uint32_t WiFiNetworkInfo::dns2;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-gateway","title":"variable gateway","text":"<pre><code>uint32_t WiFiNetworkInfo::gateway;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-localip","title":"variable localIP","text":"<pre><code>uint32_t WiFiNetworkInfo::localIP;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-password","title":"variable password","text":"<pre><code>char* WiFiNetworkInfo::password;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-ssid","title":"variable ssid","text":"<pre><code>char* WiFiNetworkInfo::ssid;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-ssidhidden","title":"variable ssidHidden","text":"<pre><code>bool WiFiNetworkInfo::ssidHidden;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_network_info/#variable-subnet","title":"variable subnet","text":"<pre><code>uint32_t WiFiNetworkInfo::subnet;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/struct_wi_fi_scan_a_p/","title":"Struct WiFiScanAP","text":"<p>ClassList &gt; WiFiScanAP</p>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiAuthMode auth    WiFiMacAddr bssid    int32_t channel    int32_t rssi    char * ssid"},{"location":"ltapi/struct_wi_fi_scan_a_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-auth","title":"variable auth","text":"<pre><code>WiFiAuthMode WiFiScanAP::auth;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-bssid","title":"variable bssid","text":"<pre><code>WiFiMacAddr WiFiScanAP::bssid;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-channel","title":"variable channel","text":"<pre><code>int32_t WiFiScanAP::channel;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-rssi","title":"variable rssi","text":"<pre><code>int32_t WiFiScanAP::rssi;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-ssid","title":"variable ssid","text":"<pre><code>char* WiFiScanAP::ssid;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/struct_wi_fi_scan_data/","title":"Struct WiFiScanData","text":"<p>ClassList &gt; WiFiScanData</p>"},{"location":"ltapi/struct_wi_fi_scan_data/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiScanAP * ap   = = NULL   uint8_t count   = = 0   bool running   = = false   unsigned long timeout   = = 0"},{"location":"ltapi/struct_wi_fi_scan_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_scan_data/#variable-ap","title":"variable ap","text":"<pre><code>WiFiScanAP* WiFiScanData::ap;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-count","title":"variable count","text":"<pre><code>uint8_t WiFiScanData::count;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-running","title":"variable running","text":"<pre><code>bool WiFiScanData::running;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-timeout","title":"variable timeout","text":"<pre><code>unsigned long WiFiScanData::timeout;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/struct_wifi_a_plist__t/","title":"Struct WifiAPlist_t","text":"<p>ClassList &gt; WifiAPlist_t</p>"},{"location":"ltapi/struct_wifi_a_plist__t/#public-attributes","title":"Public Attributes","text":"Type Name     char * passphrase    char * ssid"},{"location":"ltapi/struct_wifi_a_plist__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wifi_a_plist__t/#variable-passphrase","title":"variable passphrase","text":"<pre><code>char* WifiAPlist_t::passphrase;\n</code></pre>"},{"location":"ltapi/struct_wifi_a_plist__t/#variable-ssid","title":"variable ssid","text":"<pre><code>char* WifiAPlist_t::ssid;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/namespacearduino/","title":"Namespace arduino","text":"<p>Namespace List &gt; arduino</p>"},{"location":"ltapi/namespacearduino/#classes","title":"Classes","text":"Type Name     class IPv6Address      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/IPv6Address.h</code></p>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/","title":"Class arduino::IPv6Address","text":"<p>ClassList &gt; arduino &gt; IPv6Address</p> <p>Inherits the following classes: Printable</p>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t bytes    uint32_t dword"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-functions","title":"Public Functions","text":"Type Name      IPv6Address ()     IPv6Address (const uint8_t * address)     IPv6Address (const uint32_t * address)    bool fromString (const char * address)    bool fromString (const String &amp; address)     operator const uint32_t * () const    operator const uint8_t * () const   IPv6Address &amp; operator= (const uint8_t * address)    bool operator== (const IPv6Address &amp; addr) const   bool operator== (const uint8_t * addr) const   uint8_t operator[] (int index) const   uint8_t &amp; operator[] (int index)    virtual size_t printTo (Print &amp; p) const   String toString () const   virtual ~IPv6Address ()"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#variable-bytes","title":"variable bytes","text":"<pre><code>uint8_t arduino::IPv6Address::bytes[16];\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#variable-dword","title":"variable dword","text":"<pre><code>uint32_t arduino::IPv6Address::dword[4];\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-13","title":"function IPv6Address [1/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address () \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-23","title":"function IPv6Address [2/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address (\n    const uint8_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-33","title":"function IPv6Address [3/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address (\n    const uint32_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-fromstring-12","title":"function fromString [1/2]","text":"<pre><code>bool arduino::IPv6Address::fromString (\n    const char * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-fromstring-22","title":"function fromString [2/2]","text":"<pre><code>inline bool arduino::IPv6Address::fromString (\n    const String &amp; address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator-const-uint32_t","title":"function operator const uint32_t *","text":"<pre><code>inline arduino::IPv6Address::operator const uint32_t * () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator-const-uint8_t","title":"function operator const uint8_t *","text":"<pre><code>inline arduino::IPv6Address::operator const uint8_t * () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator","title":"function operator=","text":"<pre><code>IPv6Address &amp; arduino::IPv6Address::operator= (\n    const uint8_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool arduino::IPv6Address::operator== (\n    const IPv6Address &amp; addr\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_2","title":"function operator==","text":"<pre><code>bool arduino::IPv6Address::operator== (\n    const uint8_t * addr\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_3","title":"function operator[]","text":"<pre><code>inline uint8_t arduino::IPv6Address::operator[] (\n    int index\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_4","title":"function operator[]","text":"<pre><code>inline uint8_t &amp; arduino::IPv6Address::operator[] (\n    int index\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-printto","title":"function printTo","text":"<pre><code>virtual size_t arduino::IPv6Address::printTo (\n    Print &amp; p\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-tostring","title":"function toString","text":"<pre><code>String arduino::IPv6Address::toString () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address","title":"function ~IPv6Address","text":"<pre><code>inline virtual arduino::IPv6Address::~IPv6Address () \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friends-documentation","title":"Friends Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-client","title":"friend Client","text":"<pre><code>class arduino::IPv6Address::Client (\n    Client\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-server","title":"friend Server","text":"<pre><code>class arduino::IPv6Address::Server (\n    Server\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-udp","title":"friend UDP","text":"<pre><code>class arduino::IPv6Address::UDP (\n    UDP\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/IPv6Address.h</code></p>"},{"location":"ltapi/unionarduino__event__info__t/","title":"Union arduino_event_info_t","text":"<p>ClassList &gt; arduino_event_info_t</p>"},{"location":"ltapi/unionarduino__event__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     ip_event_got_ip_t got_ip    ip_event_got_ip6_t got_ip6    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved    wifi_event_ap_staconnected_t wifi_ap_staconnected    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected    ip_event_ap_staipassigned_t wifi_ap_staipassigned    wifi_event_ftm_report_t wifi_ftm_report    wifi_event_sta_scan_done_t wifi_scan_done    wifi_event_sta_authmode_change_t wifi_sta_authmode_change    wifi_event_sta_connected_t wifi_sta_connected    wifi_event_sta_disconnected_t wifi_sta_disconnected    wifi_event_sta_wps_er_pin_t wps_er_pin    wifi_event_sta_wps_fail_reason_t wps_fail_reason"},{"location":"ltapi/unionarduino__event__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/unionarduino__event__info__t/#variable-got_ip","title":"variable got_ip","text":"<pre><code>ip_event_got_ip_t arduino_event_info_t::got_ip;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-got_ip6","title":"variable got_ip6","text":"<pre><code>ip_event_got_ip6_t arduino_event_info_t::got_ip6;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_probereqrecved","title":"variable wifi_ap_probereqrecved","text":"<pre><code>wifi_event_ap_probe_req_rx_t arduino_event_info_t::wifi_ap_probereqrecved;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_staconnected","title":"variable wifi_ap_staconnected","text":"<pre><code>wifi_event_ap_staconnected_t arduino_event_info_t::wifi_ap_staconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_stadisconnected","title":"variable wifi_ap_stadisconnected","text":"<pre><code>wifi_event_ap_stadisconnected_t arduino_event_info_t::wifi_ap_stadisconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_staipassigned","title":"variable wifi_ap_staipassigned","text":"<pre><code>ip_event_ap_staipassigned_t arduino_event_info_t::wifi_ap_staipassigned;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ftm_report","title":"variable wifi_ftm_report","text":"<pre><code>wifi_event_ftm_report_t arduino_event_info_t::wifi_ftm_report;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_scan_done","title":"variable wifi_scan_done","text":"<pre><code>wifi_event_sta_scan_done_t arduino_event_info_t::wifi_scan_done;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_authmode_change","title":"variable wifi_sta_authmode_change","text":"<pre><code>wifi_event_sta_authmode_change_t arduino_event_info_t::wifi_sta_authmode_change;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_connected","title":"variable wifi_sta_connected","text":"<pre><code>wifi_event_sta_connected_t arduino_event_info_t::wifi_sta_connected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_disconnected","title":"variable wifi_sta_disconnected","text":"<pre><code>wifi_event_sta_disconnected_t arduino_event_info_t::wifi_sta_disconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wps_er_pin","title":"variable wps_er_pin","text":"<pre><code>wifi_event_sta_wps_er_pin_t arduino_event_info_t::wps_er_pin;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wps_fail_reason","title":"variable wps_fail_reason","text":"<pre><code>wifi_event_sta_wps_fail_reason_t arduino_event_info_t::wps_fail_reason;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Events.h</code></p>"},{"location":"ltapi/structarduino__event__t/","title":"Struct arduino_event_t","text":"<p>ClassList &gt; arduino_event_t</p>"},{"location":"ltapi/structarduino__event__t/#public-attributes","title":"Public Attributes","text":"Type Name     arduino_event_id_t event_id    arduino_event_info_t event_info"},{"location":"ltapi/structarduino__event__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structarduino__event__t/#variable-event_id","title":"variable event_id","text":"<pre><code>arduino_event_id_t arduino_event_t::event_id;\n</code></pre>"},{"location":"ltapi/structarduino__event__t/#variable-event_info","title":"variable event_info","text":"<pre><code>arduino_event_info_t arduino_event_t::event_info;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Events.h</code></p>"},{"location":"ltapi/classbase64/","title":"Class base64","text":"<p>ClassList &gt; base64</p>"},{"location":"ltapi/classbase64/#public-static-functions","title":"Public Static Functions","text":"Type Name     String encode (const uint8_t * data, size_t length)    String encode (const String &amp; text)"},{"location":"ltapi/classbase64/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/classbase64/#function-encode-12","title":"function encode [1/2]","text":"<pre><code>static String base64::encode (\n    const uint8_t * data,\n    size_t length\n) \n</code></pre> <p>base64.cpp</p> <p>Created on: 09.12.2015</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the ESP31B core for Arduino.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA convert input data to base64 </p> <p>Parameters:</p> <ul> <li><code>data</code> const uint8_t * </li> <li><code>length</code> size_t </li> </ul> <p>Returns:</p> <p>String </p>"},{"location":"ltapi/classbase64/#function-encode-22","title":"function encode [2/2]","text":"<pre><code>static String base64::encode (\n    const String &amp; text\n) \n</code></pre> <p>convert input data to base64 </p> <p>Parameters:</p> <ul> <li><code>text</code> const String&amp; </li> </ul> <p>Returns:</p> <p>String </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/base64.h</code></p>"},{"location":"ltapi/structbase64__decodestate/","title":"Struct base64_decodestate","text":"<p>ClassList &gt; base64_decodestate</p>"},{"location":"ltapi/structbase64__decodestate/#public-attributes","title":"Public Attributes","text":"Type Name     char plainchar    base64_decodestep step"},{"location":"ltapi/structbase64__decodestate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structbase64__decodestate/#variable-plainchar","title":"variable plainchar","text":"<pre><code>char base64_decodestate::plainchar;\n</code></pre>"},{"location":"ltapi/structbase64__decodestate/#variable-step","title":"variable step","text":"<pre><code>base64_decodestep base64_decodestate::step;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cdecode.h</code></p>"},{"location":"ltapi/structbase64__encodestate/","title":"Struct base64_encodestate","text":"<p>ClassList &gt; base64_encodestate</p>"},{"location":"ltapi/structbase64__encodestate/#public-attributes","title":"Public Attributes","text":"Type Name     char result    base64_encodestep step    int stepcount"},{"location":"ltapi/structbase64__encodestate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structbase64__encodestate/#variable-result","title":"variable result","text":"<pre><code>char base64_encodestate::result;\n</code></pre>"},{"location":"ltapi/structbase64__encodestate/#variable-step","title":"variable step","text":"<pre><code>base64_encodestep base64_encodestate::step;\n</code></pre>"},{"location":"ltapi/structbase64__encodestate/#variable-stepcount","title":"variable stepcount","text":"<pre><code>int base64_encodestate::stepcount;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cencode.h</code></p>"},{"location":"ltapi/classcbuf/","title":"Class cbuf","text":"<p>ClassList &gt; cbuf</p>"},{"location":"ltapi/classcbuf/#public-attributes","title":"Public Attributes","text":"Type Name     cbuf * next"},{"location":"ltapi/classcbuf/#public-functions","title":"Public Functions","text":"Type Name     size_t available () const    cbuf (size_t size)    bool empty () const   void flush ()    bool full () const   int peek ()    size_t peek (char * dst, size_t size)    int read ()    size_t read (char * dst, size_t size)    size_t remove (size_t size)    size_t resize (size_t newSize)    size_t resizeAdd (size_t addSize)    size_t room () const   size_t size ()    size_t write (char c)    size_t write (const char * src, size_t size)     ~cbuf ()"},{"location":"ltapi/classcbuf/#protected-attributes","title":"Protected Attributes","text":"Type Name     char * _begin    char * _buf    const char * _bufend    char * _end    size_t _size"},{"location":"ltapi/classcbuf/#protected-functions","title":"Protected Functions","text":"Type Name     char * wrap_if_bufend (char * ptr) const"},{"location":"ltapi/classcbuf/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/classcbuf/#variable-next","title":"variable next","text":"<pre><code>cbuf* cbuf::next;\n</code></pre>"},{"location":"ltapi/classcbuf/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classcbuf/#function-available","title":"function available","text":"<pre><code>size_t cbuf::available () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-cbuf","title":"function cbuf","text":"<pre><code>cbuf::cbuf (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-empty","title":"function empty","text":"<pre><code>inline bool cbuf::empty () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-flush","title":"function flush","text":"<pre><code>void cbuf::flush () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-full","title":"function full","text":"<pre><code>inline bool cbuf::full () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-peek-12","title":"function peek [1/2]","text":"<pre><code>int cbuf::peek () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-peek-22","title":"function peek [2/2]","text":"<pre><code>size_t cbuf::peek (\n    char * dst,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-read-12","title":"function read [1/2]","text":"<pre><code>int cbuf::read () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-read-22","title":"function read [2/2]","text":"<pre><code>size_t cbuf::read (\n    char * dst,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-remove","title":"function remove","text":"<pre><code>size_t cbuf::remove (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-resize","title":"function resize","text":"<pre><code>size_t cbuf::resize (\n    size_t newSize\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-resizeadd","title":"function resizeAdd","text":"<pre><code>size_t cbuf::resizeAdd (\n    size_t addSize\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-room","title":"function room","text":"<pre><code>size_t cbuf::room () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-size","title":"function size","text":"<pre><code>size_t cbuf::size () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t cbuf::write (\n    char c\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t cbuf::write (\n    const char * src,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-cbuf_1","title":"function ~cbuf","text":"<pre><code>cbuf::~cbuf () \n</code></pre>"},{"location":"ltapi/classcbuf/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classcbuf/#variable-_begin","title":"variable _begin","text":"<pre><code>char* cbuf::_begin;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_buf","title":"variable _buf","text":"<pre><code>char* cbuf::_buf;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_bufend","title":"variable _bufend","text":"<pre><code>const char* cbuf::_bufend;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_end","title":"variable _end","text":"<pre><code>char* cbuf::_end;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_size","title":"variable _size","text":"<pre><code>size_t cbuf::_size;\n</code></pre>"},{"location":"ltapi/classcbuf/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/classcbuf/#function-wrap_if_bufend","title":"function wrap_if_bufend","text":"<pre><code>inline char * cbuf::wrap_if_bufend (\n    char * ptr\n) const\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/cbuf/cbuf.h</code></p>"},{"location":"ltapi/structesp__ip4__addr/","title":"Struct esp_ip4_addr","text":"<p>ClassList &gt; esp_ip4_addr</p>"},{"location":"ltapi/structesp__ip4__addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t addr"},{"location":"ltapi/structesp__ip4__addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__ip4__addr/#variable-addr","title":"variable addr","text":"<pre><code>uint32_t esp_ip4_addr::addr;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/structesp__ip6__addr/","title":"Struct esp_ip6_addr","text":"<p>ClassList &gt; esp_ip6_addr</p>"},{"location":"ltapi/structesp__ip6__addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t addr    uint8_t zone"},{"location":"ltapi/structesp__ip6__addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__ip6__addr/#variable-addr","title":"variable addr","text":"<pre><code>uint32_t esp_ip6_addr::addr[4];\n</code></pre>"},{"location":"ltapi/structesp__ip6__addr/#variable-zone","title":"variable zone","text":"<pre><code>uint8_t esp_ip6_addr::zone;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/structesp__netif__ip6__info__t/","title":"Struct esp_netif_ip6_info_t","text":"<p>ClassList &gt; esp_netif_ip6_info_t</p> <p>IPV6 IP address information. </p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structesp__netif__ip6__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip6_addr_t ip"},{"location":"ltapi/structesp__netif__ip6__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__netif__ip6__info__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip6_addr_t esp_netif_ip6_info_t::ip;\n</code></pre> <p>Interface IPV6 address </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structesp__netif__ip__info__t/","title":"Struct esp_netif_ip_info_t","text":"<p>ClassList &gt; esp_netif_ip_info_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structesp__netif__ip__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip4_addr_t gw    esp_ip4_addr_t ip    esp_ip4_addr_t netmask"},{"location":"ltapi/structesp__netif__ip__info__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_STA_GOT_IP, IP_EVENT_ETH_GOT_IP events </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__netif__ip__info__t/#variable-gw","title":"variable gw","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::gw;\n</code></pre> <p>Interface IPV4 gateway address </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::ip;\n</code></pre> <p>Interface IPV4 address </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#variable-netmask","title":"variable netmask","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::netmask;\n</code></pre> <p>Interface IPV4 netmask </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/namespacefs/","title":"Namespace fs","text":"<p>Namespace List &gt; fs</p>"},{"location":"ltapi/namespacefs/#classes","title":"Classes","text":"Type Name     class FS    class FSImpl    class File    class FileImpl"},{"location":"ltapi/namespacefs/#public-types","title":"Public Types","text":"Type Name     typedef std::shared_ptr&lt; FSImpl &gt; FSImplPtr    typedef std::shared_ptr&lt; FileImpl &gt; FileImplPtr    enum SeekMode"},{"location":"ltapi/namespacefs/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/namespacefs/#typedef-fsimplptr","title":"typedef FSImplPtr","text":"<pre><code>typedef std::shared_ptr&lt;FSImpl&gt; fs::FSImplPtr;\n</code></pre>"},{"location":"ltapi/namespacefs/#typedef-fileimplptr","title":"typedef FileImplPtr","text":"<pre><code>typedef std::shared_ptr&lt;FileImpl&gt; fs::FileImplPtr;\n</code></pre>"},{"location":"ltapi/namespacefs/#enum-seekmode","title":"enum SeekMode","text":"<pre><code>enum fs::SeekMode {\n    SeekSet = 0,\n    SeekCur = 1,\n    SeekEnd = 2\n};\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_f_s/","title":"Class fs::FS","text":"<p>ClassList &gt; fs &gt; FS</p>"},{"location":"ltapi/classfs_1_1_f_s/#public-functions","title":"Public Functions","text":"Type Name      FS (FSImplPtr impl)    bool exists (const char * path)    bool exists (const String &amp; path)    bool mkdir (const char * path)    bool mkdir (const String &amp; path)    File open (const char * path, const char * mode=FILE_READ, const bool create=false)    File open (const String &amp; path, const char * mode=FILE_READ, const bool create=false)    bool remove (const char * path)    bool remove (const String &amp; path)    bool rename (const char * pathFrom, const char * pathTo)    bool rename (const String &amp; pathFrom, const String &amp; pathTo)    bool rmdir (const char * path)    bool rmdir (const String &amp; path)"},{"location":"ltapi/classfs_1_1_f_s/#protected-attributes","title":"Protected Attributes","text":"Type Name     FSImplPtr _impl"},{"location":"ltapi/classfs_1_1_f_s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s/#function-fs","title":"function FS","text":"<pre><code>inline fs::FS::FS (\n    FSImplPtr impl\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-exists-12","title":"function exists [1/2]","text":"<pre><code>bool fs::FS::exists (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-exists-22","title":"function exists [2/2]","text":"<pre><code>bool fs::FS::exists (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-mkdir-12","title":"function mkdir [1/2]","text":"<pre><code>bool fs::FS::mkdir (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-mkdir-22","title":"function mkdir [2/2]","text":"<pre><code>bool fs::FS::mkdir (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-open-12","title":"function open [1/2]","text":"<pre><code>File fs::FS::open (\n    const char * path,\n    const char * mode=FILE_READ,\n    const bool create=false\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-open-22","title":"function open [2/2]","text":"<pre><code>File fs::FS::open (\n    const String &amp; path,\n    const char * mode=FILE_READ,\n    const bool create=false\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-remove-12","title":"function remove [1/2]","text":"<pre><code>bool fs::FS::remove (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-remove-22","title":"function remove [2/2]","text":"<pre><code>bool fs::FS::remove (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rename-12","title":"function rename [1/2]","text":"<pre><code>bool fs::FS::rename (\n    const char * pathFrom,\n    const char * pathTo\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rename-22","title":"function rename [2/2]","text":"<pre><code>bool fs::FS::rename (\n    const String &amp; pathFrom,\n    const String &amp; pathTo\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rmdir-12","title":"function rmdir [1/2]","text":"<pre><code>bool fs::FS::rmdir (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rmdir-22","title":"function rmdir [2/2]","text":"<pre><code>bool fs::FS::rmdir (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s/#variable-_impl","title":"variable _impl","text":"<pre><code>FSImplPtr fs::FS::_impl;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_f_s_impl/","title":"Class fs::FSImpl","text":"<p>ClassList &gt; fs &gt; FSImpl</p>"},{"location":"ltapi/classfs_1_1_f_s_impl/#public-functions","title":"Public Functions","text":"Type Name      FSImpl ()    virtual bool exists (const char * path) = 0   virtual bool mkdir (const char * path) = 0   virtual FileImplPtr open (const char * path, const char * mode, const bool create) = 0   virtual bool remove (const char * path) = 0   virtual bool rename (const char * pathFrom, const char * pathTo) = 0   virtual bool rmdir (const char * path) = 0   virtual ~FSImpl ()"},{"location":"ltapi/classfs_1_1_f_s_impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s_impl/#function-fsimpl","title":"function FSImpl","text":"<pre><code>inline fs::FSImpl::FSImpl () \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-exists","title":"function exists","text":"<pre><code>virtual bool fs::FSImpl::exists (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-mkdir","title":"function mkdir","text":"<pre><code>virtual bool fs::FSImpl::mkdir (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-open","title":"function open","text":"<pre><code>virtual FileImplPtr fs::FSImpl::open (\n    const char * path,\n    const char * mode,\n    const bool create\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-remove","title":"function remove","text":"<pre><code>virtual bool fs::FSImpl::remove (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-rename","title":"function rename","text":"<pre><code>virtual bool fs::FSImpl::rename (\n    const char * pathFrom,\n    const char * pathTo\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-rmdir","title":"function rmdir","text":"<pre><code>virtual bool fs::FSImpl::rmdir (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-fsimpl_1","title":"function ~FSImpl","text":"<pre><code>inline virtual fs::FSImpl::~FSImpl () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_file/","title":"Class fs::File","text":"<p>ClassList &gt; fs &gt; File</p> <p>Inherits the following classes: Stream</p>"},{"location":"ltapi/classfs_1_1_file/#public-functions","title":"Public Functions","text":"Type Name      File (FileImplPtr p=FileImplPtr())    int available () override   void close ()    void flush () override   time_t getLastWrite ()    boolean isDirectory (void)    const char * name () const   File openNextFile (const char * mode=FILE_READ)     operator bool () const   const char * path () const   int peek () override   size_t position () const   int read () override   size_t read (uint8_t * buf, size_t size)    size_t readBytes (char * buffer, size_t length)    void rewindDirectory (void)    bool seek (uint32_t pos, SeekMode mode)    bool seek (uint32_t pos)    bool setBufferSize (size_t size)    size_t size () const   size_t write (uint8_t c) override   size_t write (const uint8_t * buf, size_t size) override"},{"location":"ltapi/classfs_1_1_file/#protected-attributes","title":"Protected Attributes","text":"Type Name     FileImplPtr _p"},{"location":"ltapi/classfs_1_1_file/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_file/#function-file","title":"function File","text":"<pre><code>inline fs::File::File (\n    FileImplPtr p=FileImplPtr()\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-available","title":"function available","text":"<pre><code>int fs::File::available () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-close","title":"function close","text":"<pre><code>void fs::File::close () \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-flush","title":"function flush","text":"<pre><code>void fs::File::flush () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-getlastwrite","title":"function getLastWrite","text":"<pre><code>time_t fs::File::getLastWrite () \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-isdirectory","title":"function isDirectory","text":"<pre><code>boolean fs::File::isDirectory (\n    void\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-name","title":"function name","text":"<pre><code>const char * fs::File::name () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-opennextfile","title":"function openNextFile","text":"<pre><code>File fs::File::openNextFile (\n    const char * mode=FILE_READ\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-operator-bool","title":"function operator bool","text":"<pre><code>fs::File::operator bool () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-path","title":"function path","text":"<pre><code>const char * fs::File::path () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-peek","title":"function peek","text":"<pre><code>int fs::File::peek () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-position","title":"function position","text":"<pre><code>size_t fs::File::position () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-read-12","title":"function read [1/2]","text":"<pre><code>int fs::File::read () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-read-22","title":"function read [2/2]","text":"<pre><code>size_t fs::File::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-readbytes","title":"function readBytes","text":"<pre><code>inline size_t fs::File::readBytes (\n    char * buffer,\n    size_t length\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-rewinddirectory","title":"function rewindDirectory","text":"<pre><code>void fs::File::rewindDirectory (\n    void\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-seek-12","title":"function seek [1/2]","text":"<pre><code>bool fs::File::seek (\n    uint32_t pos,\n    SeekMode mode\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-seek-22","title":"function seek [2/2]","text":"<pre><code>inline bool fs::File::seek (\n    uint32_t pos\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-setbuffersize","title":"function setBufferSize","text":"<pre><code>bool fs::File::setBufferSize (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-size","title":"function size","text":"<pre><code>size_t fs::File::size () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t fs::File::write (\n    uint8_t c\n) override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t fs::File::write (\n    const uint8_t * buf,\n    size_t size\n) override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classfs_1_1_file/#variable-_p","title":"variable _p","text":"<pre><code>FileImplPtr fs::File::_p;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_file_impl/","title":"Class fs::FileImpl","text":"<p>ClassList &gt; fs &gt; FileImpl</p>"},{"location":"ltapi/classfs_1_1_file_impl/#public-functions","title":"Public Functions","text":"Type Name     virtual void close () = 0   virtual void flush () = 0   virtual time_t getLastWrite () = 0   virtual boolean isDirectory (void) = 0   virtual const char * name () const = 0   virtual FileImplPtr openNextFile (const char * mode) = 0   virtual operator bool () = 0   virtual const char * path () const = 0   virtual size_t position () const = 0   virtual size_t read (uint8_t * buf, size_t size) = 0   virtual void rewindDirectory (void) = 0   virtual bool seek (uint32_t pos, SeekMode mode) = 0   virtual bool setBufferSize (size_t size) = 0   virtual size_t size () const = 0   virtual size_t write (const uint8_t * buf, size_t size) = 0   virtual ~FileImpl ()"},{"location":"ltapi/classfs_1_1_file_impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_file_impl/#function-close","title":"function close","text":"<pre><code>virtual void fs::FileImpl::close () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-flush","title":"function flush","text":"<pre><code>virtual void fs::FileImpl::flush () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-getlastwrite","title":"function getLastWrite","text":"<pre><code>virtual time_t fs::FileImpl::getLastWrite () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-isdirectory","title":"function isDirectory","text":"<pre><code>virtual boolean fs::FileImpl::isDirectory (\n    void\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-name","title":"function name","text":"<pre><code>virtual const char * fs::FileImpl::name () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-opennextfile","title":"function openNextFile","text":"<pre><code>virtual FileImplPtr fs::FileImpl::openNextFile (\n    const char * mode\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual fs::FileImpl::operator bool () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-path","title":"function path","text":"<pre><code>virtual const char * fs::FileImpl::path () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-position","title":"function position","text":"<pre><code>virtual size_t fs::FileImpl::position () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-read","title":"function read","text":"<pre><code>virtual size_t fs::FileImpl::read (\n    uint8_t * buf,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-rewinddirectory","title":"function rewindDirectory","text":"<pre><code>virtual void fs::FileImpl::rewindDirectory (\n    void\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-seek","title":"function seek","text":"<pre><code>virtual bool fs::FileImpl::seek (\n    uint32_t pos,\n    SeekMode mode\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-setbuffersize","title":"function setBufferSize","text":"<pre><code>virtual bool fs::FileImpl::setBufferSize (\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-size","title":"function size","text":"<pre><code>virtual size_t fs::FileImpl::size () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-write","title":"function write","text":"<pre><code>virtual size_t fs::FileImpl::write (\n    const uint8_t * buf,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-fileimpl","title":"function ~FileImpl","text":"<pre><code>inline virtual fs::FileImpl::~FileImpl () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/structip__event__ap__staipassigned__t/","title":"Struct ip_event_ap_staipassigned_t","text":"<p>ClassList &gt; ip_event_ap_staipassigned_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structip__event__ap__staipassigned__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip4_addr_t ip"},{"location":"ltapi/structip__event__ap__staipassigned__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_AP_STAIPASSIGNED event </p>"},{"location":"ltapi/structip__event__ap__staipassigned__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__ap__staipassigned__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip4_addr_t ip_event_ap_staipassigned_t::ip;\n</code></pre> <p>IP address which was assigned to the station </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structip__event__got__ip6__t/","title":"Struct ip_event_got_ip6_t","text":"<p>ClassList &gt; ip_event_got_ip6_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structip__event__got__ip6__t/#public-attributes","title":"Public Attributes","text":"Type Name     void * esp_netif    int if_index    esp_netif_ip6_info_t ip6_info    int ip_index"},{"location":"ltapi/structip__event__got__ip6__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_GOT_IP6 event </p>"},{"location":"ltapi/structip__event__got__ip6__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__got__ip6__t/#variable-esp_netif","title":"variable esp_netif","text":"<pre><code>void* ip_event_got_ip6_t::esp_netif;\n</code></pre> <p>Pointer to corresponding esp-netif object </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-if_index","title":"variable if_index","text":"<pre><code>int ip_event_got_ip6_t::if_index;\n</code></pre> <p>Interface index for which the event is received (left for legacy compilation) </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-ip6_info","title":"variable ip6_info","text":"<pre><code>esp_netif_ip6_info_t ip_event_got_ip6_t::ip6_info;\n</code></pre> <p>IPv6 address of the interface </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-ip_index","title":"variable ip_index","text":"<pre><code>int ip_event_got_ip6_t::ip_index;\n</code></pre> <p>IPv6 address index </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structip__event__got__ip__t/","title":"Struct ip_event_got_ip_t","text":"<p>ClassList &gt; ip_event_got_ip_t</p>"},{"location":"ltapi/structip__event__got__ip__t/#public-attributes","title":"Public Attributes","text":"Type Name     void * esp_netif    int if_index    bool ip_changed    esp_netif_ip_info_t ip_info"},{"location":"ltapi/structip__event__got__ip__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__got__ip__t/#variable-esp_netif","title":"variable esp_netif","text":"<pre><code>void* ip_event_got_ip_t::esp_netif;\n</code></pre> <p>Pointer to corresponding esp-netif object </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-if_index","title":"variable if_index","text":"<pre><code>int ip_event_got_ip_t::if_index;\n</code></pre> <p>Interface index for which the event is received (left for legacy compilation) </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-ip_changed","title":"variable ip_changed","text":"<pre><code>bool ip_event_got_ip_t::ip_changed;\n</code></pre> <p>Whether the assigned IP has changed or not </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-ip_info","title":"variable ip_info","text":"<pre><code>esp_netif_ip_info_t ip_event_got_ip_t::ip_info;\n</code></pre> <p>IP address, netmask, gatway IP address </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structlt__flash__id__t/","title":"Struct lt_flash_id_t","text":"<p>ClassList &gt; lt_flash_id_t</p> <p>Flash chip ID structure. </p> <ul> <li><code>#include &lt;lt_flash.h&gt;</code></li> </ul>"},{"location":"ltapi/structlt__flash__id__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t chip_id    uint8_t chip_size_id    uint8_t manufacturer_id"},{"location":"ltapi/structlt__flash__id__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structlt__flash__id__t/#variable-chip_id","title":"variable chip_id","text":"<pre><code>uint8_t lt_flash_id_t::chip_id;\n</code></pre>"},{"location":"ltapi/structlt__flash__id__t/#variable-chip_size_id","title":"variable chip_size_id","text":"<pre><code>uint8_t lt_flash_id_t::chip_size_id;\n</code></pre>"},{"location":"ltapi/structlt__flash__id__t/#variable-manufacturer_id","title":"variable manufacturer_id","text":"<pre><code>uint8_t lt_flash_id_t::manufacturer_id;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_flash.h</code></p>"},{"location":"ltapi/structlt__ota__ctx__t/","title":"Struct lt_ota_ctx_t","text":"<p>ClassList &gt; lt_ota_ctx_t</p> <p>OTA update process context. </p> <ul> <li><code>#include &lt;lt_ota.h&gt;</code></li> </ul>"},{"location":"ltapi/structlt__ota__ctx__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t buf    uint8_t * buf_pos    uint32_t bytes_total    uint32_t bytes_written    void(* callback    void * callback_param    uf2_err_t error    uf2_info_t info    bool running    uf2_ota_t uf2"},{"location":"ltapi/structlt__ota__ctx__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structlt__ota__ctx__t/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t lt_ota_ctx_t::buf[UF2_BLOCK_SIZE];\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-buf_pos","title":"variable buf_pos","text":"<pre><code>uint8_t* lt_ota_ctx_t::buf_pos;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-bytes_total","title":"variable bytes_total","text":"<pre><code>uint32_t lt_ota_ctx_t::bytes_total;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-bytes_written","title":"variable bytes_written","text":"<pre><code>uint32_t lt_ota_ctx_t::bytes_written;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-callback","title":"variable callback","text":"<pre><code>void(* lt_ota_ctx_t::callback) (void *param);\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-callback_param","title":"variable callback_param","text":"<pre><code>void* lt_ota_ctx_t::callback_param;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-error","title":"variable error","text":"<pre><code>uf2_err_t lt_ota_ctx_t::error;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-info","title":"variable info","text":"<pre><code>uf2_info_t lt_ota_ctx_t::info;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-running","title":"variable running","text":"<pre><code>bool lt_ota_ctx_t::running;\n</code></pre>"},{"location":"ltapi/structlt__ota__ctx__t/#variable-uf2","title":"variable uf2","text":"<pre><code>uf2_ota_t lt_ota_ctx_t::uf2;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_ota.h</code></p>"},{"location":"ltapi/classm_d_n_s/","title":"Class mDNS","text":"<p>ClassList &gt; mDNS</p>"},{"location":"ltapi/classm_d_n_s/#public-functions","title":"Public Functions","text":"Type Name     IPAddress IP (int idx)    IPv6Address IPv6 (int idx)    bool addService (char * service, char * proto, uint16_t port)    bool addService (const char * service, const char * proto, uint16_t port)    bool addService (String service, String proto, uint16_t port)    bool addServiceTxt (char * service, char * proto, char * key, char * value)    void addServiceTxt (const char * service, const char * proto, const char * key, const char * value)    void addServiceTxt (String service, String proto, String key, String value)    bool begin (const char * hostname)    void end ()    bool hasTxt (int idx, const char * key)    String hostname (int idx)     mDNS ()    int numTxt (int idx)    uint16_t port (int idx)    IPAddress queryHost (char * host, uint32_t timeout=2000)    IPAddress queryHost (const char * host, uint32_t timeout=2000)    IPAddress queryHost (String host, uint32_t timeout=2000)    int queryService (char * service, char * proto)    int queryService (const char * service, const char * proto)    int queryService (String service, String proto)    void setInstanceName (const char * name)    void setInstanceName (String name)    void setInstanceName (char * name)    String txt (int idx, const char * key)    String txt (int idx, int txtIdx)    String txtKey (int idx, int txtIdx)     ~mDNS ()"},{"location":"ltapi/classm_d_n_s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classm_d_n_s/#function-ip","title":"function IP","text":"<pre><code>IPAddress mDNS::IP (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-ipv6","title":"function IPv6","text":"<pre><code>IPv6Address mDNS::IPv6 (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-13","title":"function addService [1/3]","text":"<pre><code>bool mDNS::addService (\n    char * service,\n    char * proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-23","title":"function addService [2/3]","text":"<pre><code>inline bool mDNS::addService (\n    const char * service,\n    const char * proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-33","title":"function addService [3/3]","text":"<pre><code>inline bool mDNS::addService (\n    String service,\n    String proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-13","title":"function addServiceTxt [1/3]","text":"<pre><code>bool mDNS::addServiceTxt (\n    char * service,\n    char * proto,\n    char * key,\n    char * value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-23","title":"function addServiceTxt [2/3]","text":"<pre><code>inline void mDNS::addServiceTxt (\n    const char * service,\n    const char * proto,\n    const char * key,\n    const char * value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-33","title":"function addServiceTxt [3/3]","text":"<pre><code>inline void mDNS::addServiceTxt (\n    String service,\n    String proto,\n    String key,\n    String value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-begin","title":"function begin","text":"<pre><code>bool mDNS::begin (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-end","title":"function end","text":"<pre><code>void mDNS::end () \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-hastxt","title":"function hasTxt","text":"<pre><code>bool mDNS::hasTxt (\n    int idx,\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-hostname","title":"function hostname","text":"<pre><code>String mDNS::hostname (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-mdns","title":"function mDNS","text":"<pre><code>mDNS::mDNS () \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-numtxt","title":"function numTxt","text":"<pre><code>int mDNS::numTxt (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-port","title":"function port","text":"<pre><code>uint16_t mDNS::port (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-13","title":"function queryHost [1/3]","text":"<pre><code>IPAddress mDNS::queryHost (\n    char * host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-23","title":"function queryHost [2/3]","text":"<pre><code>inline IPAddress mDNS::queryHost (\n    const char * host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-33","title":"function queryHost [3/3]","text":"<pre><code>inline IPAddress mDNS::queryHost (\n    String host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-13","title":"function queryService [1/3]","text":"<pre><code>int mDNS::queryService (\n    char * service,\n    char * proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-23","title":"function queryService [2/3]","text":"<pre><code>inline int mDNS::queryService (\n    const char * service,\n    const char * proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-33","title":"function queryService [3/3]","text":"<pre><code>inline int mDNS::queryService (\n    String service,\n    String proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-13","title":"function setInstanceName [1/3]","text":"<pre><code>void mDNS::setInstanceName (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-23","title":"function setInstanceName [2/3]","text":"<pre><code>inline void mDNS::setInstanceName (\n    String name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-33","title":"function setInstanceName [3/3]","text":"<pre><code>inline void mDNS::setInstanceName (\n    char * name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txt-12","title":"function txt [1/2]","text":"<pre><code>String mDNS::txt (\n    int idx,\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txt-22","title":"function txt [2/2]","text":"<pre><code>String mDNS::txt (\n    int idx,\n    int txtIdx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txtkey","title":"function txtKey","text":"<pre><code>String mDNS::txtKey (\n    int idx,\n    int txtIdx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-mdns_1","title":"function ~mDNS","text":"<pre><code>mDNS::~mDNS () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/mDNS/mDNS.h</code></p>"},{"location":"ltapi/structmbedtls__md5__context/","title":"Struct mbedtls_md5_context","text":"<p>ClassList &gt; mbedtls_md5_context</p>"},{"location":"ltapi/structmbedtls__md5__context/#public-attributes","title":"Public Attributes","text":"Type Name     unsigned char buffer    unsigned long state    unsigned long total"},{"location":"ltapi/structmbedtls__md5__context/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structmbedtls__md5__context/#variable-buffer","title":"variable buffer","text":"<pre><code>unsigned char mbedtls_md5_context::buffer[64];\n</code></pre> <p>data block being processed </p>"},{"location":"ltapi/structmbedtls__md5__context/#variable-state","title":"variable state","text":"<pre><code>unsigned long mbedtls_md5_context::state[4];\n</code></pre> <p>intermediate digest state </p>"},{"location":"ltapi/structmbedtls__md5__context/#variable-total","title":"variable total","text":"<pre><code>unsigned long mbedtls_md5_context::total[2];\n</code></pre> <p>number of bytes processed </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5MbedTLSImpl.h</code></p>"},{"location":"ltapi/namespacemime/","title":"Namespace mime","text":"<p>Namespace List &gt; mime</p>"},{"location":"ltapi/namespacemime/#classes","title":"Classes","text":"Type Name     struct Entry"},{"location":"ltapi/namespacemime/#public-types","title":"Public Types","text":"Type Name     enum type"},{"location":"ltapi/namespacemime/#public-attributes","title":"Public Attributes","text":"Type Name     const Entry mimeTable   = = {   {\".html\",     \"text/html\"                    },    {\".htm\",         \"text/html\"                    },    {\".css\",         \"text/css\"                    },    {\".txt\",         \"text/plain\"                    },    {\".js\",     \"application/javascript\"        },    {\".json\",     \"application/json\"                },    {\".png\",         \"image/png\"                    },    {\".gif\",         \"image/gif\"                    },    {\".jpg\",         \"image/jpeg\"                    },    {\".ico\",         \"image/x-icon\"                },    {\".svg\",         \"image/svg+xml\"                },    {\".ttf\",         \"application/x-font-ttf\"        },    {\".otf\",         \"application/x-font-opentype\"  },    {\".woff\",     \"application/font-woff\"        },    {\".woff2\",     \"application/font-woff2\"    },    {\".eot\",         \"application/vnd.ms-fontobject\"},    {\".sfnt\",     \"application/font-sfnt\"        },    {\".xml\",         \"text/xml\"                    },    {\".pdf\",         \"application/pdf\"            },    {\".zip\",         \"application/zip\"            },    {\".gz\",     \"application/x-gzip\"            },    {\".appcache\", \"text/cache-manifest\"        },    {\"\",          \"application/octet-stream\"       }    }"},{"location":"ltapi/namespacemime/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/namespacemime/#enum-type","title":"enum type","text":"<pre><code>enum mime::type {\n    html,\n    htm,\n    css,\n    txt,\n    js,\n    json,\n    png,\n    gif,\n    jpg,\n    ico,\n    svg,\n    ttf,\n    otf,\n    woff,\n    woff2,\n    eot,\n    sfnt,\n    xml,\n    pdf,\n    zip,\n    gz,\n    appcache,\n    none,\n    maxType\n};\n</code></pre>"},{"location":"ltapi/namespacemime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/namespacemime/#variable-mimetable","title":"variable mimeTable","text":"<pre><code>const Entry mime::mimeTable;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/mimetable.cpp</code></p>"},{"location":"ltapi/structmime_1_1_entry/","title":"Struct mime::Entry","text":"<p>ClassList &gt; mime &gt; Entry</p>"},{"location":"ltapi/structmime_1_1_entry/#public-attributes","title":"Public Attributes","text":"Type Name     const char endsWith    const char mimeType"},{"location":"ltapi/structmime_1_1_entry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structmime_1_1_entry/#variable-endswith","title":"variable endsWith","text":"<pre><code>const char mime::Entry::endsWith[16];\n</code></pre>"},{"location":"ltapi/structmime_1_1_entry/#variable-mimetype","title":"variable mimeType","text":"<pre><code>const char mime::Entry::mimeType[32];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/mimetable.h</code></p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/","title":"Struct wifi_event_action_tx_status_t","text":"<p>ClassList &gt; wifi_event_action_tx_status_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t context    uint8_t da    int ifx    uint8_t status"},{"location":"ltapi/structwifi__event__action__tx__status__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_ACTION_TX_STATUS event </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-context","title":"variable context","text":"<pre><code>uint32_t wifi_event_action_tx_status_t::context;\n</code></pre> <p>Context to identify the request </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-da","title":"variable da","text":"<pre><code>uint8_t wifi_event_action_tx_status_t::da[6];\n</code></pre> <p>Destination MAC address </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-ifx","title":"variable ifx","text":"<pre><code>int wifi_event_action_tx_status_t::ifx;\n</code></pre> <p>WiFi interface to send request to </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-status","title":"variable status","text":"<pre><code>uint8_t wifi_event_action_tx_status_t::status;\n</code></pre> <p>Status of the operation </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/","title":"Struct wifi_event_ap_probe_req_rx_t","text":"<p>ClassList &gt; wifi_event_ap_probe_req_rx_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t mac    int rssi"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event </p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_probe_req_rx_t::mac[6];\n</code></pre> <p>MAC address of the station which send probe request </p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#variable-rssi","title":"variable rssi","text":"<pre><code>int wifi_event_ap_probe_req_rx_t::rssi;\n</code></pre> <p>Received probe request signal strength </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/","title":"Struct wifi_event_ap_staconnected_t","text":"<p>ClassList &gt; wifi_event_ap_staconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t aid    bool is_mesh_child    uint8_t mac"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_STACONNECTED event </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-aid","title":"variable aid","text":"<pre><code>uint8_t wifi_event_ap_staconnected_t::aid;\n</code></pre> <p>the aid that ESP32 soft-AP gives to the station connected to </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-is_mesh_child","title":"variable is_mesh_child","text":"<pre><code>bool wifi_event_ap_staconnected_t::is_mesh_child;\n</code></pre> <p>flag to identify mesh child </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_staconnected_t::mac[6];\n</code></pre> <p>MAC address of the station connected to ESP32 soft-AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/","title":"Struct wifi_event_ap_stadisconnected_t","text":"<p>ClassList &gt; wifi_event_ap_stadisconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t aid    bool is_mesh_child    uint8_t mac"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_STADISCONNECTED event </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-aid","title":"variable aid","text":"<pre><code>uint8_t wifi_event_ap_stadisconnected_t::aid;\n</code></pre> <p>the aid that ESP32 soft-AP gave to the station disconnects to </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-is_mesh_child","title":"variable is_mesh_child","text":"<pre><code>bool wifi_event_ap_stadisconnected_t::is_mesh_child;\n</code></pre> <p>flag to identify mesh child </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_stadisconnected_t::mac[6];\n</code></pre> <p>MAC address of the station disconnects to ESP32 soft-AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ftm__report__t/","title":"Struct wifi_event_ftm_report_t","text":"<p>ClassList &gt; wifi_event_ftm_report_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ftm__report__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t dist_est    wifi_ftm_report_entry_t * ftm_report_data    uint8_t ftm_report_num_entries    uint8_t peer_mac    uint32_t rtt_est    uint32_t rtt_raw    wifi_ftm_status_t status"},{"location":"ltapi/structwifi__event__ftm__report__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_FTM_REPORT event </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-dist_est","title":"variable dist_est","text":"<pre><code>uint32_t wifi_event_ftm_report_t::dist_est;\n</code></pre> <p>Estimated one-way distance in Centi-Meters </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-ftm_report_data","title":"variable ftm_report_data","text":"<pre><code>wifi_ftm_report_entry_t* wifi_event_ftm_report_t::ftm_report_data;\n</code></pre> <p>Pointer to FTM Report with multiple entries, should be freed after use </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-ftm_report_num_entries","title":"variable ftm_report_num_entries","text":"<pre><code>uint8_t wifi_event_ftm_report_t::ftm_report_num_entries;\n</code></pre> <p>Number of entries in the FTM Report data </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-peer_mac","title":"variable peer_mac","text":"<pre><code>uint8_t wifi_event_ftm_report_t::peer_mac[6];\n</code></pre> <p>MAC address of the FTM Peer </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-rtt_est","title":"variable rtt_est","text":"<pre><code>uint32_t wifi_event_ftm_report_t::rtt_est;\n</code></pre> <p>Estimated Round-Trip-Time with peer in Nano-Seconds </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-rtt_raw","title":"variable rtt_raw","text":"<pre><code>uint32_t wifi_event_ftm_report_t::rtt_raw;\n</code></pre> <p>Raw average Round-Trip-Time with peer in Nano-Seconds </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-status","title":"variable status","text":"<pre><code>wifi_ftm_status_t wifi_event_ftm_report_t::status;\n</code></pre> <p>Status of the FTM operation </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__roc__done__t/","title":"Struct wifi_event_roc_done_t","text":"<p>ClassList &gt; wifi_event_roc_done_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__roc__done__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t context"},{"location":"ltapi/structwifi__event__roc__done__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_ROC_DONE event </p>"},{"location":"ltapi/structwifi__event__roc__done__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__roc__done__t/#variable-context","title":"variable context","text":"<pre><code>uint32_t wifi_event_roc_done_t::context;\n</code></pre> <p>Context to identify the request </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/","title":"Struct wifi_event_sta_authmode_change_t","text":"<p>ClassList &gt; wifi_event_sta_authmode_change_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#public-attributes","title":"Public Attributes","text":"Type Name     wifi_auth_mode_t new_mode    wifi_auth_mode_t old_mode"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event </p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#variable-new_mode","title":"variable new_mode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_authmode_change_t::new_mode;\n</code></pre> <p>the new auth mode of AP </p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#variable-old_mode","title":"variable old_mode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_authmode_change_t::old_mode;\n</code></pre> <p>the old auth mode of AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__connected__t/","title":"Struct wifi_event_sta_connected_t","text":"<p>ClassList &gt; wifi_event_sta_connected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__connected__t/#public-attributes","title":"Public Attributes","text":"Type Name     wifi_auth_mode_t authmode    uint8_t bssid    uint8_t channel    uint8_t ssid    uint8_t ssid_len"},{"location":"ltapi/structwifi__event__sta__connected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_CONNECTED event </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-authmode","title":"variable authmode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_connected_t::authmode;\n</code></pre> <p>authentication mode used by AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-bssid","title":"variable bssid","text":"<pre><code>uint8_t wifi_event_sta_connected_t::bssid[6];\n</code></pre> <p>BSSID of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-channel","title":"variable channel","text":"<pre><code>uint8_t wifi_event_sta_connected_t::channel;\n</code></pre> <p>channel of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_connected_t::ssid[32];\n</code></pre> <p>SSID of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-ssid_len","title":"variable ssid_len","text":"<pre><code>uint8_t wifi_event_sta_connected_t::ssid_len;\n</code></pre> <p>SSID length of connected AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/","title":"Struct wifi_event_sta_disconnected_t","text":"<p>ClassList &gt; wifi_event_sta_disconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t bssid    uint8_t reason    uint8_t ssid    uint8_t ssid_len"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_DISCONNECTED event </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-bssid","title":"variable bssid","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::bssid[6];\n</code></pre> <p>BSSID of disconnected AP </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-reason","title":"variable reason","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::reason;\n</code></pre> <p>reason of disconnection </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::ssid[32];\n</code></pre> <p>SSID of disconnected AP </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-ssid_len","title":"variable ssid_len","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::ssid_len;\n</code></pre> <p>SSID length of disconnected AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/","title":"Struct wifi_event_sta_scan_done_t","text":"<p>ClassList &gt; wifi_event_sta_scan_done_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t number    uint8_t scan_id    uint32_t status"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_SCAN_DONE event </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-number","title":"variable number","text":"<pre><code>uint8_t wifi_event_sta_scan_done_t::number;\n</code></pre> <p>number of scan results </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-scan_id","title":"variable scan_id","text":"<pre><code>uint8_t wifi_event_sta_scan_done_t::scan_id;\n</code></pre> <p>scan sequence number, used for block scan </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-status","title":"variable status","text":"<pre><code>uint32_t wifi_event_sta_scan_done_t::status;\n</code></pre> <p>status of scanning APs: 0 - success, 1 - failure </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/","title":"Struct wifi_event_sta_wps_er_pin_t","text":"<p>ClassList &gt; wifi_event_sta_wps_er_pin_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t pin_code"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#variable-pin_code","title":"variable pin_code","text":"<pre><code>uint8_t wifi_event_sta_wps_er_pin_t::pin_code[8];\n</code></pre> <p>PIN code of station in enrollee mode </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/","title":"Struct wifi_event_sta_wps_er_success_t","text":"<p>ClassList &gt; wifi_event_sta_wps_er_success_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#public-attributes","title":"Public Attributes","text":"Type Name     struct wifi_event_sta_wps_er_success_t::@0 ap_cred    uint8_t ap_cred_cnt    uint8_t passphrase    uint8_t ssid"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ap_cred","title":"variable ap_cred","text":"<pre><code>struct wifi_event_sta_wps_er_success_t::@0 wifi_event_sta_wps_er_success_t::ap_cred[MAX_WPS_AP_CRED];\n</code></pre> <p>All AP credentials received from WPS handshake </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ap_cred_cnt","title":"variable ap_cred_cnt","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::ap_cred_cnt;\n</code></pre> <p>Number of AP credentials received </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-passphrase","title":"variable passphrase","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::passphrase[MAX_PASSPHRASE_LEN];\n</code></pre> <p>Passphrase for the AP </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::ssid[MAX_SSID_LEN];\n</code></pre> <p>SSID of AP </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/","title":"Struct wifi_ftm_report_entry_t","text":"<p>ClassList &gt; wifi_ftm_report_entry_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t dlog_token    int8_t rssi    uint32_t rtt    uint64_t t1    uint64_t t2    uint64_t t3    uint64_t t4"},{"location":"ltapi/structwifi__ftm__report__entry__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-dlog_token","title":"variable dlog_token","text":"<pre><code>uint8_t wifi_ftm_report_entry_t::dlog_token;\n</code></pre> <p>Dialog Token of the FTM frame </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-rssi","title":"variable rssi","text":"<pre><code>int8_t wifi_ftm_report_entry_t::rssi;\n</code></pre> <p>RSSI of the FTM frame received </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-rtt","title":"variable rtt","text":"<pre><code>uint32_t wifi_ftm_report_entry_t::rtt;\n</code></pre> <p>Round Trip Time in pSec with a peer </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t1","title":"variable t1","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t1;\n</code></pre> <p>Time of departure of FTM frame from FTM Responder in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t2","title":"variable t2","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t2;\n</code></pre> <p>Time of arrival of FTM frame at FTM Initiator in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t3","title":"variable t3","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t3;\n</code></pre> <p>Time of departure of ACK from FTM Initiator in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t4","title":"variable t4","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t4;\n</code></pre> <p>Time of arrival of ACK at FTM Responder in pSec </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/dir_51d9c9f08f6806a0f97badf342e5b4d7/","title":"Dir cores","text":"<p>FileList &gt; cores</p>"},{"location":"ltapi/dir_51d9c9f08f6806a0f97badf342e5b4d7/#directories","title":"Directories","text":"Type Name     dir common      <p>The documentation for this class was generated from the following file <code>cores/</code></p>"},{"location":"ltapi/dir_061390acc221bc2d9c9cb2f4362dac1d/","title":"Dir cores/common","text":"<p>FileList &gt; common</p>"},{"location":"ltapi/dir_061390acc221bc2d9c9cb2f4362dac1d/#directories","title":"Directories","text":"Type Name     dir arduino    dir base      <p>The documentation for this class was generated from the following file <code>cores/common/</code></p>"},{"location":"ltapi/dir_b638d0c61cb610adbc247035a3e10d3e/","title":"Dir cores/common/arduino","text":"<p>FileList &gt; arduino</p>"},{"location":"ltapi/dir_b638d0c61cb610adbc247035a3e10d3e/#directories","title":"Directories","text":"Type Name     dir libraries    dir src      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/</code></p>"},{"location":"ltapi/dir_368b4a9ec74cf1c10b8199770b5e2c1b/","title":"Dir cores/common/arduino/libraries","text":"<p>FileList &gt; arduino &gt; libraries</p>"},{"location":"ltapi/dir_368b4a9ec74cf1c10b8199770b5e2c1b/#directories","title":"Directories","text":"Type Name     dir api    dir common    dir ext    dir inline      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/</code></p>"},{"location":"ltapi/dir_e15f2f53a75910fcd29e18d04ab3723d/","title":"Dir cores/common/arduino/libraries/api","text":"<p>FileList &gt; api</p>"},{"location":"ltapi/dir_e15f2f53a75910fcd29e18d04ab3723d/#directories","title":"Directories","text":"Type Name     dir Serial    dir SoftwareSerial    dir WiFi      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/</code></p>"},{"location":"ltapi/dir_5e75bcdb2ffaceb01f94db1177614a08/","title":"Dir cores/common/arduino/libraries/api/Serial","text":"<p>FileList &gt; api &gt; Serial</p>"},{"location":"ltapi/dir_5e75bcdb2ffaceb01f94db1177614a08/#files","title":"Files","text":"Type Name     file Serial.cpp    file Serial.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/Serial/</code></p>"},{"location":"ltapi/_serial_8cpp/","title":"File Serial.cpp","text":"<p>FileList &gt; api &gt; Serial &gt; Serial.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Serial.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/Serial/Serial.cpp</code></p>"},{"location":"ltapi/_serial_8cpp_source/","title":"File Serial.cpp","text":"<p>File List &gt; api &gt; Serial &gt; Serial.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-05-23. */\n\n#include \"Serial.h\"\n\nSerialClass::SerialClass(uint32_t port, pin_size_t rx, pin_size_t tx) {\n    this-&gt;port = port;\n    this-&gt;rx   = rx;\n    this-&gt;tx   = tx;\n    this-&gt;buf  = NULL;\n    this-&gt;data = NULL;\n}\n\n#if LT_AUTO_DOWNLOAD_REBOOT &amp;&amp; defined(LT_UART_ADR_PATTERN)\nstatic uint8_t adrState = 0;\nstatic uint8_t adrCmd[] = {LT_UART_ADR_PATTERN};\n\nvoid SerialClass::adrParse(uint8_t c) {\n    adrState = (adrState + 1) * (c == adrCmd[adrState]);\n    if (adrState == sizeof(adrCmd) / sizeof(uint8_t)) {\n        LT_I(\"Auto download mode: rebooting\");\n        LT.restartDownloadMode();\n    }\n}\n#endif\n\nint SerialClass::available() {\n    return this-&gt;buf ? this-&gt;buf-&gt;available() : 0;\n}\n\nint SerialClass::peek() {\n    return this-&gt;buf ? this-&gt;buf-&gt;peek() : -1;\n}\n\nint SerialClass::read() {\n    return this-&gt;buf ? this-&gt;buf-&gt;read_char() : -1;\n}\n</code></pre>"},{"location":"ltapi/_serial_8h/","title":"File Serial.h","text":"<p>FileList &gt; api &gt; Serial &gt; Serial.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/HardwareSerial.h&gt;</code></li> <li><code>#include &lt;api/RingBuffer.h&gt;</code></li> </ul>"},{"location":"ltapi/_serial_8h/#classes","title":"Classes","text":"Type Name     class SerialClass"},{"location":"ltapi/_serial_8h/#public-types","title":"Public Types","text":"Type Name     typedef RingBufferN&lt; LT_SERIAL_BUFFER_SIZE &gt; SerialRingBuffer"},{"location":"ltapi/_serial_8h/#macros","title":"Macros","text":"Type Name     define HAS_SERIAL_CLASS  1"},{"location":"ltapi/_serial_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_serial_8h/#typedef-serialringbuffer","title":"typedef SerialRingBuffer","text":"<pre><code>typedef RingBufferN&lt;LT_SERIAL_BUFFER_SIZE&gt; SerialRingBuffer;\n</code></pre>"},{"location":"ltapi/_serial_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_serial_8h/#define-has_serial_class","title":"define HAS_SERIAL_CLASS","text":"<pre><code>#define HAS_SERIAL_CLASS 1\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/Serial/Serial.h</code></p>"},{"location":"ltapi/_serial_8h_source/","title":"File Serial.h","text":"<p>File List &gt; api &gt; Serial &gt; Serial.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-23. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/HardwareSerial.h&gt;\n#include &lt;api/RingBuffer.h&gt;\n\nusing namespace arduino;\n\ntypedef RingBufferN&lt;LT_SERIAL_BUFFER_SIZE&gt; SerialRingBuffer;\n\nclass SerialClass : public HardwareSerial {\n  private:\n    uint32_t port;\n    pin_size_t rx;\n    pin_size_t tx;\n\n  public:\n    void *data;\n\n  private:\n    SerialRingBuffer *buf;\n    uint32_t baudrate;\n    uint16_t config;\n\n  public:\n    SerialClass(uint32_t port, pin_size_t rx = PIN_INVALID, pin_size_t tx = PIN_INVALID);\n\n    inline void begin(unsigned long baudrate) {\n        begin(baudrate, SERIAL_8N1);\n    }\n\n    inline void configure(unsigned long baudrate) {\n        configure(baudrate, SERIAL_8N1);\n    }\n\n    void begin(unsigned long baudrate, uint16_t config);\n    void configure(unsigned long baudrate, uint16_t config);\n    void end();\n    int available();\n    int peek();\n    int read();\n    void flush();\n    size_t write(uint8_t c);\n\n    operator bool() {\n        return !!buf;\n    }\n\n  public:\n#if LT_AUTO_DOWNLOAD_REBOOT\n    static void adrParse(uint8_t c);\n#endif\n\n    using Print::write;\n};\n\n#define HAS_SERIAL_CLASS 1\n</code></pre>"},{"location":"ltapi/dir_94e03dba73a2283a03d5afbcd7ac96fd/","title":"Dir cores/common/arduino/libraries/api/SoftwareSerial","text":"<p>FileList &gt; api &gt; SoftwareSerial</p>"},{"location":"ltapi/dir_94e03dba73a2283a03d5afbcd7ac96fd/#files","title":"Files","text":"Type Name     file SoftwareSerial.cpp    file SoftwareSerial.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/</code></p>"},{"location":"ltapi/_software_serial_8cpp/","title":"File SoftwareSerial.cpp","text":"<p>FileList &gt; api &gt; SoftwareSerial &gt; SoftwareSerial.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"SoftwareSerial.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/SoftwareSerial.cpp</code></p>"},{"location":"ltapi/_software_serial_8cpp_source/","title":"File SoftwareSerial.cpp","text":"<p>File List &gt; api &gt; SoftwareSerial &gt; SoftwareSerial.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-03. */\n\n#include \"SoftwareSerial.h\"\n\n#if LT_ARD_HAS_SOFTSERIAL\n\nSoftwareSerial::SoftwareSerial(pin_size_t receivePin, pin_size_t transmitPin, bool inverted) {\n    data.rx.buf = NULL;\n    data.tx.buf = NULL;\n    data.rx.pin = receivePin;\n    data.tx.pin = transmitPin;\n    data.invert = inverted == true;\n}\n\nint SoftwareSerial::available() {\n    return data.rx.buf-&gt;available();\n}\n\nint SoftwareSerial::peek() {\n    return data.rx.buf-&gt;peek();\n}\n\nint SoftwareSerial::read() {\n    return data.rx.buf-&gt;read_char();\n}\n\nvoid SoftwareSerial::flush() {\n    while (data.rx.buf-&gt;available()) {\n        yield();\n    }\n}\n\nsize_t SoftwareSerial::write(uint8_t c) {\n    while (data.tx.buf-&gt;isFull()) {\n        yield();\n    }\n    data.tx.buf-&gt;store_char(c);\n    if (data.tx.state == SS_IDLE) {\n        data.tx.state = SS_START;\n        this-&gt;startTx();\n    }\n    return 1;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_software_serial_8h/","title":"File SoftwareSerial.h","text":"<p>FileList &gt; api &gt; SoftwareSerial &gt; SoftwareSerial.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/HardwareSerial.h&gt;</code></li> <li><code>#include &lt;api/RingBuffer.h&gt;</code></li> </ul>"},{"location":"ltapi/_software_serial_8h/#classes","title":"Classes","text":"Type Name     struct SoftData    struct SoftSerial    class SoftwareSerial"},{"location":"ltapi/_software_serial_8h/#public-types","title":"Public Types","text":"Type Name     enum SoftState"},{"location":"ltapi/_software_serial_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_software_serial_8h/#enum-softstate","title":"enum SoftState","text":"<pre><code>enum SoftState {\n    SS_IDLE = 0,\n    SS_START,\n    SS_DATA0,\n    SS_DATA1,\n    SS_DATA2,\n    SS_DATA3,\n    SS_DATA4,\n    SS_DATA5,\n    SS_DATA6,\n    SS_DATA7,\n    SS_STOP,\n    SS_END\n};\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/SoftwareSerial/SoftwareSerial.h</code></p>"},{"location":"ltapi/_software_serial_8h_source/","title":"File SoftwareSerial.h","text":"<p>File List &gt; api &gt; SoftwareSerial &gt; SoftwareSerial.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-03. */\n\n#pragma once\n\n#if LT_ARD_HAS_SOFTSERIAL || DOXYGEN\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/HardwareSerial.h&gt;\n#include &lt;api/RingBuffer.h&gt;\n\nusing namespace arduino;\n\ntypedef enum {\n    SS_IDLE = 0,\n    SS_START,\n    SS_DATA0,\n    SS_DATA1,\n    SS_DATA2,\n    SS_DATA3,\n    SS_DATA4,\n    SS_DATA5,\n    SS_DATA6,\n    SS_DATA7,\n    SS_STOP,\n    SS_END,\n} SoftState;\n\ntypedef struct {\n    SoftState state;\n    SerialRingBuffer *buf;\n    uint8_t byte;\n    pin_size_t pin;\n    void *param;\n} SoftData;\n\ntypedef struct {\n    SoftData rx;\n    SoftData tx;\n    uint8_t invert;\n    void *param;\n} SoftSerial;\n\nclass SoftwareSerial : public HardwareSerial {\n  private:\n    SoftSerial data;\n    void *param;\n\n  public:\n    SoftwareSerial(pin_size_t receivePin, pin_size_t transmitPin, bool inverted = false);\n\n    inline void begin(unsigned long baudrate) {\n        begin(baudrate, SERIAL_8N1);\n    }\n\n    int available();\n    int peek();\n    int read();\n    void flush();\n    size_t write(uint8_t c);\n\n    operator bool() {\n        return data.rx.buf || data.tx.buf;\n    }\n\n  public: // Family needs to implement these methods only\n    void begin(unsigned long baudrate, uint16_t config);\n    void end();\n\n  private:\n    void startTx();\n    void endTx();\n\n    using Print::write;\n};\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_8a0a878499ba56a6674d17f5d719a3ab/","title":"Dir cores/common/arduino/libraries/api/WiFi","text":"<p>FileList &gt; api &gt; WiFi</p>"},{"location":"ltapi/dir_8a0a878499ba56a6674d17f5d719a3ab/#files","title":"Files","text":"Type Name     file WiFi.cpp    file WiFi.h    file WiFiAP.cpp    file WiFiEvents.cpp    file WiFiEvents.h    file WiFiGeneric.cpp    file WiFiSTA.cpp    file WiFiScan.cpp    file WiFiType.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/</code></p>"},{"location":"ltapi/_wi_fi_8cpp/","title":"File WiFi.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFi.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiClass WiFi    WiFiClass * pWiFi   = = NULL"},{"location":"ltapi/_wi_fi_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_wi_fi_8cpp/#variable-wifi","title":"variable WiFi","text":"<pre><code>WiFiClass WiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8cpp/#variable-pwifi","title":"variable pWiFi","text":"<pre><code>WiFiClass* pWiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFi.cpp</code></p>"},{"location":"ltapi/_wi_fi_8cpp_source/","title":"File WiFi.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFi.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nvoid WiFiClass::printDiag(Print &amp;dest) {\n    dest.print(\"Mode: \");\n    dest.println(WiFiModeText[getMode()]);\n\n    dest.print(\"Status: \");\n    dest.println(WiFiStatusText[status()]);\n\n    if (getMode() &amp; WIFI_MODE_STA) {\n        dest.println(\"-- Station --\");\n        dest.print(\"SSID: \");\n        if (isConnected()) {\n            dest.println(SSID());\n            dest.print(\"Channel: \");\n            dest.println(channel());\n            dest.print(\"BSSID: \");\n            dest.println(BSSIDstr());\n            dest.print(\"RSSI: \");\n            dest.println(RSSI());\n            dest.print(\"Encryption: \");\n            dest.println(WiFiAuthModeText[getEncryption()]);\n            dest.print(\"IP: \");\n            dest.println(localIP());\n            dest.print(\"MAC: \");\n            dest.println(macAddress());\n            dest.print(\"Hostname: \");\n            dest.println(getHostname());\n        } else {\n            dest.println(\"disconnected\");\n        }\n    }\n\n    if (getMode() &amp; WIFI_MODE_AP) {\n        dest.println(\"-- Access Point --\");\n        dest.print(\"SSID: \");\n        if (softAPSSID().length()) {\n            dest.println(softAPSSID());\n            dest.print(\"IP: \");\n            dest.println(softAPIP());\n            dest.print(\"MAC: \");\n            dest.println(softAPmacAddress());\n            dest.print(\"Hostname: \");\n            dest.println(softAPgetHostname());\n        } else {\n            dest.println(\"disconnected\");\n        }\n    }\n}\n\nbool WiFiClass::validate(const char *ssid, const char *passphrase) {\n    if (!ssid || *ssid == 0x00 || strlen(ssid) &gt; 32) {\n        LT_WM(WIFI, \"SSID not specified or too long\");\n        return false;\n    }\n    if (passphrase) {\n        uint16_t length = strlen(passphrase);\n        if (length &lt; 8) {\n            LT_WM(WIFI, \"Passphrase too short (%u)\", length);\n            return false;\n        }\n        if (length &gt; 63) {\n            LT_WM(WIFI, \"Passphrase too long (%u)\", length);\n            return false;\n        }\n    }\n    return true;\n}\n\n__attribute__((weak)) void WiFiClass::dataInitialize() {}\n\n__attribute__((weak)) void WiFiClass::dataFree() {}\n\nWiFiClass WiFi;\nWiFiClass *pWiFi = NULL;\n</code></pre>"},{"location":"ltapi/_wi_fi_8h/","title":"File WiFi.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFi.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;Events.h&gt;</code></li> <li><code>#include &lt;api/IPAddress.h&gt;</code></li> <li><code>#include &lt;api/IPv6Address.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"WiFiType.h\"</code></li> <li><code>#include &lt;WiFiClient.h&gt;</code></li> <li><code>#include &lt;WiFiClientSecure.h&gt;</code></li> <li><code>#include &lt;WiFiServer.h&gt;</code></li> <li><code>#include &lt;WiFiUdp.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_8h/#classes","title":"Classes","text":"Type Name     class WiFiClass"},{"location":"ltapi/_wi_fi_8h/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiClass WiFi    WiFiClass * pWiFi"},{"location":"ltapi/_wi_fi_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_wi_fi_8h/#variable-wifi","title":"variable WiFi","text":"<pre><code>WiFiClass WiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8h/#variable-pwifi","title":"variable pWiFi","text":"<pre><code>WiFiClass* pWiFi;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFi.h</code></p>"},{"location":"ltapi/_wi_fi_8h_source/","title":"File WiFi.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFi.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n WiFi.h - esp32 Wifi support.\n Based on WiFi.h from Arduino WiFi shield library.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;Events.h&gt;\n#include &lt;api/IPAddress.h&gt;\n#include &lt;api/IPv6Address.h&gt;\n#include &lt;vector&gt;\n\n#include \"WiFiType.h\"\n\n#include &lt;WiFiClient.h&gt;\n#include &lt;WiFiClientSecure.h&gt;\n#include &lt;WiFiServer.h&gt;\n#include &lt;WiFiUdp.h&gt;\n\nclass WiFiClass {\n  public:\n    // must be public for WiFiEvents &amp; WiFiScan static handlers\n    void *data;\n    WiFiScanData *scan = NULL;\n\n  public: /* WiFi.cpp */\n    WiFiClass();\n    ~WiFiClass();\n    void printDiag(Print &amp;dest);\n    bool validate(const char *ssid, const char *passphrase);\n    void dataInitialize();\n    void dataFree();\n\n  public: /* WiFiGeneric.cpp */\n    bool mode(WiFiMode mode);\n    bool modePriv(WiFiMode mode, WiFiModeAction sta, WiFiModeAction ap);\n    WiFiMode getMode();\n    WiFiStatus status();\n\n    bool enableSTA(bool enable);\n    bool enableAP(bool enable);\n\n    bool setSleep(bool enable);\n    bool getSleep();\n\n    bool setTxPower(int power);\n    int getTxPower();\n\n    int hostByName(const char *hostname, IPAddress &amp;aResult);\n    IPAddress hostByName(const char *hostname);\n\n    static IPAddress calculateNetworkID(IPAddress ip, IPAddress subnet);\n    static IPAddress calculateBroadcast(IPAddress ip, IPAddress subnet);\n    static uint8_t calculateSubnetCIDR(IPAddress subnetMask);\n    static String macToString(uint8_t *mac);\n\n    static void resetNetworkInfo(WiFiNetworkInfo &amp;info);\n\n  private: /* WiFiGeneric.cpp */\n    bool restoreSTAConfig(const WiFiNetworkInfo &amp;info);\n    bool restoreAPConfig(const WiFiNetworkInfo &amp;info);\n\n  protected: /* WiFiEvents.cpp */\n    static std::vector&lt;EventHandler&gt; handlers;\n\n  public: /* WiFiEvents.cpp */\n    uint16_t onEvent(EventCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    uint16_t onEvent(EventFuncCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    uint16_t onEvent(EventSysCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    void removeEvent(EventCb callback, EventId eventId);\n    void removeEvent(EventSysCb callback, EventId eventId);\n    void removeEvent(uint16_t id);\n    static void postEvent(EventId eventId, EventInfo eventInfo);\n\n  public: /* WiFiSTA.cpp */\n    WiFiStatus begin(\n        const char *ssid,\n        const char *passphrase = NULL,\n        int32_t channel        = 0,\n        const uint8_t *bssid   = NULL,\n        bool connect           = true\n    );\n    WiFiStatus begin(\n        char *ssid,\n        char *passphrase     = NULL,\n        int32_t channel      = 0,\n        const uint8_t *bssid = NULL,\n        bool connect         = true\n    );\n\n    bool config(\n        IPAddress localIP,\n        IPAddress gateway,\n        IPAddress subnet,\n        IPAddress dns1 = (uint32_t)0x00000000,\n        IPAddress dns2 = (uint32_t)0x00000000\n    );\n\n    bool reconnect(const uint8_t *bssid = NULL);\n    bool disconnect(bool wifiOff = false);\n\n    bool isConnected();\n\n    bool setAutoReconnect(bool autoReconnect);\n    bool getAutoReconnect();\n\n    WiFiStatus waitForConnectResult(unsigned long timeout);\n\n    IPAddress localIP();\n    uint8_t *macAddress(uint8_t *mac);\n    String macAddress();\n    IPAddress subnetMask();\n    IPAddress gatewayIP();\n    IPAddress dnsIP(uint8_t dns_no = 0);\n    IPAddress broadcastIP();\n    IPAddress networkID();\n    uint8_t subnetCIDR();\n    bool enableIpV6();\n    IPv6Address localIPv6();\n    std::vector&lt;IPv6Address&gt; allLocalIPv6();\n\n    const char *getHostname();\n    bool setHostname(const char *hostname);\n    bool setMacAddress(const uint8_t *mac);\n\n    inline bool hostname(const String &amp;aHostname) {\n        return setHostname(aHostname.c_str());\n    }\n\n    const String SSID();\n    const String psk();\n    uint8_t *BSSID();\n    String BSSIDstr();\n    int32_t channel();\n    int8_t RSSI();\n    WiFiAuthMode getEncryption();\n\n  public: /* WiFiScan.cpp */\n    int16_t scanNetworks(\n        bool async               = false,\n        bool showHidden          = false,\n        bool passive             = false,\n        uint32_t maxMsPerChannel = 300,\n        uint8_t channel          = 0\n    );\n    bool getNetworkInfo(\n        uint8_t networkItem,\n        String &amp;ssid,\n        WiFiAuthMode &amp;encryptionType,\n        int32_t &amp;RSSI,\n        uint8_t *&amp;BSSID,\n        int32_t &amp;channel\n    );\n\n    int16_t scanComplete();\n    uint8_t scanAlloc(uint8_t count);\n    void scanInit();\n    void scanDelete();\n\n    String SSID(uint8_t networkItem);\n    WiFiAuthMode encryptionType(uint8_t networkItem);\n    int32_t RSSI(uint8_t networkItem);\n    uint8_t *BSSID(uint8_t networkItem);\n    String BSSIDstr(uint8_t networkItem);\n    int32_t channel(uint8_t networkItem);\n\n  public: /* WiFiAP.cpp */\n    bool softAP(\n        const char *ssid,\n        const char *passphrase = NULL,\n        int channel            = 1,\n        bool ssidHidden        = false,\n        int maxClients         = 4\n    );\n    bool softAPConfig(IPAddress localIP, IPAddress gateway, IPAddress subnet);\n    bool softAPdisconnect(bool wifiOff = false);\n\n    uint8_t softAPgetStationNum();\n\n    IPAddress softAPIP();\n    IPAddress softAPBroadcastIP();\n    IPAddress softAPNetworkID();\n    uint8_t softAPSubnetCIDR();\n    IPAddress softAPSubnetMask();\n    bool softAPenableIpV6();\n    IPv6Address softAPIPv6();\n    const char *softAPgetHostname();\n    bool softAPsetHostname(const char *hostname);\n    uint8_t *softAPmacAddress(uint8_t *mac);\n    String softAPmacAddress(void);\n    const String softAPSSID(void);\n};\n\nextern WiFiClass WiFi;\nextern WiFiClass *pWiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_a_p_8cpp/","title":"File WiFiAP.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiAP.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_a_p_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_a_p_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_a_p_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiAP.cpp</code></p>"},{"location":"ltapi/_wi_fi_a_p_8cpp_source/","title":"File WiFiAP.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiAP.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nIPAddress WiFiClass::softAPBroadcastIP() {\n    return calculateBroadcast(softAPIP(), softAPSubnetMask());\n}\n\nIPAddress WiFiClass::softAPNetworkID() {\n    return calculateNetworkID(softAPIP(), softAPSubnetMask());\n}\n\nuint8_t WiFiClass::softAPSubnetCIDR() {\n    return calculateSubnetCIDR(softAPSubnetMask());\n}\n\n__attribute__((weak)) bool WiFiClass::softAPenableIpV6() {\n    return false;\n}\n\n__attribute__((weak)) IPv6Address WiFiClass::softAPIPv6() {\n    return IPv6Address();\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8cpp/","title":"File WiFiEvents.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiEvents.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.cpp</code></p>"},{"location":"ltapi/_wi_fi_events_8cpp_source/","title":"File WiFiEvents.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiEvents.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-17. */\n\n#include \"WiFi.h\"\n\nstd::vector&lt;EventHandler&gt; WiFiClass::handlers;\n\nuint16_t WiFiClass::onEvent(EventCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.cb      = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nuint16_t WiFiClass::onEvent(EventFuncCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.fcb     = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nuint16_t WiFiClass::onEvent(EventSysCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.scb     = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nvoid WiFiClass::removeEvent(EventCb callback, EventId eventId) {\n    if (!callback)\n        return;\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.cb == callback &amp;&amp; handler.eventId == eventId) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::removeEvent(EventSysCb callback, EventId eventId) {\n    if (!callback)\n        return;\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.scb == callback &amp;&amp; handler.eventId == eventId) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::removeEvent(uint16_t id) {\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.id == id) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::postEvent(EventId eventId, EventInfo eventInfo) {\n    for (auto handler : handlers) {\n        if (handler.eventId != ARDUINO_EVENT_MAX &amp;&amp; handler.eventId != eventId)\n            continue;\n        if (handler.cb) {\n            handler.cb(eventId);\n        } else if (handler.fcb) {\n            handler.fcb(eventId, eventInfo);\n        } else if (handler.scb) {\n            Event_t event = {\n                .event_id   = eventId,\n                .event_info = eventInfo,\n            };\n            handler.scb(&amp;event);\n        }\n    }\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/","title":"File WiFiEvents.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiEvents.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiType.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_events_8h/#classes","title":"Classes","text":"Type Name     struct esp_netif_ip6_info_t IPV6 IP address information.   struct esp_netif_ip_info_t    struct ip_event_ap_staipassigned_t    struct ip_event_got_ip6_t    struct ip_event_got_ip_t    struct wifi_event_action_tx_status_t    struct wifi_event_ap_probe_req_rx_t    struct wifi_event_ap_staconnected_t    struct wifi_event_ap_stadisconnected_t    struct wifi_event_ftm_report_t    struct wifi_event_roc_done_t    struct wifi_event_sta_authmode_change_t    struct wifi_event_sta_connected_t    struct wifi_event_sta_disconnected_t    struct wifi_event_sta_scan_done_t    struct wifi_event_sta_wps_er_pin_t    struct wifi_event_sta_wps_er_success_t    struct wifi_ftm_report_entry_t"},{"location":"ltapi/_wi_fi_events_8h/#public-types","title":"Public Types","text":"Type Name     enum wifi_event_sta_wps_fail_reason_t    enum wifi_ftm_status_t FTM operation status types."},{"location":"ltapi/_wi_fi_events_8h/#macros","title":"Macros","text":"Type Name     define MAX_PASSPHRASE_LEN  64   define MAX_SSID_LEN  32   define MAX_WPS_AP_CRED  3   define WIFI_STATIS_ALL  (-1)   define WIFI_STATIS_BUFFER  (1 &lt;&lt; 0)   define WIFI_STATIS_DIAG  (1 &lt;&lt; 3)   define WIFI_STATIS_HW  (1 &lt;&lt; 2)   define WIFI_STATIS_PS  (1 &lt;&lt; 4)   define WIFI_STATIS_RXTX  (1 &lt;&lt; 1)"},{"location":"ltapi/_wi_fi_events_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_wi_fi_events_8h/#enum-wifi_event_sta_wps_fail_reason_t","title":"enum wifi_event_sta_wps_fail_reason_t","text":"<pre><code>enum wifi_event_sta_wps_fail_reason_t {\n    WPS_FAIL_REASON_NORMAL = 0,\n    WPS_FAIL_REASON_RECV_M2D,\n    WPS_FAIL_REASON_MAX\n};\n</code></pre> <p>Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event </p>"},{"location":"ltapi/_wi_fi_events_8h/#enum-wifi_ftm_status_t","title":"enum wifi_ftm_status_t","text":"<pre><code>enum wifi_ftm_status_t {\n    FTM_STATUS_SUCCESS = 0,\n    FTM_STATUS_UNSUPPORTED,\n    FTM_STATUS_CONF_REJECTED,\n    FTM_STATUS_NO_RESPONSE,\n    FTM_STATUS_FAIL\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_wi_fi_events_8h/#define-max_passphrase_len","title":"define MAX_PASSPHRASE_LEN","text":"<pre><code>#define MAX_PASSPHRASE_LEN 64\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-max_ssid_len","title":"define MAX_SSID_LEN","text":"<pre><code>#define MAX_SSID_LEN 32\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-max_wps_ap_cred","title":"define MAX_WPS_AP_CRED","text":"<pre><code>#define MAX_WPS_AP_CRED 3\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_all","title":"define WIFI_STATIS_ALL","text":"<pre><code>#define WIFI_STATIS_ALL (-1)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_buffer","title":"define WIFI_STATIS_BUFFER","text":"<pre><code>#define WIFI_STATIS_BUFFER (1 &lt;&lt; 0)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_diag","title":"define WIFI_STATIS_DIAG","text":"<pre><code>#define WIFI_STATIS_DIAG (1 &lt;&lt; 3)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_hw","title":"define WIFI_STATIS_HW","text":"<pre><code>#define WIFI_STATIS_HW (1 &lt;&lt; 2)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_ps","title":"define WIFI_STATIS_PS","text":"<pre><code>#define WIFI_STATIS_PS (1 &lt;&lt; 4)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_rxtx","title":"define WIFI_STATIS_RXTX","text":"<pre><code>#define WIFI_STATIS_RXTX (1 &lt;&lt; 1)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/_wi_fi_events_8h_source/","title":"File WiFiEvents.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiEvents.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#pragma once\n\n#include \"WiFiType.h\"\n\ntypedef struct {\n    uint32_t status; \n    uint8_t number;  \n    uint8_t scan_id; \n} wifi_event_sta_scan_done_t;\n\ntypedef struct {\n    uint8_t ssid[32];          \n    uint8_t ssid_len;          \n    uint8_t bssid[6];          \n    uint8_t channel;           \n    wifi_auth_mode_t authmode; \n} wifi_event_sta_connected_t;\n\ntypedef struct {\n    uint8_t ssid[32]; \n    uint8_t ssid_len; \n    uint8_t bssid[6]; \n    uint8_t reason;   \n} wifi_event_sta_disconnected_t;\n\ntypedef struct {\n    wifi_auth_mode_t old_mode; \n    wifi_auth_mode_t new_mode; \n} wifi_event_sta_authmode_change_t;\n\ntypedef struct {\n    uint8_t pin_code[8]; \n} wifi_event_sta_wps_er_pin_t;\n\ntypedef enum {\n    WPS_FAIL_REASON_NORMAL = 0, \n    WPS_FAIL_REASON_RECV_M2D,   \n    WPS_FAIL_REASON_MAX\n} wifi_event_sta_wps_fail_reason_t;\n\n#define MAX_SSID_LEN       32\n#define MAX_PASSPHRASE_LEN 64\n#define MAX_WPS_AP_CRED    3\n\ntypedef struct {\n    uint8_t ap_cred_cnt; \n    struct {\n        uint8_t ssid[MAX_SSID_LEN];             \n        uint8_t passphrase[MAX_PASSPHRASE_LEN]; \n    } ap_cred[MAX_WPS_AP_CRED];                 \n} wifi_event_sta_wps_er_success_t;\n\ntypedef struct {\n    uint8_t mac[6];     \n    uint8_t aid;        \n    bool is_mesh_child; \n} wifi_event_ap_staconnected_t;\n\ntypedef struct {\n    uint8_t mac[6];     \n    uint8_t aid;        \n    bool is_mesh_child; \n} wifi_event_ap_stadisconnected_t;\n\ntypedef struct {\n    int rssi;       \n    uint8_t mac[6]; \n} wifi_event_ap_probe_req_rx_t;\n\ntypedef enum {\n    FTM_STATUS_SUCCESS = 0,   \n    FTM_STATUS_UNSUPPORTED,   \n    FTM_STATUS_CONF_REJECTED, \n    FTM_STATUS_NO_RESPONSE,   \n    FTM_STATUS_FAIL,          \n} wifi_ftm_status_t;\n\ntypedef struct {\n    uint8_t dlog_token; \n    int8_t rssi;        \n    uint32_t rtt;       \n    uint64_t t1;        \n    uint64_t t2;        \n    uint64_t t3;        \n    uint64_t t4;        \n} wifi_ftm_report_entry_t;\n\ntypedef struct {\n    uint8_t peer_mac[6];      \n    wifi_ftm_status_t status; \n    uint32_t rtt_raw;         \n    uint32_t rtt_est;         \n    uint32_t dist_est;        \n    wifi_ftm_report_entry_t\n        *ftm_report_data;           \n    uint8_t ftm_report_num_entries; \n} wifi_event_ftm_report_t;\n\n#define WIFI_STATIS_BUFFER (1 &lt;&lt; 0)\n#define WIFI_STATIS_RXTX   (1 &lt;&lt; 1)\n#define WIFI_STATIS_HW     (1 &lt;&lt; 2)\n#define WIFI_STATIS_DIAG   (1 &lt;&lt; 3)\n#define WIFI_STATIS_PS     (1 &lt;&lt; 4)\n#define WIFI_STATIS_ALL    (-1)\n\ntypedef struct {\n    int ifx;          \n    uint32_t context; \n    uint8_t da[6];    \n    uint8_t status;   \n} wifi_event_action_tx_status_t;\n\ntypedef struct {\n    uint32_t context; \n} wifi_event_roc_done_t;\n\ntypedef struct {\n    esp_ip4_addr_t ip;      \n    esp_ip4_addr_t netmask; \n    esp_ip4_addr_t gw;      \n} esp_netif_ip_info_t;\n\ntypedef struct {\n    esp_ip6_addr_t ip; \n} esp_netif_ip6_info_t;\n\ntypedef struct {\n    int if_index;                \n    void *esp_netif;             \n    esp_netif_ip_info_t ip_info; \n    bool ip_changed;             \n} ip_event_got_ip_t;\n\ntypedef struct {\n    int if_index;                  \n    void *esp_netif;               \n    esp_netif_ip6_info_t ip6_info; \n    int ip_index;                  \n} ip_event_got_ip6_t;\n\ntypedef struct {\n    esp_ip4_addr_t ip; \n} ip_event_ap_staipassigned_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_generic_8cpp/","title":"File WiFiGeneric.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiGeneric.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_generic_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_generic_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_generic_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiGeneric.cpp</code></p>"},{"location":"ltapi/_wi_fi_generic_8cpp_source/","title":"File WiFiGeneric.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiGeneric.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#endif\n\nbool WiFiClass::mode(WiFiMode mode) {\n    // store a pointer to WiFi for WiFiEvents.cpp\n    pWiFi = this;\n\n    WiFiMode currentMode = getMode();\n    LT_DM(WIFI, \"Mode changing %s -&gt; %s\", WiFiModeText[currentMode], WiFiModeText[mode]);\n    if (mode == currentMode)\n        return true;\n\n    // get mode changes as 0/1\n    WiFiModeAction sta = WiFiModeAction((mode &amp; WIFI_MODE_STA) != (currentMode &amp; WIFI_MODE_STA));\n    WiFiModeAction ap  = WiFiModeAction((mode &amp; WIFI_MODE_AP) != (currentMode &amp; WIFI_MODE_AP));\n    // change 0/1 to 1/2\n    sta = WiFiModeAction(sta + sta * !!(mode &amp; WIFI_MODE_STA));\n    ap  = WiFiModeAction(ap + ap * !!(mode &amp; WIFI_MODE_AP));\n    // initialize data structures if wifi is enabled\n    if (mode)\n        dataInitialize();\n    // actually change the mode\n    LT_HEAP_I();\n    if (!modePriv(mode, sta, ap))\n        return false;\n    if (getMode() != mode) {\n        LT_WM(WIFI, \"Mode changed to %d (requested %d)\", getMode(), mode);\n    }\n    return true;\n}\n\nbool WiFiClass::enableSTA(bool enable) {\n    WiFiMode currentMode = getMode();\n    if (((currentMode &amp; WIFI_MODE_STA) != 0) != enable) {\n        return mode((WiFiMode)(currentMode ^ WIFI_MODE_STA));\n    }\n    return true;\n}\n\nbool WiFiClass::enableAP(bool enable) {\n    WiFiMode currentMode = getMode();\n    if (((currentMode &amp; WIFI_MODE_AP) != 0) != enable) {\n        return mode((WiFiMode)(currentMode ^ WIFI_MODE_AP));\n    }\n    return true;\n}\n\n__attribute__((weak)) bool WiFiClass::setSleep(bool enable) {\n    return false;\n}\n\n__attribute__((weak)) bool WiFiClass::getSleep() {\n    return false;\n}\n\n__attribute__((weak)) bool WiFiClass::setTxPower(int power) {\n    return false;\n}\n\n__attribute__((weak)) int WiFiClass::getTxPower() {\n    return 0;\n}\n\nint WiFiClass::hostByName(const char *hostname, IPAddress &amp;aResult) {\n    aResult = hostByName(hostname);\n    return true;\n}\n\nIPAddress WiFiClass::calculateNetworkID(IPAddress ip, IPAddress subnet) {\n    IPAddress networkID;\n\n    for (size_t i = 0; i &lt; 4; i++)\n        networkID[i] = subnet[i] &amp; ip[i];\n\n    return networkID;\n}\n\nIPAddress WiFiClass::calculateBroadcast(IPAddress ip, IPAddress subnet) {\n    IPAddress broadcastIp;\n\n    for (int i = 0; i &lt; 4; i++)\n        broadcastIp[i] = ~subnet[i] | ip[i];\n\n    return broadcastIp;\n}\n\nuint8_t WiFiClass::calculateSubnetCIDR(IPAddress subnetMask) {\n    uint8_t CIDR = 0;\n\n    for (uint8_t i = 0; i &lt; 4; i++) {\n        if (subnetMask[i] == 0x80) // 128\n            CIDR += 1;\n        else if (subnetMask[i] == 0xC0) // 192\n            CIDR += 2;\n        else if (subnetMask[i] == 0xE0) // 224\n            CIDR += 3;\n        else if (subnetMask[i] == 0xF0) // 242\n            CIDR += 4;\n        else if (subnetMask[i] == 0xF8) // 248\n            CIDR += 5;\n        else if (subnetMask[i] == 0xFC) // 252\n            CIDR += 6;\n        else if (subnetMask[i] == 0xFE) // 254\n            CIDR += 7;\n        else if (subnetMask[i] == 0xFF) // 255\n            CIDR += 8;\n    }\n\n    return CIDR;\n}\n\nString WiFiClass::macToString(uint8_t *mac) {\n    char macStr[18]; // 6*2 + 5*':' + '\\0'\n    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    return macStr;\n}\n\nvoid WiFiClass::resetNetworkInfo(WiFiNetworkInfo &amp;info) {\n    LT_VM(WIFI, \"Resetting network info: %s\", info.ssid);\n    free(info.ssid);\n    free(info.password);\n    free(info.bssid);\n    // wipe the structure, except IP addresses\n    memset(&amp;info, 0x00, sizeof(WiFiNetworkInfo) - 5 * sizeof(uint32_t));\n}\n\nbool WiFiClass::restoreSTAConfig(const WiFiNetworkInfo &amp;info) {\n    LT_DM(WIFI, \"Restoring %s config: %s\", \"STA\", info.ssid);\n    if (!info.ssid)\n        return false;\n    if (info.localIP) {\n        LT_DM(WIFI, \"Restoring STA IP config\");\n        if (!config(info.localIP, info.gateway, info.subnet, info.dns1, info.dns2))\n            return false;\n    }\n    return begin(info.ssid, info.password, info.channel, info.bssid);\n}\n\nbool WiFiClass::restoreAPConfig(const WiFiNetworkInfo &amp;info) {\n    LT_DM(WIFI, \"Restoring %s config: %s\", \"AP\", info.ssid);\n    if (!info.ssid)\n        return false;\n    if (info.localIP) {\n        LT_DM(WIFI, \"Restoring AP IP config\");\n        if (!softAPConfig(info.localIP, info.gateway, info.subnet))\n            return false;\n    }\n    return softAP(info.ssid, info.password, info.channel, info.ssidHidden);\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/","title":"File WiFiSTA.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiSTA.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiSTA.cpp</code></p>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp_source/","title":"File WiFiSTA.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiSTA.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nWiFiStatus WiFiClass::begin(char *ssid, char *passphrase, int32_t channel, const uint8_t *bssid, bool connect) {\n    return begin((const char *)ssid, (const char *)passphrase, channel, bssid, connect);\n}\n\nbool WiFiClass::isConnected() {\n    return status() == WL_CONNECTED;\n}\n\nWiFiStatus WiFiClass::waitForConnectResult(unsigned long timeout) {\n    if ((getMode() &amp; WIFI_MODE_STA) == 0) {\n        return WL_DISCONNECTED;\n    }\n    unsigned long start = millis();\n    while ((!status() || status() &gt;= WL_DISCONNECTED) &amp;&amp; (millis() - start) &lt; timeout) {\n        delay(100);\n    }\n    return status();\n}\n\nString WiFiClass::macAddress(void) {\n    uint8_t mac[6];\n    macAddress(mac);\n    return macToString(mac);\n}\n\nIPAddress WiFiClass::networkID() {\n    return calculateNetworkID(gatewayIP(), subnetMask());\n}\n\nuint8_t WiFiClass::subnetCIDR() {\n    return calculateSubnetCIDR(subnetMask());\n}\n\nString WiFiClass::BSSIDstr() {\n    return macToString(BSSID());\n}\n\n__attribute__((weak)) bool WiFiClass::enableIpV6() {\n    return false;\n}\n\n__attribute__((weak)) IPv6Address WiFiClass::localIPv6() {\n    return {};\n}\n\n__attribute__((weak)) std::vector&lt;IPv6Address&gt; WiFiClass::allLocalIPv6() {\n    return {};\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_scan_8cpp/","title":"File WiFiScan.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiScan.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiScan.cpp</code></p>"},{"location":"ltapi/_wi_fi_scan_8cpp_source/","title":"File WiFiScan.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiScan.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nbool WiFiClass::getNetworkInfo(\n    uint8_t networkItem,\n    String &amp;ssid,\n    WiFiAuthMode &amp;encType,\n    int32_t &amp;rssi,\n    uint8_t *&amp;bssid,\n    int32_t &amp;channel\n) {\n    ssid    = SSID(networkItem);\n    encType = encryptionType(networkItem);\n    rssi    = RSSI(networkItem);\n    bssid   = BSSID(networkItem);\n    channel = this-&gt;channel(networkItem);\n    return true;\n}\n\nint16_t WiFiClass::scanComplete() {\n    if (!scan)\n        return 0;\n    if (scan-&gt;running)\n        return WIFI_SCAN_RUNNING;\n    return scan-&gt;count;\n}\n\nvoid WiFiClass::scanInit() {\n    if (scan)\n        return;\n    scan = (WiFiScanData *)calloc(1, sizeof(WiFiScanData));\n}\n\nvoid WiFiClass::scanDelete() {\n    if (!scan)\n        return;\n    for (uint8_t i = 0; i &lt; scan-&gt;count; i++) {\n        free(scan-&gt;ap[i].ssid);\n    }\n    free(scan-&gt;ap);\n    free(scan);\n    scan = NULL;\n}\n\nuint8_t WiFiClass::scanAlloc(uint8_t count) {\n    if ((!scan-&gt;ap) || (count &gt; scan-&gt;count)) {\n        auto newMem = (WiFiScanAP *)realloc(scan-&gt;ap, count * sizeof(WiFiScanAP));\n        if (!newMem) {\n            return scan-&gt;count;\n        }\n        scan-&gt;ap = newMem;\n    }\n    if (!scan-&gt;ap) {\n        scan-&gt;count = 0;\n        return 0;\n    }\n    if (count &gt; scan-&gt;count) {\n        // clear only new entries\n        memset(scan-&gt;ap + scan-&gt;count, 0, sizeof(WiFiScanAP) * (count - scan-&gt;count));\n    }\n    scan-&gt;count = count;\n    return count;\n}\n\nString WiFiClass::SSID(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return \"\";\n    return scan-&gt;ap[networkItem].ssid;\n}\n\nWiFiAuthMode WiFiClass::encryptionType(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return WIFI_AUTH_INVALID;\n    return scan-&gt;ap[networkItem].auth;\n}\n\nint32_t WiFiClass::RSSI(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return 0;\n    return scan-&gt;ap[networkItem].rssi;\n}\n\nuint8_t *WiFiClass::BSSID(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return NULL;\n    return scan-&gt;ap[networkItem].bssid.addr;\n}\n\nString WiFiClass::BSSIDstr(uint8_t networkItem) {\n    return macToString(BSSID(networkItem));\n}\n\nint32_t WiFiClass::channel(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return 0;\n    return scan-&gt;ap[networkItem].channel;\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/","title":"File WiFiType.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiType.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_type_8h/#classes","title":"Classes","text":"Type Name     struct WiFiMacAddr    struct WiFiNetworkInfo    struct WiFiScanAP    struct WiFiScanData    struct esp_ip4_addr    struct esp_ip6_addr"},{"location":"ltapi/_wi_fi_type_8h/#public-types","title":"Public Types","text":"Type Name     enum WiFiModeAction    typedef struct esp_ip4_addr esp_ip4_addr_t    typedef struct esp_ip6_addr esp_ip6_addr_t    enum wifi_auth_mode_t    enum wifi_err_reason_t    enum wifi_mode_t    enum wl_status_t"},{"location":"ltapi/_wi_fi_type_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const char * WiFiAuthModeText   = = {   \"Open\",    \"WEP\",    \"WPA PSK\",    \"WPA2 PSK\",    \"WPA/WPA2 PSK\",    \"WPA2 EAP\",    \"WPA3 PSK\",    \"WPA2/WPA3 PSK\",    \"WAPI PSK\",    \"WPA\",    \"WPA2\",    \"Auto\",    }    const char * WiFiModeText   = = {\"NULL\", \"STA\", \"AP\", \"AP+STA\"}   const char * WiFiStatusText   = = {   \"Idle\",    \"No SSID\",    \"Scan Completed\",    \"Connected\",    \"Connect failed\",    \"Connection lost\",    \"Disconnected\",    }"},{"location":"ltapi/_wi_fi_type_8h/#macros","title":"Macros","text":"Type Name     define WIFI_AP  WIFI_MODE_AP   define WIFI_AP_STA  WIFI_MODE_APSTA   define WIFI_OFF  WIFI_MODE_NULL   define WIFI_SCAN_FAILED  (-2)   define WIFI_SCAN_RUNNING  (-1)   define WIFI_STA  WIFI_MODE_STA   define WiFiAuthMode  wifi_auth_mode_t   define WiFiEventId_t  uint16_t   define WiFiEventInfo_t arduino_event_info_t   define WiFiEvent_t  arduino_event_id_t   define WiFiMode  wifi_mode_t   define WiFiMode_t  wifi_mode_t   define WiFiStatus  wl_status_t"},{"location":"ltapi/_wi_fi_type_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_wi_fi_type_8h/#enum-wifimodeaction","title":"enum WiFiModeAction","text":"<pre><code>enum WiFiModeAction {\n    WLMODE_NONE = 0,\n    WLMODE_DISABLE = 1,\n    WLMODE_ENABLE = 2\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#typedef-esp_ip4_addr_t","title":"typedef esp_ip4_addr_t","text":"<pre><code>typedef struct esp_ip4_addr esp_ip4_addr_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#typedef-esp_ip6_addr_t","title":"typedef esp_ip6_addr_t","text":"<pre><code>typedef struct esp_ip6_addr esp_ip6_addr_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_auth_mode_t","title":"enum wifi_auth_mode_t","text":"<pre><code>enum wifi_auth_mode_t {\n    WIFI_AUTH_OPEN = 0,\n    WIFI_AUTH_WEP,\n    WIFI_AUTH_WPA_PSK,\n    WIFI_AUTH_WPA2_PSK,\n    WIFI_AUTH_WPA_WPA2_PSK,\n    WIFI_AUTH_WPA2_ENTERPRISE,\n    WIFI_AUTH_WPA3_PSK,\n    WIFI_AUTH_WPA2_WPA3_PSK,\n    WIFI_AUTH_WAPI_PSK,\n    WIFI_AUTH_WPA,\n    WIFI_AUTH_WPA2,\n    WIFI_AUTH_AUTO = 200,\n    WIFI_AUTH_INVALID = 255,\n    WIFI_AUTH_MAX\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_err_reason_t","title":"enum wifi_err_reason_t","text":"<pre><code>enum wifi_err_reason_t {\n    WIFI_REASON_UNSPECIFIED = 1,\n    WIFI_REASON_AUTH_EXPIRE = 2,\n    WIFI_REASON_AUTH_LEAVE = 3,\n    WIFI_REASON_ASSOC_EXPIRE = 4,\n    WIFI_REASON_ASSOC_TOOMANY = 5,\n    WIFI_REASON_NOT_AUTHED = 6,\n    WIFI_REASON_NOT_ASSOCED = 7,\n    WIFI_REASON_ASSOC_LEAVE = 8,\n    WIFI_REASON_ASSOC_NOT_AUTHED = 9,\n    WIFI_REASON_DISASSOC_PWRCAP_BAD = 10,\n    WIFI_REASON_DISASSOC_SUPCHAN_BAD = 11,\n    WIFI_REASON_BSS_TRANSITION_DISASSOC = 12,\n    WIFI_REASON_IE_INVALID = 13,\n    WIFI_REASON_MIC_FAILURE = 14,\n    WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,\n    WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,\n    WIFI_REASON_IE_IN_4WAY_DIFFERS = 17,\n    WIFI_REASON_GROUP_CIPHER_INVALID = 18,\n    WIFI_REASON_PAIRWISE_CIPHER_INVALID = 19,\n    WIFI_REASON_AKMP_INVALID = 20,\n    WIFI_REASON_UNSUPP_RSN_IE_VERSION = 21,\n    WIFI_REASON_INVALID_RSN_IE_CAP = 22,\n    WIFI_REASON_802_1X_AUTH_FAILED = 23,\n    WIFI_REASON_CIPHER_SUITE_REJECTED = 24,\n    WIFI_REASON_INVALID_PMKID = 53,\n    WIFI_REASON_BEACON_TIMEOUT = 200,\n    WIFI_REASON_NO_AP_FOUND = 201,\n    WIFI_REASON_AUTH_FAIL = 202,\n    WIFI_REASON_ASSOC_FAIL = 203,\n    WIFI_REASON_HANDSHAKE_TIMEOUT = 204,\n    WIFI_REASON_CONNECTION_FAIL = 205,\n    WIFI_REASON_AP_TSF_RESET = 206,\n    WIFI_REASON_ROAMING = 207\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_mode_t","title":"enum wifi_mode_t","text":"<pre><code>enum wifi_mode_t {\n    WIFI_MODE_NULL = 0,\n    WIFI_MODE_STA,\n    WIFI_MODE_AP,\n    WIFI_MODE_APSTA,\n    WIFI_MODE_MAX\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wl_status_t","title":"enum wl_status_t","text":"<pre><code>enum wl_status_t {\n    WL_NO_SHIELD = 255,\n    WL_IDLE_STATUS = 0,\n    WL_NO_SSID_AVAIL = 1,\n    WL_SCAN_COMPLETED = 2,\n    WL_CONNECTED = 3,\n    WL_CONNECT_FAILED = 4,\n    WL_CONNECTION_LOST = 5,\n    WL_DISCONNECTED = 6\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/_wi_fi_type_8h/#variable-wifiauthmodetext","title":"variable WiFiAuthModeText","text":"<pre><code>const char* WiFiAuthModeText[];\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#variable-wifimodetext","title":"variable WiFiModeText","text":"<pre><code>const char* WiFiModeText[];\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#variable-wifistatustext","title":"variable WiFiStatusText","text":"<pre><code>const char* WiFiStatusText[];\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_ap","title":"define WIFI_AP","text":"<pre><code>#define WIFI_AP WIFI_MODE_AP\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_ap_sta","title":"define WIFI_AP_STA","text":"<pre><code>#define WIFI_AP_STA WIFI_MODE_APSTA\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_off","title":"define WIFI_OFF","text":"<pre><code>#define WIFI_OFF WIFI_MODE_NULL\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_scan_failed","title":"define WIFI_SCAN_FAILED","text":"<pre><code>#define WIFI_SCAN_FAILED (-2)\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_scan_running","title":"define WIFI_SCAN_RUNNING","text":"<pre><code>#define WIFI_SCAN_RUNNING (-1)\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_sta","title":"define WIFI_STA","text":"<pre><code>#define WIFI_STA WIFI_MODE_STA\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifiauthmode","title":"define WiFiAuthMode","text":"<pre><code>#define WiFiAuthMode wifi_auth_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifieventid_t","title":"define WiFiEventId_t","text":"<pre><code>#define WiFiEventId_t uint16_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifieventinfo_t","title":"define WiFiEventInfo_t","text":"<pre><code>#define WiFiEventInfo_t arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifievent_t","title":"define WiFiEvent_t","text":"<pre><code>#define WiFiEvent_t arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifimode","title":"define WiFiMode","text":"<pre><code>#define WiFiMode wifi_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifimode_t","title":"define WiFiMode_t","text":"<pre><code>#define WiFiMode_t wifi_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifistatus","title":"define WiFiStatus","text":"<pre><code>#define WiFiStatus wl_status_t\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/_wi_fi_type_8h_source/","title":"File WiFiType.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiType.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n ESP8266WiFiType.h - esp8266 Wifi support.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n Reworked by Markus Sattler, December 2015\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#define WIFI_SCAN_RUNNING (-1)\n#define WIFI_SCAN_FAILED  (-2)\n\n#define WiFiMode_t   wifi_mode_t\n#define WiFiMode     wifi_mode_t\n#define WiFiStatus   wl_status_t\n#define WiFiAuthMode wifi_auth_mode_t\n\n#define WIFI_OFF    WIFI_MODE_NULL\n#define WIFI_STA    WIFI_MODE_STA\n#define WIFI_AP     WIFI_MODE_AP\n#define WIFI_AP_STA WIFI_MODE_APSTA\n\n#define WiFiEvent_t     arduino_event_id_t\n#define WiFiEventInfo_t arduino_event_info_t\n#define WiFiEventId_t   uint16_t\n\ntypedef struct {\n    uint8_t addr[6];\n} WiFiMacAddr;\n\nstruct esp_ip6_addr {\n    uint32_t addr[4];\n    uint8_t zone;\n};\n\nstruct esp_ip4_addr {\n    uint32_t addr;\n};\n\ntypedef struct esp_ip4_addr esp_ip4_addr_t;\ntypedef struct esp_ip6_addr esp_ip6_addr_t;\n\ntypedef enum {\n    WIFI_MODE_NULL = 0, \n    WIFI_MODE_STA,      \n    WIFI_MODE_AP,       \n    WIFI_MODE_APSTA,    \n    WIFI_MODE_MAX\n} wifi_mode_t;\n\ntypedef enum {\n    WL_NO_SHIELD       = 255, // for compatibility with WiFi Shield library\n    WL_IDLE_STATUS     = 0,\n    WL_NO_SSID_AVAIL   = 1,\n    WL_SCAN_COMPLETED  = 2,\n    WL_CONNECTED       = 3,\n    WL_CONNECT_FAILED  = 4,\n    WL_CONNECTION_LOST = 5,\n    WL_DISCONNECTED    = 6,\n} wl_status_t;\n\ntypedef enum {\n    WIFI_AUTH_OPEN = 0,        \n    WIFI_AUTH_WEP,             \n    WIFI_AUTH_WPA_PSK,         \n    WIFI_AUTH_WPA2_PSK,        \n    WIFI_AUTH_WPA_WPA2_PSK,    \n    WIFI_AUTH_WPA2_ENTERPRISE, \n    WIFI_AUTH_WPA3_PSK,        \n    WIFI_AUTH_WPA2_WPA3_PSK,   \n    WIFI_AUTH_WAPI_PSK,        \n    WIFI_AUTH_WPA,\n    WIFI_AUTH_WPA2,\n    WIFI_AUTH_AUTO    = 200,\n    WIFI_AUTH_INVALID = 255,\n    WIFI_AUTH_MAX\n} wifi_auth_mode_t;\n\ntypedef enum {\n    WIFI_REASON_UNSPECIFIED              = 1,\n    WIFI_REASON_AUTH_EXPIRE              = 2,\n    WIFI_REASON_AUTH_LEAVE               = 3,\n    WIFI_REASON_ASSOC_EXPIRE             = 4,\n    WIFI_REASON_ASSOC_TOOMANY            = 5,\n    WIFI_REASON_NOT_AUTHED               = 6,\n    WIFI_REASON_NOT_ASSOCED              = 7,\n    WIFI_REASON_ASSOC_LEAVE              = 8,\n    WIFI_REASON_ASSOC_NOT_AUTHED         = 9,\n    WIFI_REASON_DISASSOC_PWRCAP_BAD      = 10,\n    WIFI_REASON_DISASSOC_SUPCHAN_BAD     = 11,\n    WIFI_REASON_BSS_TRANSITION_DISASSOC  = 12,\n    WIFI_REASON_IE_INVALID               = 13,\n    WIFI_REASON_MIC_FAILURE              = 14,\n    WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT   = 15,\n    WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,\n    WIFI_REASON_IE_IN_4WAY_DIFFERS       = 17,\n    WIFI_REASON_GROUP_CIPHER_INVALID     = 18,\n    WIFI_REASON_PAIRWISE_CIPHER_INVALID  = 19,\n    WIFI_REASON_AKMP_INVALID             = 20,\n    WIFI_REASON_UNSUPP_RSN_IE_VERSION    = 21,\n    WIFI_REASON_INVALID_RSN_IE_CAP       = 22,\n    WIFI_REASON_802_1X_AUTH_FAILED       = 23,\n    WIFI_REASON_CIPHER_SUITE_REJECTED    = 24,\n    WIFI_REASON_INVALID_PMKID            = 53,\n    WIFI_REASON_BEACON_TIMEOUT           = 200,\n    WIFI_REASON_NO_AP_FOUND              = 201,\n    WIFI_REASON_AUTH_FAIL                = 202,\n    WIFI_REASON_ASSOC_FAIL               = 203,\n    WIFI_REASON_HANDSHAKE_TIMEOUT        = 204,\n    WIFI_REASON_CONNECTION_FAIL          = 205,\n    WIFI_REASON_AP_TSF_RESET             = 206,\n    WIFI_REASON_ROAMING                  = 207,\n} wifi_err_reason_t;\n\ntypedef struct {\n    char *ssid;\n    char *password;\n    uint8_t *bssid;\n    bool ssidHidden;\n    int channel;\n    int auth;\n    uint32_t localIP;\n    uint32_t subnet;\n    uint32_t gateway;\n    uint32_t dns1;\n    uint32_t dns2;\n} WiFiNetworkInfo;\n\ntypedef struct {\n    char *ssid;\n    WiFiAuthMode auth;\n    int32_t rssi;\n    WiFiMacAddr bssid;\n    int32_t channel;\n} WiFiScanAP;\n\ntypedef struct {\n    bool running          = false;\n    unsigned long timeout = 0;\n    uint8_t count         = 0;\n    WiFiScanAP *ap        = NULL;\n} WiFiScanData;\n\ntypedef enum {\n    WLMODE_NONE    = 0,\n    WLMODE_DISABLE = 1,\n    WLMODE_ENABLE  = 2,\n} WiFiModeAction;\n\nstatic const char *WiFiModeText[]   = {\"NULL\", \"STA\", \"AP\", \"AP+STA\"};\nstatic const char *WiFiStatusText[] = {\n    \"Idle\",\n    \"No SSID\",\n    \"Scan Completed\",\n    \"Connected\",\n    \"Connect failed\",\n    \"Connection lost\",\n    \"Disconnected\",\n};\nstatic const char *WiFiAuthModeText[] = {\n    \"Open\",\n    \"WEP\",\n    \"WPA PSK\",\n    \"WPA2 PSK\",\n    \"WPA/WPA2 PSK\",\n    \"WPA2 EAP\",\n    \"WPA3 PSK\",\n    \"WPA2/WPA3 PSK\",\n    \"WAPI PSK\",\n    \"WPA\",\n    \"WPA2\",\n    \"Auto\",\n};\n</code></pre>"},{"location":"ltapi/dir_fbd007664e1d3c6800f6de85378c1012/","title":"Dir cores/common/arduino/libraries/common","text":"<p>FileList &gt; arduino &gt; libraries &gt; common</p>"},{"location":"ltapi/dir_fbd007664e1d3c6800f6de85378c1012/#directories","title":"Directories","text":"Type Name     dir FS    dir IPv6Address    dir MD5    dir Preferences    dir Update    dir WiFiClient    dir WiFiServer    dir WiFiUdp    dir mDNS      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/</code></p>"},{"location":"ltapi/dir_20c0973793fbdc84288fa19008185bd9/","title":"Dir cores/common/arduino/libraries/common/FS","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; FS</p>"},{"location":"ltapi/dir_20c0973793fbdc84288fa19008185bd9/#files","title":"Files","text":"Type Name     file FS.cpp    file FS.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/</code></p>"},{"location":"ltapi/_f_s_8cpp/","title":"File FS.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; FS &gt; FS.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FS.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.cpp</code></p>"},{"location":"ltapi/_f_s_8cpp_source/","title":"File FS.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; FS &gt; FS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n FS.cpp - file system wrapper\n Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"FS.h\"\n\nusing namespace fs;\n\nsize_t File::write(uint8_t c) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;write(&amp;c, 1);\n}\n\ntime_t File::getLastWrite() {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;getLastWrite();\n}\n\nsize_t File::write(const uint8_t *buf, size_t size) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;write(buf, size);\n}\n\nint File::available() {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;size() - _p-&gt;position();\n}\n\nint File::read() {\n    if (!*this) {\n        return -1;\n    }\n    uint8_t result;\n    if (_p-&gt;read(&amp;result, 1) != 1) {\n        return -1;\n    }\n    return result;\n}\n\nsize_t File::read(uint8_t *buf, size_t size) {\n    if (!*this) {\n        return -1;\n    }\n    return _p-&gt;read(buf, size);\n}\n\nint File::peek() {\n    if (!*this) {\n        return -1;\n    }\n    size_t curPos = _p-&gt;position();\n    int result    = read();\n    seek(curPos, SeekSet);\n    return result;\n}\n\nvoid File::flush() {\n    if (!*this) {\n        return;\n    }\n    _p-&gt;flush();\n}\n\nbool File::seek(uint32_t pos, SeekMode mode) {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;seek(pos, mode);\n}\n\nsize_t File::position() const {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;position();\n}\n\nsize_t File::size() const {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;size();\n}\n\nbool File::setBufferSize(size_t size) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;setBufferSize(size);\n}\n\nvoid File::close() {\n    if (_p) {\n        _p-&gt;close();\n        _p = nullptr;\n    }\n}\n\nFile::operator bool() const {\n    return _p != nullptr &amp;&amp; *_p != false;\n}\n\nconst char *File::path() const {\n    if (!*this) {\n        return nullptr;\n    }\n    return _p-&gt;path();\n}\n\nconst char *File::name() const {\n    if (!*this) {\n        return nullptr;\n    }\n    return _p-&gt;name();\n}\n\n// to implement\nboolean File::isDirectory(void) {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;isDirectory();\n}\n\nFile File::openNextFile(const char *mode) {\n    if (!*this) {\n        return File();\n    }\n    return _p-&gt;openNextFile(mode);\n}\n\nvoid File::rewindDirectory(void) {\n    if (!*this) {\n        return;\n    }\n    _p-&gt;rewindDirectory();\n}\n\nFile FS::open(const String &amp;path, const char *mode, const bool create) {\n    return open(path.c_str(), mode, create);\n}\n\nFile FS::open(const char *path, const char *mode, const bool create) {\n    if (!_impl) {\n        return File();\n    }\n\n    return File(_impl-&gt;open(path, mode, create));\n}\n\nbool FS::exists(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;exists(path);\n}\n\nbool FS::exists(const String &amp;path) {\n    return exists(path.c_str());\n}\n\nbool FS::remove(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;remove(path);\n}\n\nbool FS::remove(const String &amp;path) {\n    return remove(path.c_str());\n}\n\nbool FS::rename(const char *pathFrom, const char *pathTo) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;rename(pathFrom, pathTo);\n}\n\nbool FS::rename(const String &amp;pathFrom, const String &amp;pathTo) {\n    return rename(pathFrom.c_str(), pathTo.c_str());\n}\n\nbool FS::mkdir(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;mkdir(path);\n}\n\nbool FS::mkdir(const String &amp;path) {\n    return mkdir(path.c_str());\n}\n\nbool FS::rmdir(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;rmdir(path);\n}\n\nbool FS::rmdir(const String &amp;path) {\n    return rmdir(path.c_str());\n}\n</code></pre>"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/","title":"File FS.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; FS &gt; FS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace fs"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#classes","title":"Classes","text":"Type Name     class FS    class FSImpl    class File    class FileImpl"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#macros","title":"Macros","text":"Type Name     define FILE_APPEND  \"a\"   define FILE_READ  \"r\"   define FILE_WRITE  \"w\""},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#define-file_append","title":"define FILE_APPEND","text":"<pre><code>#define FILE_APPEND \"a\"\n</code></pre>"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#define-file_read","title":"define FILE_READ","text":"<pre><code>#define FILE_READ \"r\"\n</code></pre>"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h/#define-file_write","title":"define FILE_WRITE","text":"<pre><code>#define FILE_WRITE \"w\"\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/FS/FS.h</code></p>"},{"location":"ltapi/libraries_2common_2_f_s_2_f_s_8h_source/","title":"File FS.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; FS &gt; FS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n FS.h - file system wrapper\n Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;memory&gt;\n\nnamespace fs {\n\n#define FILE_READ   \"r\"\n#define FILE_WRITE  \"w\"\n#define FILE_APPEND \"a\"\n\nclass File;\n\nclass FileImpl;\ntypedef std::shared_ptr&lt;FileImpl&gt; FileImplPtr;\nclass FSImpl;\ntypedef std::shared_ptr&lt;FSImpl&gt; FSImplPtr;\n\nenum SeekMode { SeekSet = 0, SeekCur = 1, SeekEnd = 2 };\n\nclass File : public Stream {\n  public:\n    File(FileImplPtr p = FileImplPtr()) : _p(p) {\n        _timeout = 0;\n    }\n\n    size_t write(uint8_t) override;\n    size_t write(const uint8_t *buf, size_t size) override;\n    int available() override;\n    int read() override;\n    int peek() override;\n    void flush() override;\n    size_t read(uint8_t *buf, size_t size);\n\n    size_t readBytes(char *buffer, size_t length) {\n        return read((uint8_t *)buffer, length);\n    }\n\n    bool seek(uint32_t pos, SeekMode mode);\n\n    bool seek(uint32_t pos) {\n        return seek(pos, SeekSet);\n    }\n\n    size_t position() const;\n    size_t size() const;\n    bool setBufferSize(size_t size);\n    void close();\n    operator bool() const;\n    time_t getLastWrite();\n    const char *path() const;\n    const char *name() const;\n\n    boolean isDirectory(void);\n    File openNextFile(const char *mode = FILE_READ);\n    void rewindDirectory(void);\n\n  protected:\n    FileImplPtr _p;\n};\n\nclass FileImpl {\n  public:\n    virtual ~FileImpl() {}\n\n    virtual size_t write(const uint8_t *buf, size_t size) = 0;\n    virtual size_t read(uint8_t *buf, size_t size)        = 0;\n    virtual void flush()                                  = 0;\n    virtual bool seek(uint32_t pos, SeekMode mode)        = 0;\n    virtual size_t position() const                       = 0;\n    virtual size_t size() const                           = 0;\n    virtual bool setBufferSize(size_t size)               = 0;\n    virtual void close()                                  = 0;\n    virtual time_t getLastWrite()                         = 0;\n    virtual const char *path() const                      = 0;\n    virtual const char *name() const                      = 0;\n    virtual boolean isDirectory(void)                     = 0;\n    virtual FileImplPtr openNextFile(const char *mode)    = 0;\n    virtual void rewindDirectory(void)                    = 0;\n    virtual operator bool()                               = 0;\n};\n\nclass FS {\n  public:\n    FS(FSImplPtr impl) : _impl(impl) {}\n\n    File open(const char *path, const char *mode = FILE_READ, const bool create = false);\n    File open(const String &amp;path, const char *mode = FILE_READ, const bool create = false);\n\n    bool exists(const char *path);\n    bool exists(const String &amp;path);\n\n    bool remove(const char *path);\n    bool remove(const String &amp;path);\n\n    bool rename(const char *pathFrom, const char *pathTo);\n    bool rename(const String &amp;pathFrom, const String &amp;pathTo);\n\n    bool mkdir(const char *path);\n    bool mkdir(const String &amp;path);\n\n    bool rmdir(const char *path);\n    bool rmdir(const String &amp;path);\n\n  protected:\n    FSImplPtr _impl;\n};\n\nclass FSImpl {\n  public:\n    FSImpl() {}\n\n    virtual ~FSImpl() {}\n\n    virtual FileImplPtr open(const char *path, const char *mode, const bool create) = 0;\n    virtual bool exists(const char *path)                                           = 0;\n    virtual bool rename(const char *pathFrom, const char *pathTo)                   = 0;\n    virtual bool remove(const char *path)                                           = 0;\n    virtual bool mkdir(const char *path)                                            = 0;\n    virtual bool rmdir(const char *path)                                            = 0;\n};\n\n} // namespace fs\n\n#ifndef FS_NO_GLOBALS\nusing fs::File;\nusing fs::FS;\nusing fs::SeekCur;\nusing fs::SeekEnd;\nusing fs::SeekMode;\nusing fs::SeekSet;\n#endif // FS_NO_GLOBALS\n</code></pre>"},{"location":"ltapi/dir_0e053ac3caf93ca4495f626616698305/","title":"Dir cores/common/arduino/libraries/common/IPv6Address","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; IPv6Address</p>"},{"location":"ltapi/dir_0e053ac3caf93ca4495f626616698305/#files","title":"Files","text":"Type Name     file IPv6Address.cpp    file IPv6Address.h"},{"location":"ltapi/dir_0e053ac3caf93ca4495f626616698305/#directories","title":"Directories","text":"Type Name     dir api      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/</code></p>"},{"location":"ltapi/_i_pv6_address_8cpp/","title":"File IPv6Address.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; IPv6Address &gt; IPv6Address.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"IPv6Address.h\"</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Print.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/IPv6Address.cpp</code></p>"},{"location":"ltapi/_i_pv6_address_8cpp_source/","title":"File IPv6Address.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; IPv6Address &gt; IPv6Address.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n IPv6Address.cpp - Base class that provides IPv6Address\n Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"IPv6Address.h\"\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Print.h&gt;\n\nIPv6Address::IPv6Address() {\n    memset(_address.bytes, 0, sizeof(_address.bytes));\n}\n\nIPv6Address::IPv6Address(const uint8_t *address) {\n    memcpy(_address.bytes, address, sizeof(_address.bytes));\n}\n\nIPv6Address::IPv6Address(const uint32_t *address) {\n    memcpy(_address.bytes, (const uint8_t *)address, sizeof(_address.bytes));\n}\n\nIPv6Address &amp;IPv6Address::operator=(const uint8_t *address) {\n    memcpy(_address.bytes, address, sizeof(_address.bytes));\n    return *this;\n}\n\nbool IPv6Address::operator==(const uint8_t *addr) const {\n    return memcmp(addr, _address.bytes, sizeof(_address.bytes)) == 0;\n}\n\nsize_t IPv6Address::printTo(Print &amp;p) const {\n    /* size_t n = 0;\n    for(int i = 0; i &lt; 16; i+=2) {\n        if(i){\n            n += p.print(':');\n        }\n        n += p.printf(\"%02x\", _address.bytes[i]);\n        n += p.printf(\"%02x\", _address.bytes[i+1]);\n\n    }\n    return n; */\n    return 0;\n}\n\nString IPv6Address::toString() const {\n    char szRet[40];\n    sprintf(\n        szRet,\n        \"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\",\n        _address.bytes[0],\n        _address.bytes[1],\n        _address.bytes[2],\n        _address.bytes[3],\n        _address.bytes[4],\n        _address.bytes[5],\n        _address.bytes[6],\n        _address.bytes[7],\n        _address.bytes[8],\n        _address.bytes[9],\n        _address.bytes[10],\n        _address.bytes[11],\n        _address.bytes[12],\n        _address.bytes[13],\n        _address.bytes[14],\n        _address.bytes[15]\n    );\n    return String(szRet);\n}\n\nbool IPv6Address::fromString(const char *address) {\n    // format 0011:2233:4455:6677:8899:aabb:ccdd:eeff\n    if (strlen(address) != 39) {\n        return false;\n    }\n    char *pos = (char *)address;\n    size_t i  = 0;\n    for (i = 0; i &lt; 16; i += 2) {\n        if (!sscanf(pos, \"%2hhx\", &amp;_address.bytes[i]) || !sscanf(pos + 2, \"%2hhx\", &amp;_address.bytes[i + 1])) {\n            return false;\n        }\n        pos += 5;\n    }\n    return true;\n}\n</code></pre>"},{"location":"ltapi/_i_pv6_address_8h/","title":"File IPv6Address.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; IPv6Address &gt; IPv6Address.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/Print.h&gt;</code></li> <li><code>#include &lt;api/String.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/_i_pv6_address_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace arduino"},{"location":"ltapi/_i_pv6_address_8h/#classes","title":"Classes","text":"Type Name     class IPv6Address      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/IPv6Address.h</code></p>"},{"location":"ltapi/_i_pv6_address_8h_source/","title":"File IPv6Address.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; IPv6Address &gt; IPv6Address.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n IPv6Address.h - Base class that provides IPv6Address\n Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;api/Print.h&gt;\n#include &lt;api/String.h&gt;\n#include &lt;stdint.h&gt;\n\n// A class to make it easier to handle and pass around IP addresses\n\nnamespace arduino {\n\nclass IPv6Address : public Printable {\n  private:\n    union {\n        uint8_t bytes[16]; // IPv4 address\n        uint32_t dword[4];\n    } _address;\n\n    // Access the raw byte array containing the address.  Because this returns a pointer\n    // to the internal structure rather than a copy of the address this function should only\n    // be used when you know that the usage of the returned uint8_t* will be transient and not\n    // stored.\n    uint8_t *raw_address() {\n        return _address.bytes;\n    }\n\n  public:\n    // Constructors\n    IPv6Address();\n    IPv6Address(const uint8_t *address);\n    IPv6Address(const uint32_t *address);\n\n    virtual ~IPv6Address() {}\n\n    bool fromString(const char *address);\n\n    bool fromString(const String &amp;address) {\n        return fromString(address.c_str());\n    }\n\n    operator const uint8_t *() const {\n        return _address.bytes;\n    }\n\n    operator const uint32_t *() const {\n        return _address.dword;\n    }\n\n    bool operator==(const IPv6Address &amp;addr) const {\n        return (_address.dword[0] == addr._address.dword[0]) &amp;&amp; (_address.dword[1] == addr._address.dword[1]) &amp;&amp;\n               (_address.dword[2] == addr._address.dword[2]) &amp;&amp; (_address.dword[3] == addr._address.dword[3]);\n    }\n\n    bool operator==(const uint8_t *addr) const;\n\n    // Overloaded index operator to allow getting and setting individual octets of the address\n    uint8_t operator[](int index) const {\n        return _address.bytes[index];\n    }\n\n    uint8_t &amp;operator[](int index) {\n        return _address.bytes[index];\n    }\n\n    // Overloaded copy operators to allow initialisation of IPv6Address objects from other types\n    IPv6Address &amp;operator=(const uint8_t *address);\n\n    // TODO implement printTo()\n    virtual size_t printTo(Print &amp;p) const;\n    String toString() const;\n\n    friend class UDP;\n    friend class Client;\n    friend class Server;\n};\n\n} // namespace arduino\n\nusing arduino::IPv6Address;\n</code></pre>"},{"location":"ltapi/dir_0a5433a1da7b2b93282c1ad1558c5479/","title":"Dir cores/common/arduino/libraries/common/IPv6Address/api","text":"<p>FileList &gt; api</p>"},{"location":"ltapi/dir_0a5433a1da7b2b93282c1ad1558c5479/#files","title":"Files","text":"Type Name     file IPv6Address.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/api/</code></p>"},{"location":"ltapi/api_2_i_pv6_address_8h/","title":"File IPv6Address.h","text":"<p>FileList &gt; api &gt; IPv6Address.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"../IPv6Address.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/IPv6Address/api/IPv6Address.h</code></p>"},{"location":"ltapi/api_2_i_pv6_address_8h_source/","title":"File IPv6Address.h","text":"<p>File List &gt; api &gt; IPv6Address.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include \"../IPv6Address.h\"\n</code></pre>"},{"location":"ltapi/dir_a154785acb726885f254a47f397a1398/","title":"Dir cores/common/arduino/libraries/common/MD5","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; MD5</p>"},{"location":"ltapi/dir_a154785acb726885f254a47f397a1398/#files","title":"Files","text":"Type Name     file MD5.h    file MD5HostapdImpl.h    file MD5MbedTLSImpl.cpp    file MD5MbedTLSImpl.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/</code></p>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/","title":"File MD5.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#public-types","title":"Public Types","text":"Type Name     typedef LT_MD5_CTX_T md5_context_t"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#public-functions","title":"Public Functions","text":"Type Name     void MD5Final (unsigned char digest, LT_MD5_CTX_T * context)    void MD5Init (LT_MD5_CTX_T * context)    void MD5Update (LT_MD5_CTX_T * context, const unsigned char * buf, unsigned len)"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  void"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#typedef-md5_context_t","title":"typedef md5_context_t","text":"<pre><code>typedef LT_MD5_CTX_T md5_context_t;\n</code></pre>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#function-md5final","title":"function MD5Final","text":"<pre><code>void MD5Final (\n    unsigned char digest,\n    LT_MD5_CTX_T * context\n) \n</code></pre>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#function-md5init","title":"function MD5Init","text":"<pre><code>void MD5Init (\n    LT_MD5_CTX_T * context\n) \n</code></pre>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#function-md5update","title":"function MD5Update","text":"<pre><code>void MD5Update (\n    LT_MD5_CTX_T * context,\n    const unsigned char * buf,\n    unsigned len\n) \n</code></pre>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T void\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5.h</code></p>"},{"location":"ltapi/libraries_2common_2_m_d5_2_m_d5_8h_source/","title":"File MD5.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-03. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n// available built-in implementations\n#if LT_ARD_MD5_MBEDTLS\n#include \"MD5MbedTLSImpl.h\"\n#endif\n#if LT_ARD_MD5_HOSTAPD\n#include \"MD5HostapdImpl.h\"\n#endif\n\n// common API\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#ifndef LT_MD5_CTX_T\n#define LT_MD5_CTX_T void\n#endif\n\n// for compatibility with ESP8266\ntypedef LT_MD5_CTX_T md5_context_t;\n\nvoid MD5Init(LT_MD5_CTX_T *context);\nvoid MD5Update(LT_MD5_CTX_T *context, const unsigned char *buf, unsigned len);\nvoid MD5Final(unsigned char digest[16], LT_MD5_CTX_T *context);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/_m_d5_hostapd_impl_8h/","title":"File MD5HostapdImpl.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5HostapdImpl.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_m_d5_hostapd_impl_8h/#classes","title":"Classes","text":"Type Name     struct MD5Context"},{"location":"ltapi/_m_d5_hostapd_impl_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  struct MD5Context"},{"location":"ltapi/_m_d5_hostapd_impl_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_m_d5_hostapd_impl_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T struct MD5Context\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5HostapdImpl.h</code></p>"},{"location":"ltapi/_m_d5_hostapd_impl_8h_source/","title":"File MD5HostapdImpl.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5HostapdImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-12. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct MD5Context {\n    unsigned long buf[4];\n    unsigned long bits[2];\n    unsigned char in[64];\n};\n\n#define LT_MD5_CTX_T struct MD5Context\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8cpp/","title":"File MD5MbedTLSImpl.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5MbedTLSImpl.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5MbedTLSImpl.cpp</code></p>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8cpp_source/","title":"File MD5MbedTLSImpl.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5MbedTLSImpl.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-11. */\n\n#if LT_ARD_MD5_MBEDTLS\n\nextern \"C\" {\n\n#include &lt;mbedtls/md5.h&gt;\n\nvoid MD5Init(mbedtls_md5_context *context) {\n    mbedtls_md5_init(context);\n    mbedtls_md5_starts(context);\n}\n\nvoid MD5Update(mbedtls_md5_context *context, const unsigned char *buf, unsigned len) {\n    mbedtls_md5_update(context, buf, len);\n}\n\nvoid MD5Final(unsigned char digest[16], mbedtls_md5_context *context) {\n    mbedtls_md5_finish(context, digest);\n}\n\n} // extern \"C\"\n\n#endif // LT_ARD_MD5_MBEDTLS\n</code></pre>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/","title":"File MD5MbedTLSImpl.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5MbedTLSImpl.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#classes","title":"Classes","text":"Type Name     struct mbedtls_md5_context"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T mbedtls_md5_context"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T mbedtls_md5_context\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/MD5/MD5MbedTLSImpl.h</code></p>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h_source/","title":"File MD5MbedTLSImpl.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; MD5 &gt; MD5MbedTLSImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-11. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    unsigned long total[2];   \n    unsigned long state[4];   \n    unsigned char buffer[64]; \n} mbedtls_md5_context;\n\n#define LT_MD5_CTX_T mbedtls_md5_context\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_e34b8d08ec2a080356b302de1e1a00cf/","title":"Dir cores/common/arduino/libraries/common/Preferences","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Preferences</p>"},{"location":"ltapi/dir_e34b8d08ec2a080356b302de1e1a00cf/#files","title":"Files","text":"Type Name     file Preferences.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Preferences/</code></p>"},{"location":"ltapi/_preferences_8h/","title":"File Preferences.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Preferences &gt; Preferences.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;api/String.h&gt;</code></li> </ul>"},{"location":"ltapi/_preferences_8h/#classes","title":"Classes","text":"Type Name     class IPreferences"},{"location":"ltapi/_preferences_8h/#public-types","title":"Public Types","text":"Type Name     enum PreferenceType"},{"location":"ltapi/_preferences_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_preferences_8h/#enum-preferencetype","title":"enum PreferenceType","text":"<pre><code>enum PreferenceType {\n    PT_I8,\n    PT_U8,\n    PT_I16,\n    PT_U16,\n    PT_I32,\n    PT_U32,\n    PT_I64,\n    PT_U64,\n    PT_STR,\n    PT_BLOB,\n    PT_INVALID\n};\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Preferences/Preferences.h</code></p>"},{"location":"ltapi/_preferences_8h_source/","title":"File Preferences.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; Preferences &gt; Preferences.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include &lt;api/String.h&gt;\n\ntypedef enum {\n    PT_I8,\n    PT_U8,\n    PT_I16,\n    PT_U16,\n    PT_I32,\n    PT_U32,\n    PT_I64,\n    PT_U64,\n    PT_STR,\n    PT_BLOB,\n    PT_INVALID,\n} PreferenceType;\n\nclass IPreferences {\n  public:\n    IPreferences() {}\n\n    ~IPreferences() {}\n\n    bool begin(const char *name, bool readOnly = false, const char *partition_label = NULL);\n    void end();\n\n    bool clear();\n    bool remove(const char *key);\n\n    size_t putChar(const char *key, int8_t value);\n    size_t putUChar(const char *key, uint8_t value);\n    size_t putShort(const char *key, int16_t value);\n    size_t putUShort(const char *key, uint16_t value);\n    size_t putInt(const char *key, int32_t value);\n    size_t putUInt(const char *key, uint32_t value);\n    size_t putLong(const char *key, int32_t value);\n    size_t putULong(const char *key, uint32_t value);\n    size_t putLong64(const char *key, int64_t value);\n    size_t putULong64(const char *key, uint64_t value);\n    size_t putFloat(const char *key, float_t value);\n    size_t putDouble(const char *key, double_t value);\n    size_t putBool(const char *key, bool value);\n    size_t putString(const char *key, const char *value);\n    size_t putString(const char *key, String value);\n    size_t putBytes(const char *key, const void *value, size_t len);\n\n    bool isKey(const char *key);\n    PreferenceType getType(const char *key);\n    int8_t getChar(const char *key, int8_t defaultValue = 0);\n    uint8_t getUChar(const char *key, uint8_t defaultValue = 0);\n    int16_t getShort(const char *key, int16_t defaultValue = 0);\n    uint16_t getUShort(const char *key, uint16_t defaultValue = 0);\n    int32_t getInt(const char *key, int32_t defaultValue = 0);\n    uint32_t getUInt(const char *key, uint32_t defaultValue = 0);\n    int32_t getLong(const char *key, int32_t defaultValue = 0);\n    uint32_t getULong(const char *key, uint32_t defaultValue = 0);\n    int64_t getLong64(const char *key, int64_t defaultValue = 0);\n    uint64_t getULong64(const char *key, uint64_t defaultValue = 0);\n    float_t getFloat(const char *key, float_t defaultValue = NAN);\n    double_t getDouble(const char *key, double_t defaultValue = NAN);\n    bool getBool(const char *key, bool defaultValue = false);\n    size_t getString(const char *key, char *value, size_t maxLen);\n    String getString(const char *key, String defaultValue = String());\n    size_t getBytesLength(const char *key);\n    size_t getBytes(const char *key, void *buf, size_t maxLen);\n    size_t freeEntries();\n};\n</code></pre>"},{"location":"ltapi/dir_540dc0be13f8284f6014d0451691d894/","title":"Dir cores/common/arduino/libraries/common/Update","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Update</p>"},{"location":"ltapi/dir_540dc0be13f8284f6014d0451691d894/#files","title":"Files","text":"Type Name     file Update.cpp    file Update.h    file UpdateUtil.cpp      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Update/</code></p>"},{"location":"ltapi/_update_8cpp/","title":"File Update.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Update &gt; Update.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Update.h\"</code></li> </ul>"},{"location":"ltapi/_update_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     UpdateClass Update"},{"location":"ltapi/_update_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const UpdateError errorMap   = = {   UPDATE_ERROR_OK,    UPDATE_ERROR_OK,    UPDATE_ERROR_MAGIC_BYTE,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_MAGIC_BYTE,    UPDATE_ERROR_NO_PARTITION,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_ERASE,    UPDATE_ERROR_WRITE,    UPDATE_ERROR_WRITE,    UPDATE_ERROR_WRITE,    UPDATE_ERROR_WRITE,    }"},{"location":"ltapi/_update_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_update_8cpp/#variable-update","title":"variable Update","text":"<pre><code>UpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/_update_8cpp/#variable-errormap","title":"variable errorMap","text":"<pre><code>const UpdateError errorMap[];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Update/Update.cpp</code></p>"},{"location":"ltapi/_update_8cpp_source/","title":"File Update.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; Update &gt; Update.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-29. */\n\n#include \"Update.h\"\n\nstatic const UpdateError errorMap[] = {\n    UPDATE_ERROR_OK,           /* UF2_ERR_OK - no error */\n    UPDATE_ERROR_OK,           /* UF2_ERR_IGNORE - block should be ignored */\n    UPDATE_ERROR_MAGIC_BYTE,   /* UF2_ERR_MAGIC - wrong magic numbers */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_FAMILY - family ID mismatched */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_NOT_HEADER - block is not a header */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_OTA_VER - unknown/invalid OTA format version */\n    UPDATE_ERROR_MAGIC_BYTE,   /* UF2_ERR_OTA_WRONG - no data for current OTA scheme */\n    UPDATE_ERROR_NO_PARTITION, /* UF2_ERR_PART_404 - no partition with that name */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_PART_INVALID - invalid partition info tag */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_PART_UNSET - attempted to write without target partition */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_DATA_TOO_LONG - data too long - tags won't fit */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_SEQ_MISMATCH - sequence number mismatched */\n    UPDATE_ERROR_ERASE,        /* UF2_ERR_ERASE_FAILED - erasing flash failed */\n    UPDATE_ERROR_WRITE,        /* UF2_ERR_WRITE_FAILED - writing to flash failed */\n    UPDATE_ERROR_WRITE,        /* UF2_ERR_WRITE_LENGTH - wrote fewer data than requested */\n    UPDATE_ERROR_WRITE,        /* UF2_ERR_WRITE_PROTECT - target area is write-protected */\n    UPDATE_ERROR_WRITE,        /* UF2_ERR_ALLOC_FAILED - dynamic memory allocation failed */\n};\n\nbool UpdateClass::begin(\n    size_t size,\n    int command,\n    __attribute__((unused)) int ledPin,\n    __attribute__((unused)) uint8_t ledOn,\n    __attribute__((unused)) const char *label\n) {\n#if !LT_HAS_OTA\n    LT_E(\"OTA is not yet supported on this chip!\");\n    this-&gt;errArd = UPDATE_ERROR_BAD_ARGUMENT;\n    return false;\n#endif\n    if (this-&gt;ctx) {\n        return false;\n    }\n    this-&gt;clearError();\n    if (size == 0) {\n        this-&gt;errArd = UPDATE_ERROR_SIZE;\n        return false;\n    }\n    if (command != U_FLASH) {\n        this-&gt;errArd = UPDATE_ERROR_BAD_ARGUMENT;\n        return false;\n    }\n    if (size == UPDATE_SIZE_UNKNOWN) {\n        size = 0;\n    }\n\n    this-&gt;ctx = static_cast&lt;lt_ota_ctx_t *&gt;(malloc(sizeof(lt_ota_ctx_t)));\n    lt_ota_begin(this-&gt;ctx, size);\n    this-&gt;ctx-&gt;callback       = reinterpret_cast&lt;void (*)(void *)&gt;(progressHandler);\n    this-&gt;ctx-&gt;callback_param = this;\n\n    this-&gt;md5Ctx = static_cast&lt;LT_MD5_CTX_T *&gt;(malloc(sizeof(LT_MD5_CTX_T)));\n    MD5Init(this-&gt;md5Ctx);\n\n    return true;\n}\n\nbool UpdateClass::end(bool evenIfRemaining) {\n    if (!this-&gt;ctx)\n        return false;\n\n    // update is running or finished; cleanup and end it\n    if (!isFinished() &amp;&amp; !evenIfRemaining)\n        // abort if not finished\n        this-&gt;errArd = UPDATE_ERROR_ABORT;\n\n    if (!this-&gt;md5Digest)\n        this-&gt;md5Digest = static_cast&lt;uint8_t *&gt;(malloc(16));\n    MD5Final(this-&gt;md5Digest, this-&gt;md5Ctx);\n\n    this-&gt;cleanup(/* clearError= */ evenIfRemaining);\n    return !this-&gt;hasError();\n}\n\nvoid UpdateClass::cleanup(bool clearError) {\n    if (!this-&gt;ctx)\n        return;\n\n    if (!lt_ota_end(this-&gt;ctx)) {\n        // activating firmware failed\n        this-&gt;errArd = UPDATE_ERROR_ACTIVATE;\n        this-&gt;errUf2 = UF2_ERR_OK;\n    } else if (this-&gt;md5Digest &amp;&amp; this-&gt;md5Expected &amp;&amp; memcmp(this-&gt;md5Digest, this-&gt;md5Expected, 16) != 0) {\n        // MD5 doesn't match\n        this-&gt;errArd = UPDATE_ERROR_MD5;\n        this-&gt;errUf2 = UF2_ERR_OK;\n    } else if (clearError) {\n        // successful finish and activation, clear error codes\n        this-&gt;clearError();\n    } else if (this-&gt;ctx-&gt;error &gt; UF2_ERR_IGNORE) {\n        // make error code based on UF2OTA code\n        this-&gt;errArd = errorMap[this-&gt;ctx-&gt;error];\n        this-&gt;errUf2 = this-&gt;ctx-&gt;error;\n    } else {\n        // only keep Arduino error code (set by the caller)\n        this-&gt;errUf2 = UF2_ERR_OK;\n    }\n\n#if LT_DEBUG_OTA\n    if (this-&gt;hasError())\n        this-&gt;printErrorContext();\n#endif\n\n    free(this-&gt;ctx);\n    this-&gt;ctx = nullptr;\n    free(this-&gt;md5Ctx);\n    this-&gt;md5Ctx = nullptr;\n    free(this-&gt;md5Digest);\n    this-&gt;md5Digest = nullptr;\n    free(this-&gt;md5Expected);\n    this-&gt;md5Expected = nullptr;\n}\n\nsize_t UpdateClass::write(const uint8_t *data, size_t len) {\n    if (!this-&gt;ctx)\n        return 0;\n\n    MD5Update(this-&gt;md5Ctx, data, len);\n    size_t written = lt_ota_write(ctx, data, len);\n    if (written != len)\n        this-&gt;cleanup(/* clearError= */ false);\n    return written;\n}\n\nsize_t UpdateClass::writeStream(Stream &amp;data) {\n    if (!this-&gt;ctx)\n        return 0;\n\n    size_t written    = 0;\n    uint32_t lastData = millis();\n    // loop until the update is complete\n    while (remaining()) {\n        // check stream availability\n        auto available = data.available();\n        if (available &lt;= 0) {\n            if (millis() - lastData &gt; UPDATE_TIMEOUT_MS) {\n                // waited for data too long; abort with error\n                this-&gt;errArd = UPDATE_ERROR_STREAM;\n                this-&gt;cleanup(/* clearError= */ false);\n                return written;\n            }\n            continue;\n        }\n        // available &gt; 0\n        lastData = millis();\n\n        // read data to fit in the remaining buffer space\n        auto bufSize = this-&gt;ctx-&gt;buf_pos - this-&gt;ctx-&gt;buf;\n        auto read    = data.readBytes(this-&gt;ctx-&gt;buf_pos, UF2_BLOCK_SIZE - bufSize);\n        // update MD5\n        MD5Update(this-&gt;md5Ctx, this-&gt;ctx-&gt;buf_pos, read);\n        // increment buffer writing head\n        this-&gt;ctx-&gt;buf_pos += read;\n        // process the block if complete\n        if (bufSize + read == UF2_BLOCK_SIZE)\n            lt_ota_write_block(this-&gt;ctx, reinterpret_cast&lt;uf2_block_t *&gt;(this-&gt;ctx-&gt;buf));\n        // abort on errors\n        if (hasError()) {\n            this-&gt;cleanup(/* clearError= */ false);\n            return written;\n        }\n        written += read;\n    }\n    return written;\n}\n\nUpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_8h/","title":"File Update.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Update &gt; Update.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;MD5.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;uf2ota/uf2ota.h&gt;</code></li> </ul>"},{"location":"ltapi/_update_8h/#classes","title":"Classes","text":"Type Name     class UpdateClass"},{"location":"ltapi/_update_8h/#public-types","title":"Public Types","text":"Type Name     enum UpdateCommand    enum UpdateError"},{"location":"ltapi/_update_8h/#public-attributes","title":"Public Attributes","text":"Type Name     UpdateClass Update"},{"location":"ltapi/_update_8h/#macros","title":"Macros","text":"Type Name     define ENCRYPTED_BLOCK_SIZE  16   define UPDATE_SIZE_UNKNOWN  0xFFFFFFFF   define UPDATE_TIMEOUT_MS  30 * 1000"},{"location":"ltapi/_update_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_update_8h/#enum-updatecommand","title":"enum UpdateCommand","text":"<pre><code>enum UpdateCommand {\n    U_FLASH = 0,\n    U_SPIFFS = 100,\n    U_AUTH = 200\n};\n</code></pre>"},{"location":"ltapi/_update_8h/#enum-updateerror","title":"enum UpdateError","text":"<pre><code>enum UpdateError {\n    UPDATE_ERROR_OK = 0,\n    UPDATE_ERROR_WRITE = 1,\n    UPDATE_ERROR_ERASE = 2,\n    UPDATE_ERROR_READ = 3,\n    UPDATE_ERROR_SPACE = 4,\n    UPDATE_ERROR_SIZE = 5,\n    UPDATE_ERROR_STREAM = 6,\n    UPDATE_ERROR_MD5 = 7,\n    UPDATE_ERROR_MAGIC_BYTE = 8,\n    UPDATE_ERROR_ACTIVATE = 9,\n    UPDATE_ERROR_NO_PARTITION = 10,\n    UPDATE_ERROR_BAD_ARGUMENT = 11,\n    UPDATE_ERROR_ABORT = 12\n};\n</code></pre>"},{"location":"ltapi/_update_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_update_8h/#variable-update","title":"variable Update","text":"<pre><code>UpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_update_8h/#define-encrypted_block_size","title":"define ENCRYPTED_BLOCK_SIZE","text":"<pre><code>#define ENCRYPTED_BLOCK_SIZE 16\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_size_unknown","title":"define UPDATE_SIZE_UNKNOWN","text":"<pre><code>#define UPDATE_SIZE_UNKNOWN 0xFFFFFFFF\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_timeout_ms","title":"define UPDATE_TIMEOUT_MS","text":"<pre><code>#define UPDATE_TIMEOUT_MS 30 * 1000\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Update/Update.h</code></p>"},{"location":"ltapi/_update_8h_source/","title":"File Update.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; Update &gt; Update.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;MD5.h&gt;\n#include &lt;functional&gt;\n#include &lt;uf2ota/uf2ota.h&gt;\n\ntypedef enum {\n    UPDATE_ERROR_OK           = 0,  \n    UPDATE_ERROR_WRITE        = 1,  \n    UPDATE_ERROR_ERASE        = 2,  \n    UPDATE_ERROR_READ         = 3,  \n    UPDATE_ERROR_SPACE        = 4,  \n    UPDATE_ERROR_SIZE         = 5,  \n    UPDATE_ERROR_STREAM       = 6,  \n    UPDATE_ERROR_MD5          = 7,  \n    UPDATE_ERROR_MAGIC_BYTE   = 8,  \n    UPDATE_ERROR_ACTIVATE     = 9,  \n    UPDATE_ERROR_NO_PARTITION = 10, \n    UPDATE_ERROR_BAD_ARGUMENT = 11, \n    UPDATE_ERROR_ABORT        = 12, \n} UpdateError;\n\ntypedef enum {\n    U_FLASH  = 0,\n    U_SPIFFS = 100,\n    U_AUTH   = 200,\n} UpdateCommand;\n\n#define UPDATE_SIZE_UNKNOWN 0xFFFFFFFF\n\n#define ENCRYPTED_BLOCK_SIZE 16\n\n#define UPDATE_TIMEOUT_MS 30 * 1000\n\nclass UpdateClass {\n  public:\n    typedef std::function&lt;void(size_t, size_t)&gt; THandlerFunction_Progress;\n\n  public: /* Update.cpp */\n    bool begin(\n        size_t size       = UPDATE_SIZE_UNKNOWN,\n        int command       = U_FLASH,\n        int ledPin        = -1,\n        uint8_t ledOn     = LOW,\n        const char *label = nullptr\n    );\n    bool end(bool evenIfRemaining = false);\n\n    size_t write(const uint8_t *data, size_t len);\n    size_t writeStream(Stream &amp;data);\n\n  private: /* Update.cpp */\n    void cleanup(bool clearError = false);\n\n  public: /* UpdateUtil.cpp */\n    UpdateClass &amp;onProgress(THandlerFunction_Progress handler);\n    static bool canRollBack();\n    static bool rollBack();\n    bool setMD5(const char *md5);\n    String md5String();\n    void md5(uint8_t *result);\n    uint16_t getErrorCode() const;\n    bool hasError() const;\n    void clearError();\n    const char *errorString() const;\n    void printError(Print &amp;out) const;\n\n  private: /* UpdateUtil.cpp */\n    static void progressHandler(UpdateClass *self);\n    void printErrorContext();\n\n  private:\n    lt_ota_ctx_t *ctx{nullptr};\n    uf2_err_t errUf2{UF2_ERR_OK};\n    UpdateError errArd{UPDATE_ERROR_OK};\n    THandlerFunction_Progress callback{nullptr};\n    LT_MD5_CTX_T *md5Ctx{nullptr};\n    uint8_t *md5Digest{nullptr};\n    uint8_t *md5Expected{nullptr};\n\n  public:\n    inline UpdateError getError() const {\n        return this-&gt;errArd;\n    }\n\n    inline uf2_err_t getUF2Error() const {\n        return this-&gt;ctx ? this-&gt;ctx-&gt;error : this-&gt;errUf2;\n    }\n\n    inline void abort() {\n        this-&gt;end();\n    }\n\n    inline bool isRunning() {\n        return this-&gt;ctx;\n    }\n\n    inline bool isFinished() {\n        return !(this-&gt;ctx &amp;&amp; this-&gt;ctx-&gt;bytes_written != this-&gt;ctx-&gt;bytes_total);\n    }\n\n    inline size_t size() {\n        return this-&gt;ctx ? this-&gt;ctx-&gt;bytes_total : 0;\n    }\n\n    inline size_t progress() {\n        return this-&gt;ctx ? this-&gt;ctx-&gt;bytes_written : 0;\n    }\n\n    inline size_t remaining() {\n        return this-&gt;size() - this-&gt;progress();\n    }\n\n    inline const char *getFirmwareName() {\n        if (this-&gt;ctx)\n            return this-&gt;ctx-&gt;info.fw_name;\n        return nullptr;\n    }\n\n    inline const char *getFirmwareVersion() {\n        if (this-&gt;ctx)\n            return this-&gt;ctx-&gt;info.fw_version;\n        return nullptr;\n    }\n\n    inline const char *getLibreTinyVersion() {\n        if (this-&gt;ctx)\n            return this-&gt;ctx-&gt;info.lt_version;\n        return nullptr;\n    }\n\n    inline const char *getBoardName() {\n        if (this-&gt;ctx)\n            return this-&gt;ctx-&gt;info.board;\n        return nullptr;\n    }\n};\n\nextern UpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_util_8cpp/","title":"File UpdateUtil.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; Update &gt; UpdateUtil.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Update.h\"</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;fal.h&gt;</code></li> </ul>"},{"location":"ltapi/_update_util_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const char * errArdText   = = {   nullptr,    nullptr,    nullptr,    nullptr,    nullptr,    \"Bad Size Given\",    \"Stream Read Timeout\",    \"MD5 Check Failed\",    nullptr,    \"Could Not Activate The Firmware\",    nullptr,    \"Bad Argument\",    \"Aborted\",    }    const char * errUf2Text   = = {   nullptr,    nullptr,    \"Bad Magic Number\",    \"Bad Family ID\",    \"Missing Header\",    \"Old OTA Format Found\",    \"Image Not Applicable\",    \"Partition Not Found\",    \"Partition Info Invalid\",    \"Partition Info Missing\",    \"Block Data Too Long\",    \"Bad Block Sequence Number\",    \"Flash Erase Failed\",    \"Flash Write Failed\",    \"Write Failed Length\",    \"Partition Write-Protected\",    \"Memory Alloc Failed\",    }    char errorStr"},{"location":"ltapi/_update_util_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/_update_util_8cpp/#variable-errardtext","title":"variable errArdText","text":"<pre><code>const char* errArdText[];\n</code></pre>"},{"location":"ltapi/_update_util_8cpp/#variable-erruf2text","title":"variable errUf2Text","text":"<pre><code>const char* errUf2Text[];\n</code></pre>"},{"location":"ltapi/_update_util_8cpp/#variable-errorstr","title":"variable errorStr","text":"<pre><code>char errorStr[14];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/Update/UpdateUtil.cpp</code></p>"},{"location":"ltapi/_update_util_8cpp_source/","title":"File UpdateUtil.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; Update &gt; UpdateUtil.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-30. */\n\n#include \"Update.h\"\n\n#include &lt;utility&gt;\n\nextern \"C\" {\n#include &lt;fal.h&gt;\n}\n\nstatic const char *errUf2Text[] = {\n    nullptr,                     // UF2_ERR_OK (0)\n    nullptr,                     // UF2_ERR_IGNORE (1)\n    \"Bad Magic Number\",          // UF2_ERR_MAGIC (2)\n    \"Bad Family ID\",             // UF2_ERR_FAMILY (3)\n    \"Missing Header\",            // UF2_ERR_NOT_HEADER (4)\n    \"Old OTA Format Found\",      // UF2_ERR_OTA_VER (5)\n    \"Image Not Applicable\",      // UF2_ERR_OTA_WRONG (6)\n    \"Partition Not Found\",       // UF2_ERR_PART_404 (7)\n    \"Partition Info Invalid\",    // UF2_ERR_PART_INVALID (8)\n    \"Partition Info Missing\",    // UF2_ERR_PART_UNSET (9)\n    \"Block Data Too Long\",       // UF2_ERR_DATA_TOO_LONG (10)\n    \"Bad Block Sequence Number\", // UF2_ERR_SEQ_MISMATCH (11)\n    \"Flash Erase Failed\",        // UF2_ERR_ERASE_FAILED (12)\n    \"Flash Write Failed\",        // UF2_ERR_WRITE_FAILED (13)\n    \"Write Failed Length\",       // UF2_ERR_WRITE_LENGTH (14)\n    \"Partition Write-Protected\", // UF2_ERR_WRITE_PROTECT (15)\n    \"Memory Alloc Failed\",       // UF2_ERR_ALLOC_FAILED (16)\n};\n\nstatic const char *errArdText[] = {\n    nullptr,                           // UPDATE_ERROR_OK (0)\n    nullptr,                           // UPDATE_ERROR_WRITE (1)\n    nullptr,                           // UPDATE_ERROR_ERASE (2)\n    nullptr,                           // UPDATE_ERROR_READ (3)\n    nullptr,                           // UPDATE_ERROR_SPACE (4)\n    \"Bad Size Given\",                  // UPDATE_ERROR_SIZE (5)\n    \"Stream Read Timeout\",             // UPDATE_ERROR_STREAM (6)\n    \"MD5 Check Failed\",                // UPDATE_ERROR_MD5 (7)\n    nullptr,                           // UPDATE_ERROR_MAGIC_BYTE (8)\n    \"Could Not Activate The Firmware\", // UPDATE_ERROR_ACTIVATE (9)\n    nullptr,                           // UPDATE_ERROR_NO_PARTITION (10)\n    \"Bad Argument\",                    // UPDATE_ERROR_BAD_ARGUMENT (11)\n    \"Aborted\",                         // UPDATE_ERROR_ABORT (12)\n};\n\nstatic char errorStr[14];\n\nUpdateClass &amp;UpdateClass::onProgress(THandlerFunction_Progress handler) {\n    this-&gt;callback = std::move(handler);\n    return *this;\n}\n\nvoid UpdateClass::progressHandler(UpdateClass *self) {\n    if (self-&gt;callback)\n        self-&gt;callback(self-&gt;ctx-&gt;bytes_written, self-&gt;ctx-&gt;bytes_total);\n}\n\nbool UpdateClass::canRollBack() {\n    return lt_ota_can_rollback();\n}\n\nbool UpdateClass::rollBack() {\n    if (!lt_ota_can_rollback())\n        return false;\n    return lt_ota_switch(/* revert= */ false);\n}\n\nbool UpdateClass::setMD5(const char *md5) {\n    if (strlen(md5) != 32)\n        return false;\n    if (!this-&gt;md5Expected)\n        this-&gt;md5Expected = static_cast&lt;uint8_t *&gt;(malloc(16));\n    if (!this-&gt;md5Expected)\n        return false;\n    lt_xtob(md5, 32, this-&gt;md5Expected);\n    return true;\n}\n\nString UpdateClass::md5String() {\n    if (!this-&gt;md5Digest)\n        return \"\";\n    char out[32 + 1];\n    lt_btox(this-&gt;md5Digest, 16, out);\n    return String(out);\n}\n\nvoid UpdateClass::md5(uint8_t *result) {\n    if (!this-&gt;md5Digest) {\n        memset(result, '\\0', 16);\n        return;\n    }\n    memcpy(result, this-&gt;md5Digest, 16);\n}\n\nuint16_t UpdateClass::getErrorCode() const {\n    return (this-&gt;getError() &lt;&lt; 8) | this-&gt;getUF2Error();\n}\n\nbool UpdateClass::hasError() const {\n    return this-&gt;getError() != UPDATE_ERROR_OK || this-&gt;getUF2Error() &gt; UF2_ERR_IGNORE;\n}\n\nvoid UpdateClass::clearError() {\n    this-&gt;errArd = UPDATE_ERROR_OK;\n    this-&gt;errUf2 = UF2_ERR_OK;\n    if (this-&gt;ctx)\n        this-&gt;ctx-&gt;error = UF2_ERR_OK;\n}\n\nconst char *UpdateClass::errorString() const {\n    uint8_t err;\n    if ((err = this-&gt;getUF2Error()) &gt; UF2_ERR_IGNORE)\n        return errUf2Text[err];\n    if ((err = this-&gt;getError()) != UPDATE_ERROR_OK)\n        return errArdText[err];\n    if (!this-&gt;hasError())\n        return \"\";\n    sprintf(errorStr, \"ard=%u,uf2=%u\", this-&gt;getError(), this-&gt;getUF2Error());\n    return errorStr;\n}\n\nvoid UpdateClass::printError(Print &amp;out) const {\n    out.println(errorString());\n}\n\nvoid UpdateClass::printErrorContext() {\n#if LT_DEBUG_OTA\n    if (!this-&gt;ctx)\n        return;\n\n    LT_EM(OTA, \"Error: %s\", errorString());\n    if (errArd == UPDATE_ERROR_ABORT)\n        return;\n\n    LT_EM(OTA, \"- written: %u of %u\", this-&gt;ctx-&gt;bytes_written, this-&gt;ctx-&gt;bytes_total);\n    LT_EM(\n        OTA,\n        \"- buf: size=%lld, left=%lld\",\n        this-&gt;ctx-&gt;buf_pos - this-&gt;ctx-&gt;buf,\n        this-&gt;ctx-&gt;buf + UF2_BLOCK_SIZE - this-&gt;ctx-&gt;buf_pos\n    );\n    hexdump(this-&gt;ctx-&gt;buf, this-&gt;ctx-&gt;buf_pos - this-&gt;ctx-&gt;buf);\n\n    if (ctx)\n        LT_EM(\n            OTA,\n            \"- ctx: seq=%u, part=%s\",\n            this-&gt;ctx-&gt;uf2.seq - 1, // print last parsed block seq\n            this-&gt;ctx-&gt;uf2.part ? this-&gt;ctx-&gt;uf2.part-&gt;name : nullptr\n        );\n\n    auto *block = (uf2_block_t *)this-&gt;ctx-&gt;buf;\n    LT_EM(OTA, \"- buf: seq=%u/%u, addr=%u, len=%u\", block-&gt;block_seq, block-&gt;block_count, block-&gt;addr, block-&gt;len);\n#endif\n}\n</code></pre>"},{"location":"ltapi/dir_f12ca718858451d77068237cb7af4643/","title":"Dir cores/common/arduino/libraries/common/WiFiClient","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient</p>"},{"location":"ltapi/dir_f12ca718858451d77068237cb7af4643/#files","title":"Files","text":"Type Name     file LwIPClient.cpp    file LwIPClient.h    file LwIPRxBuffer.cpp    file LwIPRxBuffer.h    file MbedTLSClient.cpp    file MbedTLSClient.h    file WiFiClient.h    file WiFiClientSecure.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/</code></p>"},{"location":"ltapi/_lw_i_p_client_8cpp/","title":"File LwIPClient.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPClient.cpp</code></p>"},{"location":"ltapi/_lw_i_p_client_8cpp_source/","title":"File LwIPClient.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPClient.h\"\n\n#include &lt;WiFi.h&gt;\n\n#define MAX_SOCK_NUM                4\n#define WIFI_CLIENT_CONNECT_TIMEOUT 3000\n#define WIFI_CLIENT_READ_TIMEOUT    3000\n#define WIFI_CLIENT_WRITE_RETRY     10\n#define WIFI_CLIENT_SELECT_TIMEOUT  1000\n#define WIFI_CLIENT_FLUSH_BUF_SIZE  1024\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n\n#include &lt;lwip/api.h&gt;\n#include &lt;lwip/dns.h&gt;\n#include &lt;lwip/err.h&gt;\n#include &lt;lwip/sockets.h&gt;\n#include &lt;sys/time.h&gt;\n\n} // extern \"C\"\n\nclass SocketHandle {\n  public:\n    int fd;\n\n    SocketHandle(int fd) : fd(fd) {}\n\n    ~SocketHandle() {\n        lwip_close(fd);\n    }\n};\n\nLwIPClient::LwIPClient() {\n    LT_VM(CLIENT, \"LwIPClient()\");\n    _connected = false;\n    _sock      = NULL;\n    _rxBuffer  = NULL;\n    _timeout   = WIFI_CLIENT_CONNECT_TIMEOUT;\n}\n\nLwIPClient::LwIPClient(int sock) {\n    LT_VM(CLIENT, \"LwIPClient(%d)\", sock);\n    _connected = true;\n    _sock      = std::make_shared&lt;SocketHandle&gt;(sock);\n    _rxBuffer  = std::make_shared&lt;LwIPRxBuffer&gt;(sock);\n    _timeout   = WIFI_CLIENT_CONNECT_TIMEOUT;\n}\n\nLwIPClient::~LwIPClient() {\n    LT_VM(CLIENT, \"~LwIPClient()\");\n    stop();\n}\n\nLwIPClient &amp;LwIPClient::operator=(const LwIPClient &amp;other) {\n    stop();\n    _connected = other._connected;\n    _sock      = other._sock;\n    _rxBuffer  = other._rxBuffer;\n    return *this;\n}\n\nbool IWiFiClient::operator==(const IWiFiClient &amp;other) const {\n    return fd() == other.fd() &amp;&amp; remoteIP() == other.remoteIP() &amp;&amp; remotePort() == other.remotePort();\n}\n\nint LwIPClient::connect(IPAddress ip, uint16_t port) {\n    return connect(ip, port, _timeout);\n}\n\nint LwIPClient::connect(const char *host, uint16_t port) {\n    return connect(host, port, _timeout);\n}\n\nint LwIPClient::connect(const char *host, uint16_t port, int32_t timeout) {\n    IPAddress ip = WiFi.hostByName(host);\n    if (!ip)\n        return 0;\n    return connect(ip, port, timeout);\n}\n\nint LwIPClient::connect(IPAddress ip, uint16_t port, int32_t timeout) {\n    if (_connected)\n        stop();\n    int sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock &lt; 0) {\n        LT_DM(CLIENT, \"socket failed\");\n        return -1;\n    }\n\n    if (timeout &lt;= 0)\n        timeout = _timeout; // use default when -1 passed as timeout\n\n    lwip_fcntl(sock, F_SETFL, lwip_fcntl(sock, F_GETFL, 0) | O_NONBLOCK);\n\n    LT_ERRNO();\n\n    struct sockaddr_in addr;\n    memset(&amp;addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = ip;\n    addr.sin_port        = htons(port);\n    fd_set fdset;\n    struct timeval tv;\n    FD_ZERO(&amp;fdset);\n    FD_SET(sock, &amp;fdset);\n    tv.tv_sec  = 0;\n    tv.tv_usec = timeout * 1000; // millis -&gt; micros\n\n    int res = lwip_connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr));\n    if (res &lt; 0 &amp;&amp; errno != EINPROGRESS) {\n        LT_EM(CLIENT, \"Connect failed; errno=%d\", errno);\n        lwip_close(sock);\n        return -1;\n    }\n\n    res = lwip_select(sock + 1, NULL, &amp;fdset, NULL, timeout &lt; 0 ? NULL : &amp;tv);\n    if (res &lt; 0) {\n        LT_EM(CLIENT, \"Select failed; errno=%d\", errno);\n        lwip_close(sock);\n        return 0;\n    }\n    if (res == 0) {\n        LT_EM(CLIENT, \"Select timeout; errno=%d\", errno);\n        lwip_close(sock);\n        return 0;\n    }\n\n    int sockerr;\n    socklen_t len = (socklen_t)sizeof(sockerr);\n    res           = lwip_getsockopt(sock, SOL_SOCKET, SO_ERROR, &amp;sockerr, &amp;len);\n\n    if (res &lt; 0 || sockerr != 0) {\n        LT_EM(CLIENT, \"Socket error; res=%d, sockerr=%d\", res, sockerr);\n        lwip_close(sock);\n        return 0;\n    }\n\n    int enable = 1;\n    lwip_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout));\n    lwip_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, sizeof(timeout));\n    lwip_setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;enable, sizeof(enable));\n    lwip_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;enable, sizeof(enable));\n\n    LT_ERRNO();\n\n    lwip_fcntl(sock, F_SETFL, lwip_fcntl(sock, F_GETFL, 0) &amp; ~O_NONBLOCK);\n\n    LT_ERRNO();\n\n    _connected = true;\n    _sock      = std::make_shared&lt;SocketHandle&gt;(sock);\n    _rxBuffer  = std::make_shared&lt;LwIPRxBuffer&gt;(sock);\n    return 1;\n}\n\nsize_t LwIPClient::write(uint8_t data) {\n    return write(&amp;data, 1);\n}\n\nsize_t LwIPClient::write(Stream &amp;stream) {\n    uint8_t *buf = (uint8_t *)malloc(1360);\n    if (!buf) {\n        return 0;\n    }\n    size_t toRead = 0, toWrite = 0, written = 0;\n    size_t available = stream.available();\n    while (available) {\n        toRead  = (available &gt; 1360) ? 1360 : available;\n        toWrite = stream.readBytes(buf, toRead);\n        written += write(buf, toWrite);\n        available = stream.available();\n    }\n    free(buf);\n    return written;\n}\n\nsize_t LwIPClient::write(const uint8_t *buf, size_t size) {\n    if (_sock &lt; 0 || !_connected || !size) {\n        setWriteError();\n        return 0;\n    }\n\n    int retry   = WIFI_CLIENT_WRITE_RETRY;\n    int written = 0;\n    while (retry) {\n        fd_set fdset;\n        struct timeval tv;\n        FD_ZERO(&amp;fdset);\n        FD_SET(fd(), &amp;fdset);\n        tv.tv_sec  = 0;\n        tv.tv_usec = WIFI_CLIENT_SELECT_TIMEOUT * 1000;\n        retry--;\n\n        if (lwip_select(fd() + 1, NULL, &amp;fdset, NULL, &amp;tv) &lt; 0) {\n            LT_WM(CLIENT, \"Select failed; errno=%d\", errno);\n            return 0;\n        }\n\n        if (FD_ISSET(fd(), &amp;fdset)) {\n            int res = lwip_send(fd(), buf, size, MSG_DONTWAIT);\n            if (res &gt; 0) {\n                written += res;\n                if (res &gt;= size) {\n                    retry = 0;\n                } else {\n                    buf += res;\n                    size -= res;\n                    retry = WIFI_CLIENT_WRITE_RETRY;\n                }\n            } else if (res &lt; 0 &amp;&amp; errno != EAGAIN) {\n                LT_WM(CLIENT, \"Send failed; errno=%d\", errno);\n                setWriteError(res);\n                _connected = false;\n                retry      = 0;\n            } else {\n                // Try again\n            }\n        }\n    }\n    LT_DM(CLIENT, \"wrote %d bytes\", written);\n    return written;\n}\n\nint LwIPClient::available() {\n    if (!_connected || !_rxBuffer)\n        return 0;\n    int res = _rxBuffer-&gt;available();\n    if (_rxBuffer-&gt;failed()) {\n        LT_ERRNO();\n        stop();\n    }\n    return res;\n}\n\nint LwIPClient::fd() const {\n    if (!_sock)\n        return -1;\n    return _sock-&gt;fd;\n}\n\nint LwIPClient::socket() {\n    return fd();\n}\n\nint LwIPClient::setTimeout(uint32_t seconds) {\n    Client::setTimeout(seconds * 1000);\n    lwip_setsockopt(fd(), SOL_SOCKET, SO_RCVTIMEO, &amp;_timeout, sizeof(_timeout));\n    return lwip_setsockopt(fd(), SOL_SOCKET, SO_SNDTIMEO, &amp;_timeout, sizeof(_timeout));\n}\n\nint LwIPClient::read() {\n    uint8_t data;\n    int res = read(&amp;data, 1);\n    if (res &lt; 0)\n        return res;\n    if (res == 0)\n        return -1;\n    return data;\n}\n\nint LwIPClient::read(uint8_t *buf, size_t size) {\n    int res = -1;\n    if (_rxBuffer) {\n        res = _rxBuffer-&gt;read(buf, size);\n        if (_rxBuffer-&gt;failed()) {\n            stop();\n        }\n    }\n    return res;\n}\n\nint LwIPClient::peek() {\n    int res = -1;\n    if (_rxBuffer) {\n        res = _rxBuffer-&gt;peek();\n        if (_rxBuffer-&gt;failed()) {\n            stop();\n        }\n    }\n    return res;\n}\n\nvoid LwIPClient::flush() {\n    int res;\n    size_t len = available();\n    if (!len)\n        return;\n    uint8_t *buf = (uint8_t *)malloc(WIFI_CLIENT_FLUSH_BUF_SIZE);\n    if (!buf)\n        return;\n    while (len) {\n        res = lwip_recv(fd(), buf, LWIP_MIN(len, WIFI_CLIENT_FLUSH_BUF_SIZE), MSG_DONTWAIT);\n        if (res &lt; 0) {\n            stop();\n            break;\n        }\n        len -= res;\n    }\n    free(buf);\n}\n\nvoid LwIPClient::stop() {\n    LT_VM(CLIENT, \"Stopping TCP\");\n    _connected = false;\n    _sock      = NULL;\n    _rxBuffer  = NULL;\n}\n\nuint8_t LwIPClient::connected() {\n    if (_connected) {\n        uint8_t dummy;\n        if (lwip_recv(fd(), &amp;dummy, 0, MSG_DONTWAIT) &lt;= 0) {\n            switch (errno) {\n                case EWOULDBLOCK:\n                case ENOENT: // caused by vfs\n                case 0:\n                    _connected = true;\n                    break;\n                case ENOTCONN:\n                case EPIPE:\n                case ECONNRESET:\n                case ECONNREFUSED:\n                case ECONNABORTED:\n                    LT_IM(CLIENT, \"Connection closed; errno=%d\", errno);\n                    _connected = false;\n                    break;\n                default:\n                    LT_WM(CLIENT, \"Connection status unknown; errno=%d\", errno);\n                    _connected = true;\n                    break;\n            }\n        }\n    }\n    return _connected;\n}\n\nIPAddress __attribute__((noinline)) getaddr(int sock, int (*func)(int, struct sockaddr *, socklen_t *)) {\n    struct sockaddr addr;\n    socklen_t len = sizeof(addr);\n    func(sock, &amp;addr, &amp;len);\n    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;\n    return IPAddress((uint32_t)(s-&gt;sin_addr.s_addr));\n}\n\nuint16_t __attribute__((noinline)) getport(int sock, int (*func)(int, struct sockaddr *, socklen_t *)) {\n    struct sockaddr addr;\n    socklen_t len = sizeof(addr);\n    func(sock, &amp;addr, &amp;len);\n    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;\n    return ntohs(s-&gt;sin_port);\n}\n\nIPAddress LwIPClient::remoteIP() const {\n    return getaddr(fd(), lwip_getpeername);\n}\n\nIPAddress LwIPClient::remoteIP(int fd) const {\n    return getaddr(fd, lwip_getpeername);\n}\n\nuint16_t LwIPClient::remotePort() const {\n    return getport(fd(), lwip_getpeername);\n}\n\nuint16_t LwIPClient::remotePort(int fd) const {\n    return getport(fd, lwip_getpeername);\n}\n\nIPAddress LwIPClient::localIP() const {\n    return getaddr(fd(), lwip_getsockname);\n}\n\nIPAddress LwIPClient::localIP(int fd) const {\n    return getaddr(fd, lwip_getsockname);\n}\n\nuint16_t LwIPClient::localPort() const {\n    return getport(fd(), lwip_getsockname);\n}\n\nuint16_t LwIPClient::localPort(int fd) const {\n    return getport(fd, lwip_getsockname);\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_client_8h/","title":"File LwIPClient.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiClient.h\"</code></li> <li><code>#include \"LwIPRxBuffer.h\"</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_client_8h/#classes","title":"Classes","text":"Type Name     class LwIPClient"},{"location":"ltapi/_lw_i_p_client_8h/#public-types","title":"Public Types","text":"Type Name     typedef LwIPClient WiFiClient"},{"location":"ltapi/_lw_i_p_client_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_lw_i_p_client_8h/#typedef-wificlient","title":"typedef WiFiClient","text":"<pre><code>typedef LwIPClient WiFiClient;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPClient.h</code></p>"},{"location":"ltapi/_lw_i_p_client_8h_source/","title":"File LwIPClient.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n#if (LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP) || DOXYGEN\n\n#include \"WiFiClient.h\"\n\n#include \"LwIPRxBuffer.h\"\n#include &lt;memory&gt;\n\nclass SocketHandle;\n\nclass LwIPClient : public IWiFiClient {\n  private:\n    bool _connected;\n    std::shared_ptr&lt;SocketHandle&gt; _sock;\n    std::shared_ptr&lt;LwIPRxBuffer&gt; _rxBuffer;\n\n  public:\n    LwIPClient();\n    LwIPClient(int sock);\n    ~LwIPClient();\n\n    int connect(IPAddress ip, uint16_t port);\n    int connect(const char *host, uint16_t port);\n    int connect(IPAddress ip, uint16_t port, int32_t timeout);\n    int connect(const char *host, uint16_t port, int32_t timeout);\n\n    size_t write(uint8_t data);\n    size_t write(const uint8_t *buf, size_t size);\n    size_t write(Stream &amp;stream);\n\n    int available();\n    int fd() const;\n    int socket();\n    int setTimeout(uint32_t seconds);\n\n    int read();\n    int read(uint8_t *buf, size_t size);\n    int peek();\n    void flush();\n    void stop();\n    uint8_t connected();\n\n    LwIPClient &amp;operator=(const LwIPClient &amp;other);\n\n    IPAddress remoteIP() const;\n    IPAddress remoteIP(int sock) const;\n    uint16_t remotePort() const;\n    uint16_t remotePort(int sock) const;\n    IPAddress localIP() const;\n    IPAddress localIP(int sock) const;\n    uint16_t localPort() const;\n    uint16_t localPort(int sock) const;\n\n    using Print::write;\n};\n\ntypedef LwIPClient WiFiClient;\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_rx_buffer_8cpp/","title":"File LwIPRxBuffer.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPRxBuffer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPRxBuffer.cpp</code></p>"},{"location":"ltapi/_lw_i_p_rx_buffer_8cpp_source/","title":"File LwIPRxBuffer.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPRxBuffer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_HAS_LWIP\n\n#include \"LwIPRxBuffer.h\"\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n\n#include &lt;lwip/sockets.h&gt;\n\n} // extern \"C\"\n\nsize_t LwIPRxBuffer::r_available() {\n    if (_sock &lt; 0) {\n        LT_DM(CLIENT, \"_sock &lt; 0\");\n        return 0;\n    }\n    int count = 0; // must be of same size as in lwip_ioctl()\n    int res   = lwip_ioctl(_sock, FIONREAD, &amp;count);\n    if (res &lt; 0) {\n        LT_DM(CLIENT, \"lwip_ioctl()=%d, errno=%d\", res, errno);\n        _failed = true;\n        return 0;\n    }\n    return count;\n}\n\nsize_t LwIPRxBuffer::fillBuffer() {\n    if (!_buffer) {\n        _buffer = (uint8_t *)malloc(_size);\n        if (!_buffer) {\n            LT_E(\"buffer alloc failed\");\n            _failed = true;\n            return 0;\n        }\n    }\n    if (_fill &amp;&amp; _pos == _fill) {\n        _fill = 0;\n        _pos  = 0;\n    }\n    if (!_buffer || _size &lt;= _fill || !r_available()) {\n        return 0;\n    }\n    int res = lwip_recv(_sock, _buffer + _fill, _size - _fill, MSG_DONTWAIT);\n    if (res &lt; 0) {\n        if (errno != EWOULDBLOCK) {\n            LT_ERRNO();\n            _failed = true;\n        }\n        return 0;\n    }\n    _fill += res;\n    return res;\n}\n\nLwIPRxBuffer::LwIPRxBuffer(int sock, size_t size)\n    : _size(size), _buffer(NULL), _pos(0), _fill(0), _sock(sock), _failed(false) {\n    //_buffer = (uint8_t *)malloc(_size);\n}\n\nLwIPRxBuffer::~LwIPRxBuffer() {\n    free(_buffer);\n}\n\nbool LwIPRxBuffer::failed() {\n    return _failed;\n}\n\nint LwIPRxBuffer::read(uint8_t *dst, size_t len) {\n    if (!dst || !len || (_pos == _fill &amp;&amp; !fillBuffer())) {\n        return _failed ? -1 : 0;\n    }\n    size_t a = _fill - _pos;\n    if (len &lt;= a || ((len - a) &lt;= (_size - _fill) &amp;&amp; fillBuffer() &gt;= (len - a))) {\n        if (len == 1) {\n            *dst = _buffer[_pos];\n        } else {\n            memcpy(dst, _buffer + _pos, len);\n        }\n        _pos += len;\n        return len;\n    }\n    size_t left   = len;\n    size_t toRead = a;\n    uint8_t *buf  = dst;\n    memcpy(buf, _buffer + _pos, toRead);\n    _pos += toRead;\n    left -= toRead;\n    buf += toRead;\n    while (left) {\n        if (!fillBuffer()) {\n            return len - left;\n        }\n        a      = _fill - _pos;\n        toRead = (a &gt; left) ? left : a;\n        memcpy(buf, _buffer + _pos, toRead);\n        _pos += toRead;\n        left -= toRead;\n        buf += toRead;\n    }\n    return len;\n}\n\nint LwIPRxBuffer::peek() {\n    if (_pos == _fill &amp;&amp; !fillBuffer()) {\n        return -1;\n    }\n    return _buffer[_pos];\n}\n\nsize_t LwIPRxBuffer::available() {\n    return _fill - _pos + r_available();\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h/","title":"File LwIPRxBuffer.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPRxBuffer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h/#classes","title":"Classes","text":"Type Name     class LwIPRxBuffer      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/LwIPRxBuffer.h</code></p>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h_source/","title":"File LwIPRxBuffer.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; LwIPRxBuffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;stdlib.h&gt;\n\nclass LwIPRxBuffer {\n  private:\n    size_t _size;\n    uint8_t *_buffer;\n    size_t _pos;\n    size_t _fill;\n    int _sock;\n    bool _failed;\n    size_t r_available();\n    size_t fillBuffer();\n\n  public:\n    LwIPRxBuffer(int sock, size_t size = 1436);\n    ~LwIPRxBuffer();\n    bool failed();\n    int read(uint8_t *dst, size_t len);\n    int peek();\n    size_t available();\n};\n</code></pre>"},{"location":"ltapi/_mbed_t_l_s_client_8cpp/","title":"File MbedTLSClient.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; MbedTLSClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/MbedTLSClient.cpp</code></p>"},{"location":"ltapi/_mbed_t_l_s_client_8cpp_source/","title":"File MbedTLSClient.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; MbedTLSClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS\n\n#include \"MbedTLSClient.h\"\n\n#include &lt;WiFi.h&gt;\n\nextern \"C\" {\n\n#include &lt;mbedtls/debug.h&gt;\n#include &lt;mbedtls/net.h&gt;\n#include &lt;mbedtls/pk.h&gt;\n#include &lt;mbedtls/platform.h&gt;\n#include &lt;mbedtls/sha256.h&gt;\n#include &lt;mbedtls/ssl.h&gt;\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#endif\n\n} // extern \"C\"\n\n#define _clientKeyC ((mbedtls_pk_context *)_clientKey)\n\nMbedTLSClient::MbedTLSClient() : WiFiClient() {\n    init(); // ensure the context is zero filled\n}\n\nMbedTLSClient::MbedTLSClient(int sock) : WiFiClient(sock) {\n    init(); // ensure the context is zero filled\n}\n\nMbedTLSClient::~MbedTLSClient() {\n    LT_VM(CLIENT, \"~MbedTLSClient()\");\n    stop();\n}\n\nvoid MbedTLSClient::stop() {\n    if (!_sslCtx)\n        return;\n    LT_VM(SSL, \"Stopping SSL\");\n\n    if (_sslCfg-&gt;ca_chain) {\n        mbedtls_x509_crt_free(_caCert);\n    }\n    if (_sslCfg-&gt;key_cert) {\n        mbedtls_x509_crt_free(_clientCert);\n        mbedtls_pk_free(_clientKeyC);\n    }\n    mbedtls_ssl_free(_sslCtx);\n    mbedtls_ssl_config_free(_sslCfg);\n\n    free(_sslCtx);\n    free(_sslCfg);\n    free(_caCert);\n    free(_clientCert);\n    free(_clientKey);\n    _sslCtx = NULL;\n\n    LT_HEAP_I();\n}\n\nvoid MbedTLSClient::init() {\n    if (!_sslCtx) {\n        _sslCtx     = (mbedtls_ssl_context *)malloc(sizeof(mbedtls_ssl_context));\n        _sslCfg     = (mbedtls_ssl_config *)malloc(sizeof(mbedtls_ssl_config));\n        _caCert     = (mbedtls_x509_crt *)malloc(sizeof(mbedtls_x509_crt));\n        _clientCert = (mbedtls_x509_crt *)malloc(sizeof(mbedtls_x509_crt));\n        _clientKey  = (mbedtls_pk_context *)malloc(sizeof(mbedtls_pk_context));\n    }\n    // Realtek AmbZ: init platform here to ensure HW crypto is initialized in ssl_init\n    mbedtls_platform_set_calloc_free(calloc, free);\n    mbedtls_ssl_init(_sslCtx);\n    mbedtls_ssl_config_init(_sslCfg);\n}\n\nint MbedTLSClient::connect(IPAddress ip, uint16_t port, int32_t timeout) {\n    return connect(ipToString(ip).c_str(), port, timeout);\n}\n\nint MbedTLSClient::connect(const char *host, uint16_t port, int32_t timeout) {\n    if (_pskIdentStr &amp;&amp; _pskStr)\n        return connect(host, port, timeout, NULL, NULL, NULL, _pskIdentStr, _pskStr) == 0;\n    return connect(host, port, timeout, _caCertStr, _clientCertStr, _clientKeyStr, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(\n    IPAddress ip,\n    uint16_t port,\n    const char *rootCABuf,\n    const char *clientCert,\n    const char *clientKey\n) {\n    return connect(ipToString(ip).c_str(), port, 0, rootCABuf, clientCert, clientKey, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(\n    const char *host,\n    uint16_t port,\n    const char *rootCABuf,\n    const char *clientCert,\n    const char *clientKey\n) {\n    return connect(host, port, 0, rootCABuf, clientCert, clientKey, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk) {\n    return connect(ipToString(ip).c_str(), port, 0, NULL, NULL, NULL, pskIdent, psk) == 0;\n}\n\nint MbedTLSClient::connect(const char *host, uint16_t port, const char *pskIdent, const char *psk) {\n    return connect(host, port, 0, NULL, NULL, NULL, pskIdent, psk) == 0;\n}\n\nstatic int ssl_random(void *data, unsigned char *output, size_t len) {\n    lt_rand_bytes((uint8_t *)output, len);\n    return 0;\n}\n\nvoid debug_cb(void *ctx, int level, const char *file, int line, const char *str) {\n    // do not print the trailing \\n\n    uint16_t len = strlen(str);\n    char *msg    = (char *)str;\n    msg[len - 1] = '\\0';\n    LT_IM(SSL, \"%04d: |%d| %s\", line, level, msg);\n}\n\nint MbedTLSClient::connect(\n    const char *host,\n    uint16_t port,\n    int32_t timeout,\n    const char *rootCABuf,\n    const char *clientCert,\n    const char *clientKey,\n    const char *pskIdent,\n    const char *psk\n) {\n    LT_HEAP_I();\n\n    if (!rootCABuf &amp;&amp; !pskIdent &amp;&amp; !psk &amp;&amp; !_insecure &amp;&amp; !_useRootCA)\n        return -1;\n\n    if (timeout &lt;= 0)\n        timeout = _timeout; // use default when -1 passed as timeout\n\n    IPAddress addr = WiFi.hostByName(host);\n    if (!(uint32_t)addr)\n        return -1;\n\n    int ret = WiFiClient::connect(addr, port, timeout);\n    if (ret &lt; 0) {\n        LT_EM(SSL, \"SSL socket failed\");\n        return ret;\n    }\n\n    char *uid = \"lt-ssl\"; // TODO\n\n    LT_VM(SSL, \"Init SSL\");\n    init();\n    LT_HEAP_I();\n\n    // mbedtls_debug_set_threshold(4);\n    // mbedtls_ssl_conf_dbg(&amp;_sslCfg, debug_cb, NULL);\n\n    ret = mbedtls_ssl_config_defaults(\n        _sslCfg,\n        MBEDTLS_SSL_IS_CLIENT,\n        MBEDTLS_SSL_TRANSPORT_STREAM,\n        MBEDTLS_SSL_PRESET_DEFAULT\n    );\n    LT_RET_NZ(ret);\n\n#ifdef MBEDTLS_SSL_ALPN\n    if (_alpnProtocols) {\n        ret = mbedtls_ssl_conf_alpn_protocols(_sslCfg, _alpnProtocols);\n        LT_RET_NZ(ret);\n    }\n#endif\n\n    if (_insecure) {\n        mbedtls_ssl_conf_authmode(_sslCfg, MBEDTLS_SSL_VERIFY_NONE);\n    } else if (rootCABuf) {\n        mbedtls_x509_crt_init(_caCert);\n        mbedtls_ssl_conf_authmode(_sslCfg, MBEDTLS_SSL_VERIFY_REQUIRED);\n        ret = mbedtls_x509_crt_parse(_caCert, (const unsigned char *)rootCABuf, strlen(rootCABuf) + 1);\n        mbedtls_ssl_conf_ca_chain(_sslCfg, _caCert, NULL);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(_caCert);\n            LT_RET(ret);\n        }\n    } else if (_useRootCA) {\n        return -1; // not implemented\n    } else if (pskIdent &amp;&amp; psk) {\n#ifdef MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED\n        uint16_t len = strlen(psk);\n        if ((len &amp; 1) != 0 || len &gt; 2 * MBEDTLS_PSK_MAX_LEN) {\n            LT_EM(SSL, \"PSK length invalid\");\n            return -1;\n        }\n        unsigned char pskBin[MBEDTLS_PSK_MAX_LEN] = {};\n        for (uint8_t i = 0; i &lt; len; i++) {\n            uint8_t c = psk[i];\n            c |= 0b00100000; // make lowercase\n            c -= '0' * (c &gt;= '0' &amp;&amp; c &lt;= '9');\n            c -= ('a' - 10) * (c &gt;= 'a' &amp;&amp; c &lt;= 'z');\n            if (c &gt; 0xf)\n                return -1;\n            pskBin[i / 2] |= c &lt;&lt; (4 * ((i &amp; 1) ^ 1));\n        }\n        ret = mbedtls_ssl_conf_psk(_sslCfg, pskBin, len / 2, (const unsigned char *)pskIdent, strlen(pskIdent));\n        LT_RET_NZ(ret);\n#else\n        return -1;\n#endif\n    } else {\n        return -1;\n    }\n\n    if (!_insecure &amp;&amp; clientCert &amp;&amp; clientKey) {\n        mbedtls_x509_crt_init(_clientCert);\n        mbedtls_pk_init(_clientKeyC);\n        LT_VM(SSL, \"Loading client cert\");\n        ret = mbedtls_x509_crt_parse(_clientCert, (const unsigned char *)clientCert, strlen(clientCert) + 1);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(_clientCert);\n            LT_RET(ret);\n        }\n        LT_VM(SSL, \"Loading private key\");\n        ret = mbedtls_pk_parse_key(_clientKeyC, (const unsigned char *)clientKey, strlen(clientKey) + 1, NULL, 0);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(_clientCert);\n            LT_RET(ret);\n        }\n        mbedtls_ssl_conf_own_cert(_sslCfg, _clientCert, _clientKeyC);\n    }\n\n    LT_VM(SSL, \"Setting TLS hostname\");\n    ret = mbedtls_ssl_set_hostname(_sslCtx, host);\n    LT_RET_NZ(ret);\n\n    mbedtls_ssl_conf_rng(_sslCfg, ssl_random, NULL);\n    ret = mbedtls_ssl_setup(_sslCtx, _sslCfg);\n    LT_RET_NZ(ret);\n\n    _sockTls = fd();\n    mbedtls_ssl_set_bio(_sslCtx, &amp;_sockTls, mbedtls_net_send, mbedtls_net_recv, NULL);\n    mbedtls_net_set_nonblock((mbedtls_net_context *)&amp;_sockTls);\n\n    LT_HEAP_I();\n\n    LT_VM(SSL, \"SSL handshake\");\n    if (_handshakeTimeout == 0)\n        _handshakeTimeout = timeout;\n    unsigned long start = millis();\n    while (ret = mbedtls_ssl_handshake(_sslCtx)) {\n        if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n            LT_RET(ret);\n        }\n        if ((millis() - start) &gt; _handshakeTimeout) {\n            LT_EM(SSL, \"SSL handshake timeout\");\n            return -1;\n        }\n        delay(2);\n    }\n\n    LT_HEAP_I();\n\n    if (clientCert &amp;&amp; clientKey) {\n        LT_DM(\n            SSL,\n            \"Protocol %s, ciphersuite %s\",\n            mbedtls_ssl_get_version(_sslCtx),\n            mbedtls_ssl_get_ciphersuite(_sslCtx)\n        );\n        ret = mbedtls_ssl_get_record_expansion(_sslCtx);\n        if (ret &gt;= 0)\n            LT_DM(SSL, \"Record expansion: %d\", ret);\n        else {\n            LT_WM(SSL, \"Record expansion unknown\");\n        }\n    }\n\n    LT_VM(SSL, \"Verifying certificate\");\n    ret = mbedtls_ssl_get_verify_result(_sslCtx);\n    if (ret) {\n        char buf[512];\n        memset(buf, 0, sizeof(buf));\n        mbedtls_x509_crt_verify_info(buf, sizeof(buf), \"  ! \", ret);\n        LT_EM(SSL, \"Failed to verify peer certificate! Verification info: %s\", buf);\n        return ret;\n    }\n\n    if (rootCABuf)\n        mbedtls_x509_crt_free(_caCert);\n    if (clientCert)\n        mbedtls_x509_crt_free(_clientCert);\n    if (clientKey != NULL)\n        mbedtls_pk_free(_clientKeyC);\n    return 0; // OK\n}\n\nsize_t MbedTLSClient::write(const uint8_t *buf, size_t size) {\n    int ret = -1;\n    while ((ret = mbedtls_ssl_write(_sslCtx, buf, size)) &lt;= 0) {\n        if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE &amp;&amp; ret &lt; 0) {\n            LT_RET(ret);\n        }\n        delay(2);\n    }\n    return ret;\n}\n\nint MbedTLSClient::available() {\n    bool peeked = _peeked &gt;= 0;\n    if (!connected())\n        return peeked;\n\n    int ret = mbedtls_ssl_read(_sslCtx, NULL, 0);\n    if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE &amp;&amp; ret &lt; 0) {\n        stop();\n        return peeked ? peeked : ret;\n    }\n    return mbedtls_ssl_get_bytes_avail(_sslCtx) + peeked;\n}\n\nint MbedTLSClient::read(uint8_t *buf, size_t size) {\n    bool peeked = false;\n    int toRead  = available();\n    if ((!buf &amp;&amp; size) || toRead &lt;= 0)\n        return -1;\n    if (!size)\n        return 0;\n    if (_peeked &gt;= 0) {\n        buf[0]  = _peeked;\n        _peeked = -1;\n        size--;\n        toRead--;\n        if (!size || !toRead)\n            return 1;\n        buf++;\n        peeked = true;\n    }\n\n    int ret = mbedtls_ssl_read(_sslCtx, buf, size);\n    if (ret &lt; 0) {\n        stop();\n        return peeked ? peeked : ret;\n    }\n    return ret + peeked;\n}\n\nint MbedTLSClient::peek() {\n    if (_peeked &gt;= 0)\n        return _peeked;\n    _peeked = timedRead();\n    return _peeked;\n}\n\nvoid MbedTLSClient::flush() {}\n\nint MbedTLSClient::lastError(char *buf, const size_t size) {\n    return 0; // TODO (?)\n}\n\nvoid MbedTLSClient::setInsecure() {\n    _caCertStr     = NULL;\n    _clientCertStr = NULL;\n    _clientKeyStr  = NULL;\n    _pskIdentStr   = NULL;\n    _pskStr        = NULL;\n    _insecure      = true;\n}\n\n// TODO only allocate _caCert, _clientCert and _clientKey when one\n// of the following functions is used\n\nvoid MbedTLSClient::setPreSharedKey(const char *pskIdent, const char *psk) {\n    _pskIdentStr = pskIdent;\n    _pskStr      = psk;\n}\n\nvoid MbedTLSClient::setCACert(const char *rootCA) {\n    _caCertStr = rootCA;\n}\n\nvoid MbedTLSClient::setCertificate(const char *clientCA) {\n    _clientCertStr = clientCA;\n}\n\nvoid MbedTLSClient::setPrivateKey(const char *privateKey) {\n    _clientKeyStr = privateKey;\n}\n\nchar *streamToStr(Stream &amp;stream, size_t size) {\n    char *buf = (char *)malloc(size + 1);\n    if (!buf)\n        return NULL;\n    if (size != stream.readBytes(buf, size)) {\n        free(buf);\n        return NULL;\n    }\n    buf[size] = '\\0';\n    return buf;\n}\n\nbool MbedTLSClient::loadCACert(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _caCertStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::loadCertificate(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _clientCertStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::loadPrivateKey(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _clientKeyStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::verify(const char *fingerprint, const char *domainName) {\n    uint8_t fpLocal[32] = {};\n    uint16_t len        = strlen(fingerprint);\n    uint8_t byte        = 0;\n    for (uint8_t i = 0; i &lt; len; i++) {\n        uint8_t c = fingerprint[i];\n        while ((c == ' ' || c == ':') &amp;&amp; i &lt; len) {\n            c = fingerprint[++i];\n        }\n        c |= 0b00100000; // make lowercase\n        c -= '0' * (c &gt;= '0' &amp;&amp; c &lt;= '9');\n        c -= ('a' - 10) * (c &gt;= 'a' &amp;&amp; c &lt;= 'z');\n        if (c &gt; 0xf)\n            return -1;\n        fpLocal[byte / 2] |= c &lt;&lt; (4 * ((byte &amp; 1) ^ 1));\n        byte++;\n        if (byte &gt;= 64)\n            break;\n    }\n\n    uint8_t fpRemote[32];\n    if (!getFingerprintSHA256(fpRemote))\n        return false;\n\n    if (memcmp(fpLocal, fpRemote, 32)) {\n        LT_DM(SSL, \"Fingerprints don't match\");\n        return false;\n    }\n\n    if (!domainName)\n        return true;\n    // TODO domain name verification\n    return true;\n}\n\nvoid MbedTLSClient::setHandshakeTimeout(unsigned long handshakeTimeout) {\n    _handshakeTimeout = handshakeTimeout * 1000;\n}\n\nvoid MbedTLSClient::setAlpnProtocols(const char **alpnProtocols) {\n    _alpnProtocols = alpnProtocols;\n}\n\nbool MbedTLSClient::getFingerprintSHA256(uint8_t result[32]) {\n    const mbedtls_x509_crt *cert = mbedtls_ssl_get_peer_cert(_sslCtx);\n    if (!cert) {\n        LT_EM(SSL, \"Failed to get peer certificate\");\n        return false;\n    }\n    mbedtls_sha256_context shaCtx;\n    mbedtls_sha256_init(&amp;shaCtx);\n    mbedtls_sha256_starts(&amp;shaCtx, false);\n    mbedtls_sha256_update(&amp;shaCtx, cert-&gt;raw.p, cert-&gt;raw.len);\n    mbedtls_sha256_finish(&amp;shaCtx, result);\n    return true;\n}\n\n#endif // LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS\n</code></pre>"},{"location":"ltapi/_mbed_t_l_s_client_8h/","title":"File MbedTLSClient.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; MbedTLSClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiClientSecure.h\"</code></li> </ul>"},{"location":"ltapi/_mbed_t_l_s_client_8h/#classes","title":"Classes","text":"Type Name     class MbedTLSClient"},{"location":"ltapi/_mbed_t_l_s_client_8h/#public-types","title":"Public Types","text":"Type Name     typedef MbedTLSClient WiFiClientSecure"},{"location":"ltapi/_mbed_t_l_s_client_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_mbed_t_l_s_client_8h/#typedef-wificlientsecure","title":"typedef WiFiClientSecure","text":"<pre><code>typedef MbedTLSClient WiFiClientSecure;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/MbedTLSClient.h</code></p>"},{"location":"ltapi/_mbed_t_l_s_client_8h_source/","title":"File MbedTLSClient.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; MbedTLSClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#if (LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS) || DOXYGEN\n\n#include \"WiFiClientSecure.h\"\n\nstruct mbedtls_ssl_context;\nstruct mbedtls_ssl_config;\nstruct mbedtls_x509_crt;\n\nclass MbedTLSClient : public WiFiClient, public IWiFiClientSecure {\n  private:\n    mbedtls_ssl_context *_sslCtx = NULL;\n    mbedtls_ssl_config *_sslCfg;\n    mbedtls_x509_crt *_caCert;\n    mbedtls_x509_crt *_clientCert;\n    void *_clientKey;\n    uint32_t _handshakeTimeout = 0;\n\n    void init();\n    int _sockTls    = -1;\n    bool _insecure  = false;\n    bool _useRootCA = false;\n    int _peeked     = -1;\n\n    const char *_caCertStr;\n    const char *_clientCertStr;\n    const char *_clientKeyStr;\n    const char *_pskIdentStr;\n    const char *_pskStr;\n    const char **_alpnProtocols;\n\n    int connect(\n        const char *host,\n        uint16_t port,\n        int32_t timeout,\n        const char *rootCABuf,\n        const char *clientCert,\n        const char *clientKey,\n        const char *pskIdent,\n        const char *psk\n    );\n\n  public:\n    MbedTLSClient();\n    MbedTLSClient(int sock);\n    ~MbedTLSClient();\n\n    int connect(IPAddress ip, uint16_t port, int32_t timeout);\n    int connect(const char *host, uint16_t port, int32_t timeout);\n\n    int connect(IPAddress ip, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey);\n    int connect(const char *host, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey);\n    int connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk);\n    int connect(const char *host, uint16_t port, const char *pskIdent, const char *psk);\n\n    size_t write(const uint8_t *buf, size_t size);\n\n    int available();\n\n    int read(uint8_t *buf, size_t size);\n    int peek();\n    void flush();\n    void stop();\n\n    int lastError(char *buf, const size_t size);\n    void setInsecure(); // Don't validate the chain, just accept whatever is given. VERY INSECURE!\n    void setPreSharedKey(const char *pskIdent, const char *psk); // psk in hex\n    void setCACert(const char *rootCA);\n    void setCertificate(const char *clientCA);\n    void setPrivateKey(const char *privateKey);\n    bool loadCACert(Stream &amp;stream, size_t size);\n    bool loadCertificate(Stream &amp;stream, size_t size);\n    bool loadPrivateKey(Stream &amp;stream, size_t size);\n    bool verify(const char *fingerprint, const char *domainName);\n    void setHandshakeTimeout(unsigned long handshakeTimeout);\n    void setAlpnProtocols(const char **alpnProtocols);\n    bool getFingerprintSHA256(uint8_t result[32]);\n\n    using WiFiClient::connect;\n    using WiFiClient::read;\n};\n\ntypedef MbedTLSClient WiFiClientSecure;\n\n#endif\n</code></pre>"},{"location":"ltapi/_wi_fi_client_8h/","title":"File WiFiClient.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; WiFiClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Client.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_client_8h/#classes","title":"Classes","text":"Type Name     class IWiFiClient      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/WiFiClient.h</code></p>"},{"location":"ltapi/_wi_fi_client_8h_source/","title":"File WiFiClient.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; WiFiClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Client.h - Base class that provides Client\n  Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Client.h&gt;\n\nclass IWiFiClient : public Client {\n  public:\n    IWiFiClient() {}\n\n    IWiFiClient(int sock) {}\n\n    ~IWiFiClient() {}\n\n    virtual int connect(IPAddress ip, uint16_t port, int32_t timeout)     = 0;\n    virtual int connect(const char *host, uint16_t port, int32_t timeout) = 0;\n\n    virtual size_t write(Stream &amp;stream) = 0;\n\n    size_t write_P(PGM_P buffer, size_t size) {\n        return write((const uint8_t *)buffer, size);\n    }\n\n    virtual int fd() const                   = 0;\n    virtual int socket()                     = 0;\n    virtual int setTimeout(uint32_t seconds) = 0;\n\n    bool operator==(const IWiFiClient &amp;other) const;\n\n    operator bool() {\n        return connected();\n    }\n\n    virtual bool operator==(const bool value) {\n        return bool() == value;\n    }\n\n    virtual bool operator!=(const bool value) {\n        return bool() != value;\n    }\n\n    virtual bool operator!=(const IWiFiClient &amp;other) {\n        return !this-&gt;operator==(other);\n    };\n\n    virtual IPAddress remoteIP() const          = 0;\n    virtual IPAddress remoteIP(int sock) const  = 0;\n    virtual uint16_t remotePort() const         = 0;\n    virtual uint16_t remotePort(int sock) const = 0;\n    virtual IPAddress localIP() const           = 0;\n    virtual IPAddress localIP(int sock) const   = 0;\n    virtual uint16_t localPort() const          = 0;\n    virtual uint16_t localPort(int sock) const  = 0;\n\n    using Print::write;\n};\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n#include \"LwIPClient.h\"\n#endif\n</code></pre>"},{"location":"ltapi/_wi_fi_client_secure_8h/","title":"File WiFiClientSecure.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; WiFiClientSecure.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"WiFiClient.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_client_secure_8h/#classes","title":"Classes","text":"Type Name     class IWiFiClientSecure      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiClient/WiFiClientSecure.h</code></p>"},{"location":"ltapi/_wi_fi_client_secure_8h_source/","title":"File WiFiClientSecure.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiClient &gt; WiFiClientSecure.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WiFiClientSecure.h - Base class that provides Client SSL to ESP32\n  Copyright (c) 2011 Adrian McEwen.  All right reserved.\n  Additions Copyright (C) 2017 Evandro Luis Copercini.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#include \"WiFiClient.h\"\n\nclass IWiFiClientSecure {\n  public:\n    virtual int connect(\n        IPAddress ip,\n        uint16_t port,\n        const char *rootCABuf,\n        const char *clientCert,\n        const char *clientKey\n    ) = 0;\n    virtual int connect(\n        const char *host,\n        uint16_t port,\n        const char *rootCABuf,\n        const char *clientCert,\n        const char *clientKey\n    )                                                                                           = 0;\n    virtual int connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk)     = 0;\n    virtual int connect(const char *host, uint16_t port, const char *pskIdent, const char *psk) = 0;\n\n    virtual int lastError(char *buf, const size_t size) = 0;\n    virtual void setInsecure() = 0; // Don't validate the chain, just accept whatever is given. VERY INSECURE!\n    virtual void setPreSharedKey(const char *pskIdent, const char *psk)  = 0; // psk in hex\n    virtual void setCACert(const char *rootCA)                           = 0;\n    virtual void setCertificate(const char *clientCA)                    = 0;\n    virtual void setPrivateKey(const char *privateKey)                   = 0;\n    virtual bool loadCACert(Stream &amp;stream, size_t size)                 = 0;\n    virtual bool loadCertificate(Stream &amp;stream, size_t size)            = 0;\n    virtual bool loadPrivateKey(Stream &amp;stream, size_t size)             = 0;\n    virtual bool verify(const char *fingerprint, const char *domainName) = 0;\n    virtual void setHandshakeTimeout(unsigned long handshakeTimeout)     = 0;\n    virtual void setAlpnProtocols(const char **alpnProtocols)            = 0;\n    virtual bool getFingerprintSHA256(uint8_t result[32])                = 0;\n};\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS\n#include \"MbedTLSClient.h\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_561e7e821afe2d99042aaa333fa070ac/","title":"Dir cores/common/arduino/libraries/common/WiFiServer","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiServer</p>"},{"location":"ltapi/dir_561e7e821afe2d99042aaa333fa070ac/#files","title":"Files","text":"Type Name     file LwIPServer.cpp    file LwIPServer.h    file WiFiServer.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/</code></p>"},{"location":"ltapi/_lw_i_p_server_8cpp/","title":"File LwIPServer.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; LwIPServer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/LwIPServer.cpp</code></p>"},{"location":"ltapi/_lw_i_p_server_8cpp_source/","title":"File LwIPServer.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; LwIPServer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPServer.h\"\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n#include &lt;lwip/api.h&gt;\n// #include &lt;lwip/dns.h&gt;\n#include &lt;lwip/err.h&gt;\n#include &lt;lwip/sockets.h&gt;\n#include &lt;sys/time.h&gt;\n}\n\nLwIPServer::LwIPServer(uint32_t addr, uint16_t port, uint8_t maxClients)\n    : _sock(-1), _sockAccepted(-1), _addr(addr), _port(port), _maxClients(maxClients), _active(false), _noDelay(false) {\n}\n\nLwIPServer::operator bool() {\n    return _active;\n}\n\nbool LwIPServer::begin(uint16_t port, bool reuseAddr) {\n    if (_active)\n        return true;\n    if (port)\n        _port = port;\n\n    _sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (_sock &lt; 0) {\n        LT_EM(SERVER, \"Socket failed; errno=%d\", errno);\n        return false;\n    }\n\n    int enable = reuseAddr;\n    lwip_setsockopt(_sock, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(enable));\n\n    struct sockaddr_in addr;\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = _addr;\n    addr.sin_port        = htons(_port);\n\n    if (lwip_bind(_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {\n        LT_EM(SERVER, \"Bind failed; errno=%d\", errno);\n        return false;\n    }\n\n    if (lwip_listen(_sock, _maxClients) &lt; 0) {\n        LT_EM(SERVER, \"Bind failed; errno=%d\", errno);\n        return false;\n    }\n\n    uint8_t *addrB = (uint8_t *)&amp;_addr;\n    LT_IM(SERVER, \"Server running on %hhu.%hhu.%hhu.%hhu:%hu\", addrB[0], addrB[1], addrB[2], addrB[3], _port);\n\n    lwip_fcntl(_sock, F_SETFL, O_NONBLOCK);\n    _active       = true;\n    _noDelay      = false;\n    _sockAccepted = -1;\n    return true;\n}\n\nvoid LwIPServer::end() {\n    if (_sock == -1)\n        return;\n    lwip_close(_sock);\n    _sock   = -1;\n    _active = -1;\n}\n\nWiFiClient LwIPServer::accept() {\n    if (!_active)\n        return WiFiClient();\n\n    int sock;\n    if (_sockAccepted &gt;= 0) {\n        sock          = _sockAccepted;\n        _sockAccepted = -1;\n    } else {\n        struct sockaddr_in addr;\n        socklen_t len = sizeof(addr);\n        sock          = lwip_accept(_sock, (struct sockaddr *)&amp;addr, &amp;len);\n    }\n\n    if (sock &gt;= 0) {\n        int enable = 1;\n        if (lwip_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;enable, sizeof(enable)) == ERR_OK) {\n            enable = _noDelay;\n            if (lwip_setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;enable, sizeof(enable)) == ERR_OK) {\n                // HOTFIX: allow the TCP thread to receive data\n                // I'm not sure what's happening there, so this should probably be fixed properly.\n                // When a connection arrives, sometimes TCP hasn't received anything yet. This causes\n                // calling WiFiClient::connected() check for lwip_recv(), which returns EWOULDBLOCK\n                // as the client is still connected. The problem is that there's basically an infinite loop\n                // created: nowhere in that code is a yield()/delay() that would allow TCP thread to work\n                // and receive data, so LwIP still sees a connected client that sends nothing. At least\n                // that's what I understand. And any loop that doesn't call delay() seems to block the TCP\n                // stack completely and prevents it from even being pinged.\n                LT_DM(SERVER, \"Got client\");\n                delay(5);\n                return WiFiClient(sock);\n            }\n        }\n    }\n\n    return WiFiClient();\n}\n\nint LwIPServer::setTimeout(uint32_t seconds) {\n    struct timeval tv;\n    tv.tv_sec  = seconds;\n    tv.tv_usec = 0;\n    if (lwip_setsockopt(_sock, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv)) &lt; 0)\n        return -1;\n    return lwip_setsockopt(_sock, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, sizeof(tv));\n}\n\nvoid LwIPServer::setNoDelay(bool noDelay) {\n    _noDelay = noDelay;\n}\n\nbool LwIPServer::getNoDelay() {\n    return _noDelay;\n}\n\nbool LwIPServer::hasClient() {\n    if (_sockAccepted &gt;= 0) {\n        return true;\n    }\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    _sockAccepted = lwip_accept(_sock, (struct sockaddr *)&amp;addr, &amp;len);\n    if (_sockAccepted &gt;= 0) {\n        return true;\n    }\n    return false;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_server_8h/","title":"File LwIPServer.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; LwIPServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiServer.h\"</code></li> </ul>"},{"location":"ltapi/_lw_i_p_server_8h/#classes","title":"Classes","text":"Type Name     class LwIPServer"},{"location":"ltapi/_lw_i_p_server_8h/#public-types","title":"Public Types","text":"Type Name     typedef LwIPServer WiFiServer"},{"location":"ltapi/_lw_i_p_server_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_lw_i_p_server_8h/#typedef-wifiserver","title":"typedef WiFiServer","text":"<pre><code>typedef LwIPServer WiFiServer;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/LwIPServer.h</code></p>"},{"location":"ltapi/_lw_i_p_server_8h_source/","title":"File LwIPServer.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; LwIPServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n#if (LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP) || DOXYGEN\n\n#include \"WiFiServer.h\"\n\nclass LwIPServer : public IWiFiServer&lt;WiFiClient&gt; {\n  private:\n    int _sock;\n    int _sockAccepted;\n    uint32_t _addr;\n    uint16_t _port;\n    uint8_t _maxClients;\n    bool _active;\n    bool _noDelay = false;\n\n  private:\n    LwIPServer(uint32_t addr, uint16_t port = 80, uint8_t maxClients = 4);\n\n  public:\n    LwIPServer(uint16_t port = 80, uint8_t maxClients = 4) : LwIPServer((uint32_t)0, port, maxClients) {}\n\n    LwIPServer(int port = 80, uint8_t maxClients = 4) : LwIPServer((uint32_t)0, port, maxClients) {}\n\n    LwIPServer(const IPAddress &amp;addr, uint16_t port = 80, uint8_t maxClients = 4)\n        : LwIPServer((uint32_t)addr, port, maxClients) {}\n\n    operator bool();\n\n    bool begin(uint16_t port = 0, bool reuseAddr = true);\n    void end();\n    WiFiClient accept();\n\n    size_t write(const uint8_t *buffer, size_t size) {\n        return 0;\n    }\n\n    void stopAll() {}\n\n    int setTimeout(uint32_t seconds);\n    void setNoDelay(bool noDelay);\n    bool getNoDelay();\n    bool hasClient();\n};\n\ntypedef LwIPServer WiFiServer;\n\n#endif\n</code></pre>"},{"location":"ltapi/_wi_fi_server_8h/","title":"File WiFiServer.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; WiFiServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Print.h&gt;</code></li> <li><code>#include \"WiFiClient.h\"</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_server_8h/#classes","title":"Classes","text":"Type Name     class IWiFiServer &lt;typename TWiFiClient, typename&gt;     <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiServer/WiFiServer.h</code></p>"},{"location":"ltapi/_wi_fi_server_8h_source/","title":"File WiFiServer.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiServer &gt; WiFiServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Server.h - Server class for Raspberry Pi\n  Copyright (c) 2016 Hristo Gochkov  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Print.h&gt;\n\n#include \"WiFiClient.h\"\n\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename TWiFiClient, typename = std::enable_if&lt;std::is_base_of&lt;IWiFiClient, TWiFiClient&gt;::value&gt;&gt;\n\nclass IWiFiServer : public Print { // arduino::Server is useless anyway\n  public:\n    void listenOnLocalhost() {}\n\n    IWiFiServer(uint16_t port = 80, uint8_t maxClients = 4) {}\n\n    IWiFiServer(const IPAddress &amp;addr, uint16_t port = 80, uint8_t maxClients = 4) {}\n\n    ~IWiFiServer() {\n        stop();\n    }\n\n    TWiFiClient available() {\n        return accept();\n    };\n\n    virtual operator bool() = 0;\n\n    virtual bool begin(uint16_t port = 0, bool reuseAddr = true) = 0;\n    virtual void end()                                           = 0;\n    virtual TWiFiClient accept()                                 = 0;\n\n    void close() {\n        end();\n    }\n\n    void stop() {\n        end();\n    }\n\n    virtual int setTimeout(uint32_t seconds) = 0;\n    virtual void stopAll()                   = 0;\n    virtual void setNoDelay(bool noDelay)    = 0;\n    virtual bool getNoDelay()                = 0;\n    virtual bool hasClient()                 = 0;\n\n    size_t write(uint8_t data) {\n        return write(&amp;data, 1);\n    }\n\n    using Print::write;\n};\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n#include \"LwIPServer.h\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_947f33558ea20e7a91b0d58d77bc396d/","title":"Dir cores/common/arduino/libraries/common/WiFiUdp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp</p>"},{"location":"ltapi/dir_947f33558ea20e7a91b0d58d77bc396d/#files","title":"Files","text":"Type Name     file LwIPUdp.cpp    file LwIPUdp.h    file WiFiUdp.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/</code></p>"},{"location":"ltapi/_lw_i_p_udp_8cpp/","title":"File LwIPUdp.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; LwIPUdp.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/LwIPUdp.cpp</code></p>"},{"location":"ltapi/_lw_i_p_udp_8cpp_source/","title":"File LwIPUdp.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; LwIPUdp.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Udp.cpp - UDP class for Raspberry Pi\n  Copyright (c) 2016 Hristo Gochkov  All right reserved.\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPUdp.h\"\n\nextern \"C\" {\n\n#include &lt;lwip/netdb.h&gt;\n#include &lt;lwip/sockets.h&gt;\n\n} // extern \"C\"\n\n#undef write\n#undef read\n\nLwIPUDP::LwIPUDP() : udp_server(-1), server_port(0), remote_port(0), tx_buffer(0), tx_buffer_len(0), rx_buffer(0) {}\n\nLwIPUDP::~LwIPUDP() {\n    stop();\n}\n\nuint8_t LwIPUDP::begin(IPAddress address, uint16_t port) {\n    stop();\n\n    server_port = port;\n\n    tx_buffer = new char[1460];\n    if (!tx_buffer) {\n        log_e(\"could not create tx buffer: %d\", errno);\n        return 0;\n    }\n\n    if ((udp_server = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {\n        log_e(\"could not create socket: %d\", errno);\n        return 0;\n    }\n\n    int yes = 1;\n    if (setsockopt(udp_server, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(yes)) &lt; 0) {\n        log_e(\"could not set socket option: %d\", errno);\n        stop();\n        return 0;\n    }\n\n    struct sockaddr_in addr;\n    memset((char *)&amp;addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_port        = htons(server_port);\n    addr.sin_addr.s_addr = (in_addr_t)address;\n    if (bind(udp_server, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1) {\n        log_e(\"could not bind socket: %d\", errno);\n        stop();\n        return 0;\n    }\n    fcntl(udp_server, F_SETFL, O_NONBLOCK);\n    return 1;\n}\n\nuint8_t LwIPUDP::begin(uint16_t p) {\n    return begin(IPAddress((uint32_t)INADDR_ANY), p);\n}\n\nuint8_t LwIPUDP::beginMulticast(IPAddress a, uint16_t p) {\n    if (begin(IPAddress((uint32_t)INADDR_ANY), p)) {\n        if ((uint32_t)a != 0) {\n            struct ip_mreq mreq;\n            mreq.imr_multiaddr.s_addr = (in_addr_t)a;\n            mreq.imr_interface.s_addr = INADDR_ANY;\n            if (setsockopt(udp_server, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0) {\n                log_e(\"could not join igmp: %d\", errno);\n                stop();\n                return 0;\n            }\n            multicast_ip = a;\n        }\n        return 1;\n    }\n    return 0;\n}\n\nvoid LwIPUDP::stop() {\n    if (tx_buffer) {\n        delete[] tx_buffer;\n        tx_buffer = NULL;\n    }\n    tx_buffer_len = 0;\n    if (rx_buffer) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = NULL;\n        delete b;\n    }\n    if (udp_server == -1)\n        return;\n    if ((uint32_t)multicast_ip != 0) {\n        struct ip_mreq mreq;\n        mreq.imr_multiaddr.s_addr = (in_addr_t)multicast_ip;\n        mreq.imr_interface.s_addr = (in_addr_t)0;\n        setsockopt(udp_server, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, sizeof(mreq));\n        multicast_ip = IPAddress((uint32_t)INADDR_ANY);\n    }\n    close(udp_server);\n    udp_server = -1;\n}\n\nint LwIPUDP::beginMulticastPacket() {\n    if (!server_port || multicast_ip == IPAddress((uint32_t)INADDR_ANY))\n        return 0;\n    remote_ip   = multicast_ip;\n    remote_port = server_port;\n    return beginPacket();\n}\n\nint LwIPUDP::beginPacket() {\n    if (!remote_port)\n        return 0;\n\n    // allocate tx_buffer if is necessary\n    if (!tx_buffer) {\n        tx_buffer = new char[1460];\n        if (!tx_buffer) {\n            log_e(\"could not create tx buffer: %d\", errno);\n            return 0;\n        }\n    }\n\n    tx_buffer_len = 0;\n\n    // check whereas socket is already open\n    if (udp_server != -1)\n        return 1;\n\n    if ((udp_server = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {\n        log_e(\"could not create socket: %d\", errno);\n        return 0;\n    }\n\n    fcntl(udp_server, F_SETFL, O_NONBLOCK);\n\n    return 1;\n}\n\nint LwIPUDP::beginPacket(IPAddress ip, uint16_t port) {\n    remote_ip   = ip;\n    remote_port = port;\n    return beginPacket();\n}\n\nint LwIPUDP::beginPacket(const char *host, uint16_t port) {\n    struct hostent *server;\n    server = gethostbyname(host);\n    if (server == NULL) {\n        log_e(\"could not get host from dns: %d\", errno);\n        return 0;\n    }\n    return beginPacket(IPAddress((const uint8_t *)(server-&gt;h_addr_list[0])), port);\n}\n\nint LwIPUDP::endPacket() {\n    struct sockaddr_in recipient;\n    recipient.sin_addr.s_addr = (uint32_t)remote_ip;\n    recipient.sin_family      = AF_INET;\n    recipient.sin_port        = htons(remote_port);\n    int sent = sendto(udp_server, tx_buffer, tx_buffer_len, 0, (struct sockaddr *)&amp;recipient, sizeof(recipient));\n    if (sent &lt; 0) {\n        log_e(\"could not send data: %d\", errno);\n        return 0;\n    }\n    return 1;\n}\n\nsize_t LwIPUDP::write(uint8_t data) {\n    if (tx_buffer_len == 1460) {\n        endPacket();\n        tx_buffer_len = 0;\n    }\n    tx_buffer[tx_buffer_len++] = data;\n    return 1;\n}\n\nsize_t LwIPUDP::write(const uint8_t *buffer, size_t size) {\n    size_t i;\n    for (i = 0; i &lt; size; i++)\n        write(buffer[i]);\n    return i;\n}\n\nint LwIPUDP::parsePacket() {\n    if (rx_buffer)\n        return 0;\n    struct sockaddr_in si_other;\n    int slen  = sizeof(si_other), len;\n    char *buf = new char[1460];\n    if (!buf) {\n        return 0;\n    }\n    if ((len = recvfrom(udp_server, buf, 1460, MSG_DONTWAIT, (struct sockaddr *)&amp;si_other, (socklen_t *)&amp;slen)) == -1) {\n        delete[] buf;\n        if (errno == EWOULDBLOCK) {\n            return 0;\n        }\n        log_e(\"could not receive data: %d\", errno);\n        return 0;\n    }\n    remote_ip   = IPAddress(si_other.sin_addr.s_addr);\n    remote_port = ntohs(si_other.sin_port);\n    if (len &gt; 0) {\n        rx_buffer = new cbuf(len);\n        rx_buffer-&gt;write(buf, len);\n    }\n    delete[] buf;\n    return len;\n}\n\nint LwIPUDP::available() {\n    if (!rx_buffer)\n        return 0;\n    return rx_buffer-&gt;available();\n}\n\nint LwIPUDP::read() {\n    if (!rx_buffer)\n        return -1;\n    int out = rx_buffer-&gt;read();\n    if (!rx_buffer-&gt;available()) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = 0;\n        delete b;\n    }\n    return out;\n}\n\nint LwIPUDP::read(unsigned char *buffer, size_t len) {\n    return read((char *)buffer, len);\n}\n\nint LwIPUDP::read(char *buffer, size_t len) {\n    if (!rx_buffer)\n        return 0;\n    int out = rx_buffer-&gt;read(buffer, len);\n    if (!rx_buffer-&gt;available()) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = 0;\n        delete b;\n    }\n    return out;\n}\n\nint LwIPUDP::peek() {\n    if (!rx_buffer)\n        return -1;\n    return rx_buffer-&gt;peek();\n}\n\nvoid LwIPUDP::flush() {\n    if (!rx_buffer)\n        return;\n    cbuf *b   = rx_buffer;\n    rx_buffer = 0;\n    delete b;\n}\n\nIPAddress LwIPUDP::remoteIP() {\n    return remote_ip;\n}\n\nuint16_t LwIPUDP::remotePort() {\n    return remote_port;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_udp_8h/","title":"File LwIPUdp.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; LwIPUdp.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiUdp.h\"</code></li> <li><code>#include &lt;cbuf.h&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_udp_8h/#classes","title":"Classes","text":"Type Name     class LwIPUDP"},{"location":"ltapi/_lw_i_p_udp_8h/#public-types","title":"Public Types","text":"Type Name     typedef LwIPUDP WiFiUDP"},{"location":"ltapi/_lw_i_p_udp_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_lw_i_p_udp_8h/#typedef-wifiudp","title":"typedef WiFiUDP","text":"<pre><code>typedef LwIPUDP WiFiUDP;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/LwIPUdp.h</code></p>"},{"location":"ltapi/_lw_i_p_udp_8h_source/","title":"File LwIPUdp.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; LwIPUdp.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-09-10. */\n\n#pragma once\n\n#if (LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP) || DOXYGEN\n\n#include \"WiFiUdp.h\"\n\n#include &lt;cbuf.h&gt;\n\nclass LwIPUDP : public IWiFiUDP {\n  private:\n    int udp_server;\n    IPAddress multicast_ip;\n    IPAddress remote_ip;\n    uint16_t server_port;\n    uint16_t remote_port;\n    char *tx_buffer;\n    size_t tx_buffer_len;\n    cbuf *rx_buffer;\n\n  public:\n    LwIPUDP();\n    ~LwIPUDP();\n    uint8_t begin(IPAddress ip, uint16_t port);\n    uint8_t begin(uint16_t port);\n    uint8_t beginMulticast(IPAddress ip, uint16_t port);\n    void stop();\n    int beginMulticastPacket();\n    int beginPacket();\n    int beginPacket(IPAddress ip, uint16_t port);\n    int beginPacket(const char *host, uint16_t port);\n    int endPacket();\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    int parsePacket();\n    int available();\n    int read();\n    int read(unsigned char *buffer, size_t len);\n    int read(char *buffer, size_t len);\n    int peek();\n    void flush();\n    IPAddress remoteIP();\n    uint16_t remotePort();\n};\n\ntypedef LwIPUDP WiFiUDP;\n\n#endif\n</code></pre>"},{"location":"ltapi/_wi_fi_udp_8h/","title":"File WiFiUdp.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; WiFiUdp.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Udp.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_udp_8h/#classes","title":"Classes","text":"Type Name     class IWiFiUDP      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/WiFiUdp/WiFiUdp.h</code></p>"},{"location":"ltapi/_wi_fi_udp_8h_source/","title":"File WiFiUdp.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; WiFiUdp &gt; WiFiUdp.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Udp.h&gt;\n\nclass IWiFiUDP : public UDP {\n  public:\n    IWiFiUDP() {}\n\n    ~IWiFiUDP() {}\n\n    virtual uint8_t begin(IPAddress ip, uint16_t port)          = 0;\n    virtual uint8_t begin(uint16_t port)                        = 0;\n    virtual uint8_t beginMulticast(IPAddress ip, uint16_t port) = 0;\n    virtual void stop()                                         = 0;\n    virtual int beginMulticastPacket()                          = 0;\n    virtual int beginPacket()                                   = 0;\n    virtual int beginPacket(IPAddress ip, uint16_t port)        = 0;\n    virtual int beginPacket(const char *host, uint16_t port)    = 0;\n    virtual int endPacket()                                     = 0;\n    virtual size_t write(uint8_t)                               = 0;\n    virtual size_t write(const uint8_t *buffer, size_t size)    = 0;\n    virtual int parsePacket()                                   = 0;\n    virtual int available()                                     = 0;\n    virtual int read()                                          = 0;\n    virtual int read(unsigned char *buffer, size_t len)         = 0;\n    virtual int read(char *buffer, size_t len)                  = 0;\n    virtual int peek()                                          = 0;\n    virtual void flush()                                        = 0;\n    virtual IPAddress remoteIP()                                = 0;\n    virtual uint16_t remotePort()                               = 0;\n};\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n#include \"LwIPUdp.h\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_5cec7dea66206196679083f825c4cd25/","title":"Dir cores/common/arduino/libraries/common/mDNS","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; mDNS</p>"},{"location":"ltapi/dir_5cec7dea66206196679083f825c4cd25/#files","title":"Files","text":"Type Name     file LwIPmDNS.cpp    file mDNS.cpp    file mDNS.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/mDNS/</code></p>"},{"location":"ltapi/_lw_i_pm_d_n_s_8cpp/","title":"File LwIPmDNS.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; LwIPmDNS.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/mDNS/LwIPmDNS.cpp</code></p>"},{"location":"ltapi/_lw_i_pm_d_n_s_8cpp_source/","title":"File LwIPmDNS.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; LwIPmDNS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#if LT_HAS_LWIP2\n\n#include \"mDNS.h\"\n#include &lt;vector&gt;\n\nextern \"C\" {\n#include &lt;errno.h&gt;\n#include &lt;lwip/apps/mdns.h&gt;\n#include &lt;lwip/igmp.h&gt;\n#include &lt;lwip/init.h&gt;\n#include &lt;lwip/netif.h&gt;\n}\n\n#if LWIP_VERSION_SIMPLE &lt; 20100 &amp;&amp; defined(LWIP_NETIF_EXT_STATUS_CALLBACK)\n#warning \"LWIP_NETIF_EXT_STATUS_CALLBACK not available before lwIP 2.1.0\"\n#undef LWIP_NETIF_EXT_STATUS_CALLBACK\n#endif\n\n#if LWIP_MDNS_RESPONDER\n\nstruct CachedService {\n    CachedService(const char *_name, const char *_service, mdns_sd_proto _proto, uint16_t _port)\n        : name(strdup(_name)), service(strdup(_service)), proto(_proto), port(_port) {}\n\n    CachedService(const CachedService &amp;)            = delete;\n    CachedService &amp;operator=(const CachedService &amp;) = delete;\n\n    CachedService(CachedService &amp;&amp;other)\n        : name(other.name), service(other.service), proto(other.proto), port(other.port),\n          records(std::move(other.records)) {\n        other.name    = nullptr;\n        other.service = nullptr;\n        other.records.clear();\n    }\n\n    ~CachedService() {\n        if (name) {\n            free(name);\n        }\n\n        if (service) {\n            free(service);\n        }\n\n        for (auto &amp;str : records) {\n            if (str) {\n                free(str);\n            }\n        }\n    }\n\n    char *name;\n    char *service;\n    mdns_sd_proto proto;\n    uint16_t port;\n    std::vector&lt;char *&gt; records;\n};\n\nstatic std::vector&lt;CachedService&gt; sCachedServices;\n\nstatic const char *hostName;\n#ifdef LWIP_NETIF_EXT_STATUS_CALLBACK\nNETIF_DECLARE_EXT_CALLBACK(netif_callback)\n#endif\n\nmDNS::mDNS() {}\n\nmDNS::~mDNS() {\n    cleanup();\n}\n\nvoid mDNS::cleanup() {\n    sCachedServices.clear();\n\n    free((void *)hostName);\n    hostName = NULL;\n\n    free((void *)instanceName);\n    instanceName = NULL;\n}\n\nstatic void mdnsTxtCallback(struct mdns_service *service, void *userdata) {\n    size_t index = (size_t)userdata;\n    if (index &gt;= sCachedServices.size())\n        return;\n\n    for (const auto &amp;record : sCachedServices[index].records) {\n        err_t err = mdns_resp_add_service_txtitem(service, record, strlen(record));\n        if (err != ERR_OK) {\n            LT_DM(MDNS, \"Error %d while adding txt record: %s\", err, record);\n        }\n    }\n}\n\n#if LWIP_VERSION_SIMPLE &lt; 20200 // TTL removed in LwIP commit 62fb2fd749b (2.2.0 release)\nstatic void mdnsStatusCallback(struct netif *netif, uint8_t result) {\n    LT_DM(MDNS, \"Status: netif %u, status %u\", netif-&gt;num, result);\n}\n#else\nstatic void mdnsStatusCallback(struct netif *netif, uint8_t result, int8_t slot) {\n    LT_DM(MDNS, \"Status: netif %u, status %u slot %d\", netif-&gt;num, result, slot);\n}\n#endif\n\n#ifdef LWIP_NETIF_EXT_STATUS_CALLBACK\nstatic void addServices(struct netif *netif) {\n    for (uint8_t i = 0; i &lt; sCachedServices.size(); i++) {\n        const auto &amp;cachedService = sCachedServices[i];\n        LT_DM(\n            MDNS,\n            \"Add service: netif %u / %s / %s / %u / %u\",\n            netif-&gt;num,\n            cachedService.name,\n            cachedService.service,\n            cachedService.proto,\n            cachedService.port\n        );\n        s8_t slot = mdns_resp_add_service(\n            netif,\n            cachedService.name,\n            cachedService.service,\n            cachedService.proto,\n            cachedService.port,\n#if LWIP_VERSION_SIMPLE &lt; 20200 // TTL removed in LwIP commit 62fb2fd749b (2.2.0 release)\n            255,\n#endif\n            mdnsTxtCallback,\n            reinterpret_cast&lt;void *&gt;(i) // index of newly added service\n        );\n\n        if (slot &lt; 0) {\n            LT_DM(MDNS, \"mdns_resp_add_service returned error %d\", slot);\n        }\n    }\n}\n#endif\n\nstatic bool enableMDNS(struct netif *netif) {\n    if (netif_is_up(netif)) {\n        LT_DM(MDNS, \"Starting mDNS on netif %u\", netif-&gt;num);\n        if ((netif-&gt;flags &amp; NETIF_FLAG_IGMP) == 0) {\n            netif-&gt;flags |= NETIF_FLAG_IGMP;\n            igmp_start(netif);\n            LT_DM(MDNS, \"Added IGMP to netif %u\", netif-&gt;num);\n        }\n#if LWIP_VERSION_SIMPLE &lt; 20200 // TTL removed in LwIP commit 62fb2fd749b (2.2.0 release)\n        err_t ret = mdns_resp_add_netif(netif, hostName, 255);\n#else\n        err_t ret = mdns_resp_add_netif(netif, hostName);\n#endif\n        if (ret == ERR_OK) {\n            LT_DM(MDNS, \"mDNS started on netif %u, announcing it to network\", netif-&gt;num);\n#if LWIP_VERSION_SIMPLE &gt;= 20100\n            mdns_resp_announce(netif);\n#else\n#warning \"lwIP version older than 2.1.0, mdns_resp_announce() unavailable\"\n#endif\n            return true;\n        } else {\n            LT_DM(MDNS, \"Cannot start mDNS on netif %u; ret=%d, errno=%d\", netif-&gt;num, ret, errno);\n        }\n    }\n    return false;\n}\n\n#ifdef LWIP_NETIF_EXT_STATUS_CALLBACK\nstatic void mdns_netif_ext_status_callback(\n    struct netif *netif,\n    netif_nsc_reason_t reason,\n    const netif_ext_callback_args_t *args\n) {\n    if (reason &amp; LWIP_NSC_NETIF_REMOVED) {\n        LT_DM(MDNS, \"Netif removed, stopping mDNS on netif %u\", netif-&gt;num);\n        mdns_resp_remove_netif(netif);\n    } else if ((reason &amp; LWIP_NSC_STATUS_CHANGED) || (reason &amp; LWIP_NSC_NETIF_ADDED)) {\n        LT_DM(MDNS, \"Netif changed/added, starting mDNS on netif %u\", netif-&gt;num);\n        if (enableMDNS(netif) &amp;&amp; sCachedServices.size() &gt; 0) {\n            LT_DM(MDNS, \"Adding services to netif %u\", netif-&gt;num);\n            addServices(netif);\n        }\n    }\n}\n#endif\n\nbool mDNS::begin(const char *hostname) {\n    hostName = strdup(hostname);\n    setInstanceName(hostname);\n#ifdef LWIP_NETIF_EXT_STATUS_CALLBACK\n    netif_add_ext_callback(&amp;netif_callback, mdns_netif_ext_status_callback);\n#endif\n    LT_DM(MDNS, \"Starting (%s)\", hostname);\n#if LWIP_VERSION_MAJOR &gt;= 2 &amp;&amp; LWIP_VERSION_MINOR &gt;= 1\n    mdns_resp_register_name_result_cb(mdnsStatusCallback);\n#endif\n    mdns_resp_init();\n    struct netif *netif;\n    for (netif = netif_list; netif != NULL; netif = netif-&gt;next) {\n        enableMDNS(netif);\n    }\n    return true;\n}\n\nvoid mDNS::end() {\n#ifdef LWIP_NETIF_EXT_STATUS_CALLBACK\n    netif_remove_ext_callback(&amp;netif_callback);\n#endif\n\n    struct netif *netif = netif_list;\n    while (netif != NULL) {\n        if (netif_is_up(netif))\n            mdns_resp_remove_netif(netif);\n        netif = netif-&gt;next;\n    }\n\n    cleanup();\n}\n\nbool mDNS::addServiceImpl(const char *name, const char *service, uint8_t proto, uint16_t port) {\n    bool added          = false;\n    struct netif *netif = netif_list;\n\n    std::size_t serviceIndex = sCachedServices.size();\n    // add the service to TXT record arrays\n    sCachedServices.emplace_back(name, service, (mdns_sd_proto)proto, port);\n\n    while (netif != NULL) {\n        if (netif_is_up(netif)) {\n            // register TXT callback;\n            // pass service index as userdata parameter\n            LT_DM(MDNS, \"Add service: netif %u / %s / %s / %u / %u\", netif-&gt;num, name, service, proto, port);\n            s8_t slot = mdns_resp_add_service(\n                netif,\n                name,\n                service,\n                (mdns_sd_proto)proto,\n                port,\n#if LWIP_VERSION_SIMPLE &lt; 20200 // TTL removed in LwIP commit 62fb2fd749b (2.2.0 release)\n                255,\n#endif\n                mdnsTxtCallback,\n                (void *)serviceIndex // index of newly added service\n            );\n\n            if (slot &lt; 0) {\n                LT_DM(MDNS, \"mdns_resp_add_service returned error %d\", slot);\n            }\n\n            added = true;\n        }\n        netif = netif-&gt;next;\n    }\n\n    return added;\n}\n\nbool mDNS::addServiceTxtImpl(const char *service, uint8_t proto, const char *item) {\n    uint8_t i;\n    for (i = 0; i &lt; sCachedServices.size(); i++) {\n        const auto &amp;cachedService = sCachedServices[i];\n        // find a matching service\n        if (strcmp(cachedService.service, service) == 0 &amp;&amp; cachedService.proto == proto) {\n            break;\n        }\n    }\n    if (i == sCachedServices.size())\n        return false;\n\n    sCachedServices[i].records.push_back(strdup(item));\n    return true;\n}\n\nMDNSResponder MDNS;\n\n#endif\n\n#endif\n</code></pre>"},{"location":"ltapi/m_d_n_s_8cpp/","title":"File mDNS.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; mDNS.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mDNS.h\"</code></li> </ul>"},{"location":"ltapi/m_d_n_s_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name     char * ensureUnderscore (char * value)    void freeIfCopied (const char * original, char * duplicate)"},{"location":"ltapi/m_d_n_s_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/m_d_n_s_8cpp/#function-ensureunderscore","title":"function ensureUnderscore","text":"<pre><code>static char * ensureUnderscore (\n    char * value\n) \n</code></pre>"},{"location":"ltapi/m_d_n_s_8cpp/#function-freeifcopied","title":"function freeIfCopied","text":"<pre><code>static inline void freeIfCopied (\n    const char * original,\n    char * duplicate\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/mDNS/mDNS.cpp</code></p>"},{"location":"ltapi/m_d_n_s_8cpp_source/","title":"File mDNS.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; mDNS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-08-26. */\n\n#include \"mDNS.h\"\n\nstatic char *ensureUnderscore(char *value) {\n    if (value[0] == '_') {\n        return value;\n    }\n    size_t len   = strlen(value) + 1 + 1; // 1 for underscore, 1 for null-terminator\n    char *result = (char *)malloc(len);\n    result[0]    = '_';\n    strcpy(result + 1, value);\n    return result;\n}\n\nstatic inline void freeIfCopied(const char *original, char *duplicate) {\n    if ((duplicate) &amp;&amp; (original != duplicate)) {\n        free(duplicate);\n    }\n}\n\nvoid mDNS::setInstanceName(const char *name) {\n    if (instanceName)\n        free(instanceName);\n    instanceName = strdup(name);\n}\n\nbool mDNS::addService(char *service, char *proto, uint16_t port) {\n    char *_service = ensureUnderscore(service);\n    uint8_t _proto = strncmp(proto + (proto[0] == '_'), \"tcp\", 3) == 0 ? MDNS_TCP : MDNS_UDP;\n\n    bool result = addServiceImpl(instanceName ? instanceName : \"LT mDNS\", _service, _proto, port);\n    freeIfCopied(service, _service);\n    return result;\n}\n\nbool mDNS::addServiceTxt(char *service, char *proto, char *key, char *value) {\n    char *_service = ensureUnderscore(service);\n    uint8_t _proto = strncmp(proto + (proto[0] == '_'), \"tcp\", 3) == 0 ? MDNS_TCP : MDNS_UDP;\n\n    uint8_t txt_len = strlen(key) + strlen(value) + 1;\n    char *txt       = (char *)malloc(txt_len + 1);\n    sprintf(txt, \"%s=%s\", key, value);\n\n    bool result = addServiceTxtImpl(_service, _proto, txt);\n    freeIfCopied(service, _service);\n    free(txt);\n    return result;\n}\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/","title":"File mDNS.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; mDNS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/IPv6Address.h&gt;</code></li> </ul>"},{"location":"ltapi/m_d_n_s_8h/#classes","title":"Classes","text":"Type Name     class mDNS"},{"location":"ltapi/m_d_n_s_8h/#public-types","title":"Public Types","text":"Type Name     typedef mDNS MDNSResponder"},{"location":"ltapi/m_d_n_s_8h/#public-attributes","title":"Public Attributes","text":"Type Name     MDNSResponder MDNS"},{"location":"ltapi/m_d_n_s_8h/#macros","title":"Macros","text":"Type Name     define MDNS_TCP  1   define MDNS_UDP  0"},{"location":"ltapi/m_d_n_s_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#typedef-mdnsresponder","title":"typedef MDNSResponder","text":"<pre><code>typedef mDNS MDNSResponder;\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#variable-mdns","title":"variable MDNS","text":"<pre><code>MDNSResponder MDNS;\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#define-mdns_tcp","title":"define MDNS_TCP","text":"<pre><code>#define MDNS_TCP 1\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#define-mdns_udp","title":"define MDNS_UDP","text":"<pre><code>#define MDNS_UDP 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/common/mDNS/mDNS.h</code></p>"},{"location":"ltapi/m_d_n_s_8h_source/","title":"File mDNS.h","text":"<p>File List &gt; arduino &gt; libraries &gt; common &gt; mDNS &gt; mDNS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\nESP8266 Multicast DNS (port of CC3000 Multicast DNS library)\nVersion 1.1\nCopyright (c) 2013 Tony DiCola (tony@tonydicola.com)\nESP8266 port (c) 2015 Ivan Grokhotkov (ivan@esp8266.com)\nMDNS-SD Suport 2015 Hristo Gochkov (hristo@espressif.com)\nExtended MDNS-SD support 2016 Lars Englund (lars.englund@gmail.com)\nRewritten for ESP32 by Hristo Gochkov (hristo@espressif.com)\n\nThis is a simple implementation of multicast DNS query support for an Arduino\nrunning on ESP32 chip.\n\nUsage:\n- Include the ESP32 Multicast DNS library in the sketch.\n- Call the begin method in the sketch's setup and provide a domain name (without\n  the '.local' suffix, i.e. just provide 'foo' to resolve 'foo.local'), and the\n  Adafruit CC3000 class instance.  Optionally provide a time to live (in seconds)\n  for the DNS record--the default is 1 hour.\n- Call the update method in each iteration of the sketch's loop function.\n\nLicense (MIT license):\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/IPv6Address.h&gt;\n\n#define MDNS_UDP 0\n#define MDNS_TCP 1\n\nclass mDNS {\n  private:\n    bool addServiceImpl(const char *name, const char *service, uint8_t proto, uint16_t port);\n    bool addServiceTxtImpl(const char *service, uint8_t proto, const char *item);\n    void cleanup();\n\n    char *instanceName = NULL;\n\n  public:\n    mDNS();\n    ~mDNS();\n\n    bool begin(const char *hostname);\n    void end();\n\n    void setInstanceName(const char *name);\n    bool addService(char *service, char *proto, uint16_t port);\n    bool addServiceTxt(char *service, char *proto, char *key, char *value);\n    // void enableArduino(uint16_t port = 3232, bool auth = false);\n    // void disableArduino();\n    // void enableWorkstation(esp_interface_t interface = ESP_IF_WIFI_STA);\n    // void disableWorkstation();\n\n    IPAddress queryHost(char *host, uint32_t timeout = 2000);\n    int queryService(char *service, char *proto);\n\n    String hostname(int idx);\n    IPAddress IP(int idx);\n    IPv6Address IPv6(int idx);\n    uint16_t port(int idx);\n    int numTxt(int idx);\n    bool hasTxt(int idx, const char *key);\n    String txt(int idx, const char *key);\n    String txt(int idx, int txtIdx);\n    String txtKey(int idx, int txtIdx);\n\n    void setInstanceName(String name) {\n        setInstanceName(name.c_str());\n    }\n\n    void setInstanceName(char *name) {\n        setInstanceName((const char *)name);\n    }\n\n    bool addService(const char *service, const char *proto, uint16_t port) {\n        return addService((char *)service, (char *)proto, port);\n    }\n\n    bool addService(String service, String proto, uint16_t port) {\n        return addService(service.c_str(), proto.c_str(), port);\n    }\n\n    void addServiceTxt(const char *service, const char *proto, const char *key, const char *value) {\n        addServiceTxt((char *)service, (char *)proto, (char *)key, (char *)value);\n    }\n\n    void addServiceTxt(String service, String proto, String key, String value) {\n        addServiceTxt(service.c_str(), proto.c_str(), key.c_str(), value.c_str());\n    }\n\n    IPAddress queryHost(const char *host, uint32_t timeout = 2000) {\n        return queryHost((char *)host, timeout);\n    }\n\n    IPAddress queryHost(String host, uint32_t timeout = 2000) {\n        return queryHost(host.c_str(), timeout);\n    }\n\n    int queryService(const char *service, const char *proto) {\n        return queryService((char *)service, (char *)proto);\n    }\n\n    int queryService(String service, String proto) {\n        return queryService(service.c_str(), proto.c_str());\n    }\n};\n\ntypedef mDNS MDNSResponder;\n\nextern MDNSResponder MDNS;\n</code></pre>"},{"location":"ltapi/dir_5ea3aad773d57a5f23d4c7a2455c87eb/","title":"Dir cores/common/arduino/libraries/ext","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext</p>"},{"location":"ltapi/dir_5ea3aad773d57a5f23d4c7a2455c87eb/#directories","title":"Directories","text":"Type Name     dir HTTPClient    dir StreamString    dir WebServer    dir WiFiMulti    dir base64    dir cbuf      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/</code></p>"},{"location":"ltapi/dir_317cbb6bf43941e79ffdd996bee8e3bd/","title":"Dir cores/common/arduino/libraries/ext/HTTPClient","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; HTTPClient</p>"},{"location":"ltapi/dir_317cbb6bf43941e79ffdd996bee8e3bd/#files","title":"Files","text":"Type Name     file HTTPClient.cpp    file HTTPClient.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/</code></p>"},{"location":"ltapi/_h_t_t_p_client_8cpp/","title":"File HTTPClient.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; HTTPClient &gt; HTTPClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/HTTPClient.cpp</code></p>"},{"location":"ltapi/_h_t_t_p_client_8cpp_source/","title":"File HTTPClient.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; HTTPClient &gt; HTTPClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n#include &lt;WiFi.h&gt;\n#include &lt;WiFiClientSecure.h&gt;\n#endif\n\n// #include &lt;StreamString.h&gt;\n#include &lt;base64.h&gt;\n\n#include \"HTTPClient.h\"\n\n#include &lt;time.h&gt;\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nclass TransportTraits {\n  public:\n    virtual ~TransportTraits() {}\n\n    virtual std::unique_ptr&lt;WiFiClient&gt; create() {\n        return std::unique_ptr&lt;WiFiClient&gt;(new WiFiClient());\n    }\n\n    virtual bool verify(WiFiClient &amp;client, const char *host) {\n        return true;\n    }\n};\n\nclass TLSTraits : public TransportTraits {\n  public:\n    TLSTraits(const char *CAcert, const char *clicert = nullptr, const char *clikey = nullptr)\n        : _cacert(CAcert), _clicert(clicert), _clikey(clikey) {}\n\n    std::unique_ptr&lt;WiFiClient&gt; create() override {\n        return std::unique_ptr&lt;WiFiClient&gt;(new WiFiClientSecure());\n    }\n\n    bool verify(WiFiClient &amp;client, const char *host) override {\n        WiFiClientSecure &amp;wcs = static_cast&lt;WiFiClientSecure &amp;&gt;(client);\n        if (_cacert == nullptr) {\n            wcs.setInsecure();\n        } else {\n            wcs.setCACert(_cacert);\n            wcs.setCertificate(_clicert);\n            wcs.setPrivateKey(_clikey);\n        }\n        return true;\n    }\n\n  protected:\n    const char *_cacert;\n    const char *_clicert;\n    const char *_clikey;\n};\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nHTTPClient::HTTPClient() {}\n\nHTTPClient::~HTTPClient() {\n    if (_client) {\n        _client-&gt;stop();\n    }\n    if (_currentHeaders) {\n        delete[] _currentHeaders;\n    }\n    if (_tcpDeprecated) {\n        _tcpDeprecated.reset(nullptr);\n    }\n    if (_transportTraits) {\n        _transportTraits.reset(nullptr);\n    }\n}\n\nvoid HTTPClient::clear() {\n    _returnCode = 0;\n    _size       = -1;\n    _headers    = \"\";\n}\n\nbool HTTPClient::begin(WiFiClient &amp;client, String url) {\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n#endif\n\n    _client = &amp;client;\n\n    // check for : (http: or https:)\n    int index = url.indexOf(':');\n    if (index &lt; 0) {\n        log_d(\"failed to parse protocol\");\n        return false;\n    }\n\n    String protocol = url.substring(0, index);\n    if (protocol != \"http\" &amp;&amp; protocol != \"https\") {\n        log_d(\"unknown protocol '%s'\", protocol.c_str());\n        return false;\n    }\n\n    _port   = (protocol == \"https\" ? 443 : 80);\n    _secure = (protocol == \"https\");\n    return beginInternal(url, protocol.c_str());\n}\n\nbool HTTPClient::begin(WiFiClient &amp;client, String host, uint16_t port, String uri, bool https) {\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n#endif\n\n    _client = &amp;client;\n\n    clear();\n    _host     = host;\n    _port     = port;\n    _uri      = uri;\n    _protocol = (https ? \"https\" : \"http\");\n    _secure   = https;\n    return true;\n}\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nbool HTTPClient::begin(String url, const char *CAcert) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _port = 443;\n    if (!beginInternal(url, \"https\")) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert));\n    if (!_transportTraits) {\n        log_e(\"could not create transport traits\");\n        return false;\n    }\n\n    return true;\n}\n\nbool HTTPClient::begin(String url) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _port = 80;\n    if (!beginInternal(url, \"http\")) {\n        return begin(url, (const char *)NULL);\n    }\n    _transportTraits = TransportTraitsPtr(new TransportTraits());\n    if (!_transportTraits) {\n        log_e(\"could not create transport traits\");\n        return false;\n    }\n\n    return true;\n}\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nbool HTTPClient::beginInternal(String url, const char *expectedProtocol) {\n    log_v(\"url: %s\", url.c_str());\n\n    // check for : (http: or https:\n    int index = url.indexOf(':');\n    if (index &lt; 0) {\n        log_e(\"failed to parse protocol\");\n        return false;\n    }\n\n    _protocol = url.substring(0, index);\n    if (_protocol != expectedProtocol) {\n        log_d(\"unexpected protocol: %s, expected %s\", _protocol.c_str(), expectedProtocol);\n        return false;\n    }\n\n    url.remove(0, (index + 3)); // remove http:// or https://\n\n    index = url.indexOf('/');\n    if (index == -1) {\n        index = url.length();\n        url += '/';\n    }\n    String host = url.substring(0, index);\n    url.remove(0, index); // remove host part\n\n    // get Authorization\n    index = host.indexOf('@');\n    if (index &gt;= 0) {\n        // auth info\n        String auth = host.substring(0, index);\n        host.remove(0, index + 1); // remove auth part including @\n        _base64Authorization = base64::encode(auth);\n    }\n\n    // get port\n    index = host.indexOf(':');\n    String the_host;\n    if (index &gt;= 0) {\n        the_host = host.substring(0, index); // hostname\n        host.remove(0, (index + 1));         // remove hostname + :\n        _port = host.toInt();                // get port\n    } else {\n        the_host = host;\n    }\n    if (_host != the_host &amp;&amp; connected()) {\n        log_d(\"switching host from '%s' to '%s'. disconnecting first\", _host.c_str(), the_host.c_str());\n        _canReuse = false;\n        disconnect(true);\n    }\n    _host = the_host;\n    _uri  = url;\n    log_d(\"protocol: %s, host: %s port: %d url: %s\", _protocol.c_str(), _host.c_str(), _port, _uri.c_str());\n    return true;\n}\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nbool HTTPClient::begin(String host, uint16_t port, String uri) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host            = host;\n    _port            = port;\n    _uri             = uri;\n    _transportTraits = TransportTraitsPtr(new TransportTraits());\n    log_d(\"host: %s port: %d uri: %s\", host.c_str(), port, uri.c_str());\n    return true;\n}\n\nbool HTTPClient::begin(String host, uint16_t port, String uri, const char *CAcert) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host = host;\n    _port = port;\n    _uri  = uri;\n\n    if (strlen(CAcert) == 0) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert));\n    return true;\n}\n\nbool HTTPClient::begin(\n    String host,\n    uint16_t port,\n    String uri,\n    const char *CAcert,\n    const char *cli_cert,\n    const char *cli_key\n) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host = host;\n    _port = port;\n    _uri  = uri;\n\n    if (strlen(CAcert) == 0) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert, cli_cert, cli_key));\n    return true;\n}\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nvoid HTTPClient::end(void) {\n    disconnect(false);\n    clear();\n}\n\nvoid HTTPClient::disconnect(bool preserveClient) {\n    if (connected()) {\n        if (_client-&gt;available() &gt; 0) {\n            log_d(\"still data in buffer (%d), clean up.\\n\", _client-&gt;available());\n            _client-&gt;flush();\n        }\n\n        if (_reuse &amp;&amp; _canReuse) {\n            log_d(\"tcp keep open for reuse\");\n        } else {\n            log_d(\"tcp stop\");\n            _client-&gt;stop();\n            if (!preserveClient) {\n                _client = nullptr;\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n                if (_tcpDeprecated) {\n                    _transportTraits.reset(nullptr);\n                    _tcpDeprecated.reset(nullptr);\n                }\n#endif\n            }\n        }\n    } else {\n        log_d(\"tcp is closed\\n\");\n    }\n}\n\nbool HTTPClient::connected() {\n    if (_client) {\n        return ((_client-&gt;available() &gt; 0) || _client-&gt;connected());\n    }\n    return false;\n}\n\nvoid HTTPClient::setReuse(bool reuse) {\n    _reuse = reuse;\n}\n\nvoid HTTPClient::setUserAgent(const String &amp;userAgent) {\n    _userAgent = userAgent;\n}\n\nvoid HTTPClient::setAuthorization(const char *user, const char *password) {\n    if (user &amp;&amp; password) {\n        String auth = user;\n        auth += \":\";\n        auth += password;\n        _base64Authorization = base64::encode(auth);\n    }\n}\n\nvoid HTTPClient::setAuthorization(const char *auth) {\n    if (auth) {\n        _base64Authorization = auth;\n    }\n}\n\nvoid HTTPClient::setAuthorizationType(const char *authType) {\n    if (authType) {\n        _authorizationType = authType;\n    }\n}\n\nvoid HTTPClient::setConnectTimeout(int32_t connectTimeout) {\n    _connectTimeout = connectTimeout;\n}\n\nvoid HTTPClient::setTimeout(uint16_t timeout) {\n    _tcpTimeout = timeout;\n    if (connected()) {\n        _client-&gt;setTimeout((timeout + 500) / 1000);\n    }\n}\n\nvoid HTTPClient::useHTTP10(bool useHTTP10) {\n    _useHTTP10 = useHTTP10;\n    _reuse     = !useHTTP10;\n}\n\nint HTTPClient::GET() {\n    return sendRequest(\"GET\");\n}\n\nint HTTPClient::POST(uint8_t *payload, size_t size) {\n    return sendRequest(\"POST\", payload, size);\n}\n\nint HTTPClient::POST(String payload) {\n    return POST((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::PATCH(uint8_t *payload, size_t size) {\n    return sendRequest(\"PATCH\", payload, size);\n}\n\nint HTTPClient::PATCH(String payload) {\n    return PATCH((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::PUT(uint8_t *payload, size_t size) {\n    return sendRequest(\"PUT\", payload, size);\n}\n\nint HTTPClient::PUT(String payload) {\n    return PUT((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::sendRequest(const char *type, String payload) {\n    return sendRequest(type, (uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::sendRequest(const char *type, uint8_t *payload, size_t size) {\n    int code;\n    bool redirect          = false;\n    uint16_t redirectCount = 0;\n    do {\n        // wipe out any existing headers from previous request\n        for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n            if (_currentHeaders[i].value.length() &gt; 0) {\n                _currentHeaders[i].value = \"\"; // LT: changed from clear()\n            }\n        }\n\n        log_d(\"request type: '%s' redirCount: %d\\n\", type, redirectCount);\n\n        // connect to server\n        if (!connect()) {\n            return returnError(HTTPC_ERROR_CONNECTION_REFUSED);\n        }\n\n        if (payload &amp;&amp; size &gt; 0) {\n            addHeader(F(\"Content-Length\"), String(size));\n        }\n\n        // add cookies to header, if present\n        String cookie_string;\n        if (generateCookieString(&amp;cookie_string)) {\n            addHeader(\"Cookie\", cookie_string);\n        }\n\n        // send Header\n        if (!sendHeader(type)) {\n            return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);\n        }\n\n        // send Payload if needed\n        if (payload &amp;&amp; size &gt; 0) {\n            if (_client-&gt;write(&amp;payload[0], size) != size) {\n                return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n            }\n        }\n\n        code = handleHeaderResponse();\n        log_d(\"sendRequest code=%d\\n\", code);\n\n        // Handle redirections as stated in RFC document:\n        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n        //\n        // Implementing HTTP_CODE_FOUND as redirection with GET method,\n        // to follow most of existing user agent implementations.\n        //\n        redirect = false;\n        if (_followRedirects != HTTPC_DISABLE_FOLLOW_REDIRECTS &amp;&amp; redirectCount &lt; _redirectLimit &amp;&amp;\n            _location.length() &gt; 0) {\n            switch (code) {\n                // redirecting using the same method\n                case HTTP_CODE_MOVED_PERMANENTLY:\n                case HTTP_CODE_TEMPORARY_REDIRECT: {\n                    if (\n                        // allow to force redirections on other methods\n                        // (the RFC require user to accept the redirection)\n                        _followRedirects == HTTPC_FORCE_FOLLOW_REDIRECTS ||\n                        // allow GET and HEAD methods without force\n                        !strcmp(type, \"GET\") ||\n                        !strcmp(type, \"HEAD\")\n                    ) {\n                        redirectCount += 1;\n                        log_d(\n                            \"following redirect (the same method): '%s' redirCount: %d\\n\",\n                            _location.c_str(),\n                            redirectCount\n                        );\n                        if (!setURL(_location)) {\n                            log_d(\"failed setting URL for redirection\\n\");\n                            // no redirection\n                            break;\n                        }\n                        // redirect using the same request method and payload, diffrent URL\n                        redirect = true;\n                    }\n                    break;\n                }\n                // redirecting with method dropped to GET or HEAD\n                // note: it does not need `HTTPC_FORCE_FOLLOW_REDIRECTS` for any method\n                case HTTP_CODE_FOUND:\n                case HTTP_CODE_SEE_OTHER: {\n                    redirectCount += 1;\n                    log_d(\n                        \"following redirect (dropped to GET/HEAD): '%s' redirCount: %d\\n\",\n                        _location.c_str(),\n                        redirectCount\n                    );\n                    if (!setURL(_location)) {\n                        log_d(\"failed setting URL for redirection\\n\");\n                        // no redirection\n                        break;\n                    }\n                    // redirect after changing method to GET/HEAD and dropping payload\n                    type     = \"GET\";\n                    payload  = nullptr;\n                    size     = 0;\n                    redirect = true;\n                    break;\n                }\n\n                default:\n                    break;\n            }\n        }\n\n    } while (redirect);\n    // handle Server Response (Header)\n    return returnError(code);\n}\n\nint HTTPClient::sendRequest(const char *type, Stream *stream, size_t size) {\n\n    if (!stream) {\n        return returnError(HTTPC_ERROR_NO_STREAM);\n    }\n\n    // connect to server\n    if (!connect()) {\n        return returnError(HTTPC_ERROR_CONNECTION_REFUSED);\n    }\n\n    if (size &gt; 0) {\n        addHeader(\"Content-Length\", String(size));\n    }\n\n    // add cookies to header, if present\n    String cookie_string;\n    if (generateCookieString(&amp;cookie_string)) {\n        addHeader(\"Cookie\", cookie_string);\n    }\n\n    // send Header\n    if (!sendHeader(type)) {\n        return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);\n    }\n\n    int buff_size = HTTP_TCP_BUFFER_SIZE;\n\n    int len          = size;\n    int bytesWritten = 0;\n\n    if (len == 0) {\n        len = -1;\n    }\n\n    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE\n    if ((len &gt; 0) &amp;&amp; (len &lt; HTTP_TCP_BUFFER_SIZE)) {\n        buff_size = len;\n    }\n\n    // create buffer for read\n    uint8_t *buff = (uint8_t *)malloc(buff_size);\n\n    if (buff) {\n        // read all data from stream and send it to server\n        while (connected() &amp;&amp; (stream-&gt;available() &gt; -1) &amp;&amp; (len &gt; 0 || len == -1)) {\n\n            // get available data size\n            int sizeAvailable = stream-&gt;available();\n\n            if (sizeAvailable) {\n\n                int readBytes = sizeAvailable;\n\n                // read only the asked bytes\n                if (len &gt; 0 &amp;&amp; readBytes &gt; len) {\n                    readBytes = len;\n                }\n\n                // not read more the buffer can handle\n                if (readBytes &gt; buff_size) {\n                    readBytes = buff_size;\n                }\n\n                // read data\n                int bytesRead = stream-&gt;readBytes(buff, readBytes);\n\n                // write it to Stream\n                int bytesWrite = _client-&gt;write((const uint8_t *)buff, bytesRead);\n                bytesWritten += bytesWrite;\n\n                // are all Bytes a writen to stream ?\n                if (bytesWrite != bytesRead) {\n                    log_d(\"short write, asked for %d but got %d retry...\", bytesRead, bytesWrite);\n\n                    // check for write error\n                    if (_client-&gt;getWriteError()) {\n                        log_d(\"stream write error %d\", _client-&gt;getWriteError());\n\n                        // reset write error for retry\n                        _client-&gt;clearWriteError();\n                    }\n\n                    // some time for the stream\n                    delay(1);\n\n                    int leftBytes = (readBytes - bytesWrite);\n\n                    // retry to send the missed bytes\n                    bytesWrite = _client-&gt;write((const uint8_t *)(buff + bytesWrite), leftBytes);\n                    bytesWritten += bytesWrite;\n\n                    if (bytesWrite != leftBytes) {\n                        // failed again\n                        log_d(\"short write, asked for %d but got %d failed.\", leftBytes, bytesWrite);\n                        free(buff);\n                        return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n                    }\n                }\n\n                // check for write error\n                if (_client-&gt;getWriteError()) {\n                    log_d(\"stream write error %d\", _client-&gt;getWriteError());\n                    free(buff);\n                    return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n                }\n\n                // count bytes to read left\n                if (len &gt; 0) {\n                    len -= readBytes;\n                }\n\n                delay(0);\n            } else {\n                delay(1);\n            }\n        }\n\n        free(buff);\n\n        if (size &amp;&amp; (int)size != bytesWritten) {\n            log_d(\"Stream payload bytesWritten %d and size %d mismatch!.\", bytesWritten, size);\n            log_d(\"ERROR SEND PAYLOAD FAILED!\");\n            return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n        } else {\n            log_d(\"Stream payload written: %d\", bytesWritten);\n        }\n\n    } else {\n        log_d(\"too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);\n        return returnError(HTTPC_ERROR_TOO_LESS_RAM);\n    }\n\n    // handle Server Response (Header)\n    return returnError(handleHeaderResponse());\n}\n\nint HTTPClient::getSize(void) {\n    return _size;\n}\n\nWiFiClient &amp;HTTPClient::getStream(void) {\n    if (connected()) {\n        return *_client;\n    }\n\n    log_w(\"getStream: not connected\");\n    static WiFiClient empty;\n    return empty;\n}\n\nWiFiClient *HTTPClient::getStreamPtr(void) {\n    if (connected()) {\n        return _client;\n    }\n\n    log_w(\"getStreamPtr: not connected\");\n    return nullptr;\n}\n\nint HTTPClient::writeToStream(Stream *stream) {\n\n    if (!stream) {\n        return returnError(HTTPC_ERROR_NO_STREAM);\n    }\n\n    if (!connected()) {\n        return returnError(HTTPC_ERROR_NOT_CONNECTED);\n    }\n\n    // get length of document (is -1 when Server sends no Content-Length header)\n    int len = _size;\n    int ret = 0;\n\n    if (_transferEncoding == HTTPC_TE_IDENTITY) {\n        ret = writeToStreamDataBlock(stream, len);\n\n        // have we an error?\n        if (ret &lt; 0) {\n            return returnError(ret);\n        }\n    } else if (_transferEncoding == HTTPC_TE_CHUNKED) {\n        int size = 0;\n        while (1) {\n            if (!connected()) {\n                return returnError(HTTPC_ERROR_CONNECTION_LOST);\n            }\n            String chunkHeader = _client-&gt;readStringUntil('\\n');\n\n            if (chunkHeader.length() &lt;= 0) {\n                return returnError(HTTPC_ERROR_READ_TIMEOUT);\n            }\n\n            chunkHeader.trim(); // remove \\r\n\n            // read size of chunk\n            len = (uint32_t)strtol((const char *)chunkHeader.c_str(), NULL, 16);\n            size += len;\n            log_d(\" read chunk len: %d\", len);\n\n            // data left?\n            if (len &gt; 0) {\n                int r = writeToStreamDataBlock(stream, len);\n                if (r &lt; 0) {\n                    // error in writeToStreamDataBlock\n                    return returnError(r);\n                }\n                ret += r;\n            } else {\n\n                // if no length Header use global chunk size\n                if (_size &lt;= 0) {\n                    _size = size;\n                }\n\n                // check if we have write all data out\n                if (ret != _size) {\n                    return returnError(HTTPC_ERROR_STREAM_WRITE);\n                }\n                break;\n            }\n\n            // read trailing \\r\\n at the end of the chunk\n            char buf[2];\n            auto trailing_seq_len = _client-&gt;readBytes((uint8_t *)buf, 2);\n            if (trailing_seq_len != 2 || buf[0] != '\\r' || buf[1] != '\\n') {\n                return returnError(HTTPC_ERROR_READ_TIMEOUT);\n            }\n\n            delay(0);\n        }\n    } else {\n        return returnError(HTTPC_ERROR_ENCODING);\n    }\n\n    //    end();\n    disconnect(true);\n    return ret;\n}\n\n/* String HTTPClient::getString(void) {\n    // _size can be -1 when Server sends no Content-Length header\n    if (_size &gt; 0 || _size == -1) {\n        StreamString sstring;\n        // try to reserve needed memory (noop if _size == -1)\n        if (sstring.reserve((_size + 1))) {\n            writeToStream(&amp;sstring);\n            return sstring;\n        } else {\n            log_d(\"not enough memory to reserve a string! need: %d\", (_size + 1));\n        }\n    }\n\n    return \"\";\n} */\n\nString HTTPClient::errorToString(int error) {\n    switch (error) {\n        case HTTPC_ERROR_CONNECTION_REFUSED:\n            return F(\"connection refused\");\n        case HTTPC_ERROR_SEND_HEADER_FAILED:\n            return F(\"send header failed\");\n        case HTTPC_ERROR_SEND_PAYLOAD_FAILED:\n            return F(\"send payload failed\");\n        case HTTPC_ERROR_NOT_CONNECTED:\n            return F(\"not connected\");\n        case HTTPC_ERROR_CONNECTION_LOST:\n            return F(\"connection lost\");\n        case HTTPC_ERROR_NO_STREAM:\n            return F(\"no stream\");\n        case HTTPC_ERROR_NO_HTTP_SERVER:\n            return F(\"no HTTP server\");\n        case HTTPC_ERROR_TOO_LESS_RAM:\n            return F(\"too less ram\");\n        case HTTPC_ERROR_ENCODING:\n            return F(\"Transfer-Encoding not supported\");\n        case HTTPC_ERROR_STREAM_WRITE:\n            return F(\"Stream write error\");\n        case HTTPC_ERROR_READ_TIMEOUT:\n            return F(\"read Timeout\");\n        default:\n            return String();\n    }\n}\n\nvoid HTTPClient::addHeader(const String &amp;name, const String &amp;value, bool first, bool replace) {\n    // not allow set of Header handled by code\n    if (!name.equalsIgnoreCase(F(\"Connection\")) &amp;&amp; !name.equalsIgnoreCase(F(\"User-Agent\")) &amp;&amp;\n        !name.equalsIgnoreCase(F(\"Host\")) &amp;&amp;\n        !(name.equalsIgnoreCase(F(\"Authorization\")) &amp;&amp; _base64Authorization.length())) {\n\n        String headerLine = name;\n        headerLine += \": \";\n\n        if (replace) {\n            int headerStart = _headers.indexOf(headerLine);\n            if (headerStart != -1 &amp;&amp; (headerStart == 0 || _headers[headerStart - 1] == '\\n')) {\n                int headerEnd = _headers.indexOf('\\n', headerStart);\n                _headers      = _headers.substring(0, headerStart) + _headers.substring(headerEnd + 1);\n            }\n        }\n\n        headerLine += value;\n        headerLine += \"\\r\\n\";\n        if (first) {\n            _headers = headerLine + _headers;\n        } else {\n            _headers += headerLine;\n        }\n    }\n}\n\nvoid HTTPClient::collectHeaders(const char *headerKeys[], const size_t headerKeysCount) {\n    _headerKeysCount = headerKeysCount;\n    if (_currentHeaders) {\n        delete[] _currentHeaders;\n    }\n    _currentHeaders = new RequestArgument[_headerKeysCount];\n    for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n        _currentHeaders[i].key = headerKeys[i];\n    }\n}\n\nString HTTPClient::header(const char *name) {\n    for (size_t i = 0; i &lt; _headerKeysCount; ++i) {\n        if (_currentHeaders[i].key == name) {\n            return _currentHeaders[i].value;\n        }\n    }\n    return String();\n}\n\nString HTTPClient::header(size_t i) {\n    if (i &lt; _headerKeysCount) {\n        return _currentHeaders[i].value;\n    }\n    return String();\n}\n\nString HTTPClient::headerName(size_t i) {\n    if (i &lt; _headerKeysCount) {\n        return _currentHeaders[i].key;\n    }\n    return String();\n}\n\nint HTTPClient::headers() {\n    return _headerKeysCount;\n}\n\nbool HTTPClient::hasHeader(const char *name) {\n    for (size_t i = 0; i &lt; _headerKeysCount; ++i) {\n        if ((_currentHeaders[i].key == name) &amp;&amp; (_currentHeaders[i].value.length() &gt; 0)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool HTTPClient::connect(void) {\n    if (connected()) {\n        if (_reuse) {\n            log_d(\"already connected, reusing connection\");\n        } else {\n            log_d(\"already connected, try reuse!\");\n        }\n        while (_client-&gt;available() &gt; 0) {\n            _client-&gt;read();\n        }\n        return true;\n    }\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_transportTraits &amp;&amp; !_client) {\n        _tcpDeprecated = _transportTraits-&gt;create();\n        if (!_tcpDeprecated) {\n            log_e(\"failed to create client\");\n            return false;\n        }\n        _client = _tcpDeprecated.get();\n    }\n#endif\n\n    if (!_client) {\n        log_d(\"HTTPClient::begin was not called or returned error\");\n        return false;\n    }\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated &amp;&amp; !_transportTraits-&gt;verify(*_client, _host.c_str())) {\n        log_d(\"transport level verify failed\");\n        _client-&gt;stop();\n        return false;\n    }\n#endif\n    if (!_client-&gt;connect(_host.c_str(), _port, _connectTimeout)) {\n        log_d(\"failed connect to %s:%u\", _host.c_str(), _port);\n        return false;\n    }\n\n    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()\n    _client-&gt;setTimeout((_tcpTimeout + 500) / 1000);\n\n    log_d(\" connected to %s:%u\", _host.c_str(), _port);\n\n    /*\n    #ifdef ESP8266\n        _client-&gt;setNoDelay(true);\n    #endif\n     */\n    return connected();\n}\n\nbool HTTPClient::sendHeader(const char *type) {\n    if (!connected()) {\n        return false;\n    }\n\n    String header = String(type) + \" \" + _uri + F(\" HTTP/1.\");\n\n    if (_useHTTP10) {\n        header += \"0\";\n    } else {\n        header += \"1\";\n    }\n\n    header += String(F(\"\\r\\nHost: \")) + _host;\n    if (_port != 80 &amp;&amp; _port != 443) {\n        header += ':';\n        header += String(_port);\n    }\n    header += String(F(\"\\r\\nUser-Agent: \")) + _userAgent + F(\"\\r\\nConnection: \");\n\n    if (_reuse) {\n        header += F(\"keep-alive\");\n    } else {\n        header += F(\"close\");\n    }\n    header += \"\\r\\n\";\n\n    if (!_useHTTP10) {\n        header += F(\"Accept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\\r\\n\");\n    }\n\n    if (_base64Authorization.length()) {\n        _base64Authorization.replace(\"\\n\", \"\");\n        header += F(\"Authorization: \");\n        header += _authorizationType;\n        header += \" \";\n        header += _base64Authorization;\n        header += \"\\r\\n\";\n    }\n\n    header += _headers + \"\\r\\n\";\n\n    return (_client-&gt;write((const uint8_t *)header.c_str(), header.length()) == header.length());\n}\n\nint HTTPClient::handleHeaderResponse() {\n\n    if (!connected()) {\n        return HTTPC_ERROR_NOT_CONNECTED;\n    }\n\n    _returnCode = 0;\n    _size       = -1;\n    _canReuse   = _reuse;\n\n    String transferEncoding;\n\n    _transferEncoding          = HTTPC_TE_IDENTITY;\n    unsigned long lastDataTime = millis();\n    bool firstLine             = true;\n    String date;\n\n    while (connected()) {\n        size_t len = _client-&gt;available();\n        if (len &gt; 0) {\n            String headerLine = _client-&gt;readStringUntil('\\n');\n            headerLine.trim(); // remove \\r\n\n            lastDataTime = millis();\n\n            log_v(\"RX: '%s'\", headerLine.c_str());\n\n            if (firstLine) {\n                firstLine = false;\n                if (_canReuse &amp;&amp; headerLine.startsWith(\"HTTP/1.\")) {\n                    _canReuse = (headerLine[sizeof \"HTTP/1.\" - 1] != '0');\n                }\n                int codePos = headerLine.indexOf(' ') + 1;\n                _returnCode = headerLine.substring(codePos, headerLine.indexOf(' ', codePos)).toInt();\n            } else if (headerLine.indexOf(':')) {\n                String headerName  = headerLine.substring(0, headerLine.indexOf(':'));\n                String headerValue = headerLine.substring(headerLine.indexOf(':') + 1);\n                headerValue.trim();\n\n                if (headerName.equalsIgnoreCase(\"Date\")) {\n                    date = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Content-Length\")) {\n                    _size = headerValue.toInt();\n                }\n\n                if (_canReuse &amp;&amp; headerName.equalsIgnoreCase(\"Connection\")) {\n                    if (headerValue.indexOf(\"close\") &gt;= 0 &amp;&amp; headerValue.indexOf(\"keep-alive\") &lt; 0) {\n                        _canReuse = false;\n                    }\n                }\n\n                if (headerName.equalsIgnoreCase(\"Transfer-Encoding\")) {\n                    transferEncoding = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Location\")) {\n                    _location = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Set-Cookie\")) {\n                    setCookie(date, headerValue);\n                }\n\n                for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n                    if (_currentHeaders[i].key.equalsIgnoreCase(headerName)) {\n                        // Uncomment the following lines if you need to add support for multiple headers with the same\n                        // key: if (!_currentHeaders[i].value.isEmpty()) {\n                        //     // Existing value, append this one with a comma\n                        //     _currentHeaders[i].value += ',';\n                        //     _currentHeaders[i].value += headerValue;\n                        // } else {\n                        _currentHeaders[i].value = headerValue;\n                        // }\n                        break; // We found a match, stop looking\n                    }\n                }\n            }\n\n            if (headerLine == \"\") {\n                log_d(\"code: %d\", _returnCode);\n\n                if (_size &gt; 0) {\n                    log_d(\"size: %d\", _size);\n                }\n\n                if (transferEncoding.length() &gt; 0) {\n                    log_d(\"Transfer-Encoding: %s\", transferEncoding.c_str());\n                    if (transferEncoding.equalsIgnoreCase(\"chunked\")) {\n                        _transferEncoding = HTTPC_TE_CHUNKED;\n                    } else if (transferEncoding.equalsIgnoreCase(\"identity\")) {\n                        _transferEncoding = HTTPC_TE_IDENTITY;\n                    } else {\n                        return HTTPC_ERROR_ENCODING;\n                    }\n                } else {\n                    _transferEncoding = HTTPC_TE_IDENTITY;\n                }\n\n                if (_returnCode) {\n                    return _returnCode;\n                } else {\n                    log_d(\"Remote host is not an HTTP Server!\");\n                    return HTTPC_ERROR_NO_HTTP_SERVER;\n                }\n            }\n\n        } else {\n            if ((millis() - lastDataTime) &gt; _tcpTimeout) {\n                return HTTPC_ERROR_READ_TIMEOUT;\n            }\n            delay(10);\n        }\n    }\n\n    return HTTPC_ERROR_CONNECTION_LOST;\n}\n\nint HTTPClient::writeToStreamDataBlock(Stream *stream, int size) {\n    int buff_size    = HTTP_TCP_BUFFER_SIZE;\n    int len          = size;\n    int bytesWritten = 0;\n\n    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE\n    if ((len &gt; 0) &amp;&amp; (len &lt; HTTP_TCP_BUFFER_SIZE)) {\n        buff_size = len;\n    }\n\n    // create buffer for read\n    uint8_t *buff = (uint8_t *)malloc(buff_size);\n\n    if (buff) {\n        // read all data from server\n        while (connected() &amp;&amp; (len &gt; 0 || len == -1)) {\n\n            // get available data size\n            size_t sizeAvailable = _client-&gt;available();\n\n            if (sizeAvailable) {\n\n                int readBytes = sizeAvailable;\n\n                // read only the asked bytes\n                if (len &gt; 0 &amp;&amp; readBytes &gt; len) {\n                    readBytes = len;\n                }\n\n                // not read more the buffer can handle\n                if (readBytes &gt; buff_size) {\n                    readBytes = buff_size;\n                }\n\n                // stop if no more reading\n                if (readBytes == 0)\n                    break;\n\n                // read data\n                int bytesRead = _client-&gt;readBytes(buff, readBytes);\n\n                // write it to Stream\n                int bytesWrite = stream-&gt;write(buff, bytesRead);\n                bytesWritten += bytesWrite;\n\n                // are all Bytes a writen to stream ?\n                if (bytesWrite != bytesRead) {\n                    log_d(\"short write asked for %d but got %d retry...\", bytesRead, bytesWrite);\n\n                    // check for write error\n                    if (stream-&gt;getWriteError()) {\n                        log_d(\"stream write error %d\", stream-&gt;getWriteError());\n\n                        // reset write error for retry\n                        stream-&gt;clearWriteError();\n                    }\n\n                    // some time for the stream\n                    delay(1);\n\n                    int leftBytes = (readBytes - bytesWrite);\n\n                    // retry to send the missed bytes\n                    bytesWrite = stream-&gt;write((buff + bytesWrite), leftBytes);\n                    bytesWritten += bytesWrite;\n\n                    if (bytesWrite != leftBytes) {\n                        // failed again\n                        log_w(\"short write asked for %d but got %d failed.\", leftBytes, bytesWrite);\n                        free(buff);\n                        return HTTPC_ERROR_STREAM_WRITE;\n                    }\n                }\n\n                // check for write error\n                if (stream-&gt;getWriteError()) {\n                    log_w(\"stream write error %d\", stream-&gt;getWriteError());\n                    free(buff);\n                    return HTTPC_ERROR_STREAM_WRITE;\n                }\n\n                // count bytes to read left\n                if (len &gt; 0) {\n                    len -= readBytes;\n                }\n\n                delay(0);\n            } else {\n                delay(1);\n            }\n        }\n\n        free(buff);\n\n        log_d(\"connection closed or file end (written: %d).\", bytesWritten);\n\n        if ((size &gt; 0) &amp;&amp; (size != bytesWritten)) {\n            log_d(\"bytesWritten %d and size %d mismatch!.\", bytesWritten, size);\n            return HTTPC_ERROR_STREAM_WRITE;\n        }\n\n    } else {\n        log_w(\"too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);\n        return HTTPC_ERROR_TOO_LESS_RAM;\n    }\n\n    return bytesWritten;\n}\n\nint HTTPClient::returnError(int error) {\n    if (error &lt; 0) {\n        log_w(\"error(%d): %s\", error, errorToString(error).c_str());\n        if (connected()) {\n            log_d(\"tcp stop\");\n            _client-&gt;stop();\n        }\n    }\n    return error;\n}\n\nvoid HTTPClient::setFollowRedirects(followRedirects_t follow) {\n    _followRedirects = follow;\n}\n\nvoid HTTPClient::setRedirectLimit(uint16_t limit) {\n    _redirectLimit = limit;\n}\n\nbool HTTPClient::setURL(const String &amp;url) {\n    // if the new location is only a path then only update the URI\n    if (url &amp;&amp; url[0] == '/') {\n        _uri = url;\n        clear();\n        return true;\n    }\n\n    if (!url.startsWith(_protocol + ':')) {\n        log_d(\"new URL not the same protocol, expected '%s', URL: '%s'\\n\", _protocol.c_str(), url.c_str());\n        return false;\n    }\n\n    // check if the port is specified\n    int indexPort = url.indexOf(':', 6); // find the first ':' excluding the one from the protocol\n    int indexURI  = url.indexOf('/', 7); // find where the URI starts to make sure the ':' is not part of it\n    if (indexPort == -1 || indexPort &gt; indexURI) {\n        // the port is not specified\n        _port = (_protocol == \"https\" ? 443 : 80);\n    }\n\n    // disconnect but preserve _client.\n    // Also have to keep the connection otherwise it will free some of the memory used by _client\n    // and will blow up later when trying to do _client-&gt;available() or similar\n    _canReuse = true;\n    disconnect(true);\n    return beginInternal(url, _protocol.c_str());\n}\n\nconst String &amp;HTTPClient::getLocation(void) {\n    return _location;\n}\n\nvoid HTTPClient::setCookieJar(CookieJar *cookieJar) {\n    _cookieJar = cookieJar;\n}\n\nvoid HTTPClient::resetCookieJar() {\n    _cookieJar = nullptr;\n}\n\nvoid HTTPClient::clearAllCookies() {\n    if (_cookieJar)\n        _cookieJar-&gt;clear();\n}\n\nvoid HTTPClient::setCookie(String date, String headerValue) {\n    if (!_cookieJar) {\n        return;\n    }\n#define HTTP_TIME_PATTERN \"%a, %d %b %Y %H:%M:%S\"\n\n    Cookie cookie;\n    String value;\n    int pos1, pos2;\n\n    headerValue.toLowerCase();\n\n    struct tm tm;\n    strptime(date.c_str(), HTTP_TIME_PATTERN, &amp;tm);\n    cookie.date = mktime(&amp;tm);\n\n    pos1 = headerValue.indexOf('=');\n    pos2 = headerValue.indexOf(';');\n\n    if (pos1 &gt;= 0 &amp;&amp; pos2 &gt; pos1) {\n        cookie.name  = headerValue.substring(0, pos1);\n        cookie.value = headerValue.substring(pos1 + 1, pos2);\n    } else {\n        return; // invalid cookie header\n    }\n\n    // expires\n    if (headerValue.indexOf(\"expires=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"expires=\") + strlen(\"expires=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        strptime(value.c_str(), HTTP_TIME_PATTERN, &amp;tm);\n        cookie.expires.date  = mktime(&amp;tm);\n        cookie.expires.valid = true;\n    }\n\n    // max-age\n    if (headerValue.indexOf(\"max-age=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"max-age=\") + strlen(\"max-age=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        cookie.max_age.duration = value.toInt();\n        cookie.max_age.valid    = true;\n    }\n\n    // domain\n    if (headerValue.indexOf(\"domain=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"domain=\") + strlen(\"domain=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        if (value.startsWith(\".\"))\n            value.remove(0, 1);\n\n        if (_host.indexOf(value) &gt;= 0) {\n            cookie.domain = value;\n        } else {\n            return; // server tries to set a cookie on a different domain; ignore it\n        }\n    } else {\n        pos1 = _host.lastIndexOf('.', _host.lastIndexOf('.') - 1);\n        if (pos1 &gt;= 0)\n            cookie.domain = _host.substring(pos1 + 1);\n        else\n            cookie.domain = _host;\n    }\n\n    // path\n    if (headerValue.indexOf(\"path=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"path=\") + strlen(\"path=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            cookie.path = headerValue.substring(pos1, pos2);\n        else\n            cookie.path = headerValue.substring(pos1);\n    }\n\n    // HttpOnly\n    cookie.http_only = (headerValue.indexOf(\"httponly\") &gt;= 0);\n\n    // secure\n    cookie.secure = (headerValue.indexOf(\"secure\") &gt;= 0);\n\n    // overwrite or delete cookie in/from cookie jar\n    time_t now_local = time(NULL);\n    time_t now_gmt   = mktime(gmtime(&amp;now_local));\n\n    bool found = false;\n\n    for (auto c = _cookieJar-&gt;begin(); c != _cookieJar-&gt;end(); ++c) {\n        if (c-&gt;domain == cookie.domain &amp;&amp; c-&gt;name == cookie.name) {\n            // when evaluating, max-age takes precedence over expires if both are defined\n            if ((cookie.max_age.valid &amp;&amp; ((cookie.date + cookie.max_age.duration) &lt; now_gmt)) ||\n                cookie.max_age.duration &lt;= 0 ||\n                (!cookie.max_age.valid &amp;&amp; cookie.expires.valid &amp;&amp; cookie.expires.date &lt; now_gmt)) {\n                _cookieJar-&gt;erase(c);\n                c--;\n            } else {\n                *c = cookie;\n            }\n            found = true;\n        }\n    }\n\n    // add cookie to jar\n    if (!found &amp;&amp; !(cookie.max_age.valid &amp;&amp; cookie.max_age.duration &lt;= 0))\n        _cookieJar-&gt;push_back(cookie);\n}\n\nbool HTTPClient::generateCookieString(String *cookieString) {\n    time_t now_local = time(NULL);\n    time_t now_gmt   = mktime(gmtime(&amp;now_local));\n\n    *cookieString = \"\";\n    bool found    = false;\n\n    if (!_cookieJar) {\n        return false;\n    }\n    for (auto c = _cookieJar-&gt;begin(); c != _cookieJar-&gt;end(); ++c) {\n        if ((c-&gt;max_age.valid &amp;&amp; ((c-&gt;date + c-&gt;max_age.duration) &lt; now_gmt)) ||\n            (!c-&gt;max_age.valid &amp;&amp; c-&gt;expires.valid &amp;&amp; c-&gt;expires.date &lt; now_gmt)) {\n            _cookieJar-&gt;erase(c);\n            c--;\n        } else if (_host.indexOf(c-&gt;domain) &gt;= 0 &amp;&amp; (!c-&gt;secure || _secure)) {\n            if (*cookieString == \"\")\n                *cookieString = c-&gt;name + \"=\" + c-&gt;value;\n            else\n                *cookieString += \" ;\" + c-&gt;name + \"=\" + c-&gt;value;\n            found = true;\n        }\n    }\n\n    return found;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/","title":"File HTTPClient.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; HTTPClient &gt; HTTPClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;WiFiClient.h&gt;</code></li> <li><code>#include &lt;WiFiClientSecure.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_h_t_t_p_client_8h/#classes","title":"Classes","text":"Type Name     struct Cookie    class HTTPClient    struct RequestArgument"},{"location":"ltapi/_h_t_t_p_client_8h/#public-types","title":"Public Types","text":"Type Name     typedef std::vector&lt; Cookie &gt; CookieJar    typedef std::unique_ptr&lt; TransportTraits &gt; TransportTraitsPtr    enum followRedirects_t    enum t_http_codes HTTP codes see RFC7231.   enum transferEncoding_t"},{"location":"ltapi/_h_t_t_p_client_8h/#macros","title":"Macros","text":"Type Name     define HTTPCLIENT_1_1_COMPATIBLE    define HTTPCLIENT_DEFAULT_TCP_TIMEOUT  (5000)Cookie jar support.   define HTTPC_ERROR_CONNECTION_LOST  (-5)   define HTTPC_ERROR_CONNECTION_REFUSED  (-1)HTTP client errors.   define HTTPC_ERROR_ENCODING  (-9)   define HTTPC_ERROR_NOT_CONNECTED  (-4)   define HTTPC_ERROR_NO_HTTP_SERVER  (-7)   define HTTPC_ERROR_NO_STREAM  (-6)   define HTTPC_ERROR_READ_TIMEOUT  (-11)   define HTTPC_ERROR_SEND_HEADER_FAILED  (-2)   define HTTPC_ERROR_SEND_PAYLOAD_FAILED  (-3)   define HTTPC_ERROR_STREAM_WRITE  (-10)   define HTTPC_ERROR_TOO_LESS_RAM  (-8)   define HTTP_TCP_BUFFER_SIZE  (1460)size for the stream handling"},{"location":"ltapi/_h_t_t_p_client_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_h_t_t_p_client_8h/#typedef-cookiejar","title":"typedef CookieJar","text":"<pre><code>typedef std::vector&lt;Cookie&gt; CookieJar;\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#typedef-transporttraitsptr","title":"typedef TransportTraitsPtr","text":"<pre><code>typedef std::unique_ptr&lt;TransportTraits&gt; TransportTraitsPtr;\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-followredirects_t","title":"enum followRedirects_t","text":"<pre><code>enum followRedirects_t {\n    HTTPC_DISABLE_FOLLOW_REDIRECTS,\n    HTTPC_STRICT_FOLLOW_REDIRECTS,\n    HTTPC_FORCE_FOLLOW_REDIRECTS\n};\n</code></pre> <p>redirection follow mode. * <code>HTTPC_DISABLE_FOLLOW_REDIRECTS</code> - no redirection will be followed. * <code>HTTPC_STRICT_FOLLOW_REDIRECTS</code> - strict RFC2616, only requests using GET or HEAD methods will be redirected (using the same method), since the RFC requires end-user confirmation in other cases. * <code>HTTPC_FORCE_FOLLOW_REDIRECTS</code> - all redirections will be followed, regardless of a used method. New request will use the same method, and they will include the same body data and the same headers. In the sense of the RFC, it's just like every redirection is confirmed. </p>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-t_http_codes","title":"enum t_http_codes","text":"<pre><code>enum t_http_codes {\n    HTTP_CODE_CONTINUE = 100,\n    HTTP_CODE_SWITCHING_PROTOCOLS = 101,\n    HTTP_CODE_PROCESSING = 102,\n    HTTP_CODE_OK = 200,\n    HTTP_CODE_CREATED = 201,\n    HTTP_CODE_ACCEPTED = 202,\n    HTTP_CODE_NON_AUTHORITATIVE_INFORMATION = 203,\n    HTTP_CODE_NO_CONTENT = 204,\n    HTTP_CODE_RESET_CONTENT = 205,\n    HTTP_CODE_PARTIAL_CONTENT = 206,\n    HTTP_CODE_MULTI_STATUS = 207,\n    HTTP_CODE_ALREADY_REPORTED = 208,\n    HTTP_CODE_IM_USED = 226,\n    HTTP_CODE_MULTIPLE_CHOICES = 300,\n    HTTP_CODE_MOVED_PERMANENTLY = 301,\n    HTTP_CODE_FOUND = 302,\n    HTTP_CODE_SEE_OTHER = 303,\n    HTTP_CODE_NOT_MODIFIED = 304,\n    HTTP_CODE_USE_PROXY = 305,\n    HTTP_CODE_TEMPORARY_REDIRECT = 307,\n    HTTP_CODE_PERMANENT_REDIRECT = 308,\n    HTTP_CODE_BAD_REQUEST = 400,\n    HTTP_CODE_UNAUTHORIZED = 401,\n    HTTP_CODE_PAYMENT_REQUIRED = 402,\n    HTTP_CODE_FORBIDDEN = 403,\n    HTTP_CODE_NOT_FOUND = 404,\n    HTTP_CODE_METHOD_NOT_ALLOWED = 405,\n    HTTP_CODE_NOT_ACCEPTABLE = 406,\n    HTTP_CODE_PROXY_AUTHENTICATION_REQUIRED = 407,\n    HTTP_CODE_REQUEST_TIMEOUT = 408,\n    HTTP_CODE_CONFLICT = 409,\n    HTTP_CODE_GONE = 410,\n    HTTP_CODE_LENGTH_REQUIRED = 411,\n    HTTP_CODE_PRECONDITION_FAILED = 412,\n    HTTP_CODE_PAYLOAD_TOO_LARGE = 413,\n    HTTP_CODE_URI_TOO_LONG = 414,\n    HTTP_CODE_UNSUPPORTED_MEDIA_TYPE = 415,\n    HTTP_CODE_RANGE_NOT_SATISFIABLE = 416,\n    HTTP_CODE_EXPECTATION_FAILED = 417,\n    HTTP_CODE_MISDIRECTED_REQUEST = 421,\n    HTTP_CODE_UNPROCESSABLE_ENTITY = 422,\n    HTTP_CODE_LOCKED = 423,\n    HTTP_CODE_FAILED_DEPENDENCY = 424,\n    HTTP_CODE_UPGRADE_REQUIRED = 426,\n    HTTP_CODE_PRECONDITION_REQUIRED = 428,\n    HTTP_CODE_TOO_MANY_REQUESTS = 429,\n    HTTP_CODE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n    HTTP_CODE_INTERNAL_SERVER_ERROR = 500,\n    HTTP_CODE_NOT_IMPLEMENTED = 501,\n    HTTP_CODE_BAD_GATEWAY = 502,\n    HTTP_CODE_SERVICE_UNAVAILABLE = 503,\n    HTTP_CODE_GATEWAY_TIMEOUT = 504,\n    HTTP_CODE_HTTP_VERSION_NOT_SUPPORTED = 505,\n    HTTP_CODE_VARIANT_ALSO_NEGOTIATES = 506,\n    HTTP_CODE_INSUFFICIENT_STORAGE = 507,\n    HTTP_CODE_LOOP_DETECTED = 508,\n    HTTP_CODE_NOT_EXTENDED = 510,\n    HTTP_CODE_NETWORK_AUTHENTICATION_REQUIRED = 511\n};\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-transferencoding_t","title":"enum transferEncoding_t","text":"<pre><code>enum transferEncoding_t {\n    HTTPC_TE_IDENTITY,\n    HTTPC_TE_CHUNKED\n};\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpclient_1_1_compatible","title":"define HTTPCLIENT_1_1_COMPATIBLE","text":"<pre><code>#define HTTPCLIENT_1_1_COMPATIBLE \n</code></pre> <p>HTTPClient.h</p> <p>Created on: 02.11.2015</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the HTTPClient for Arduino. Port to ESP32 by Evandro Luis Copercini (2017), changed fingerprints to CA verification.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpclient_default_tcp_timeout","title":"define HTTPCLIENT_DEFAULT_TCP_TIMEOUT","text":"<pre><code>#define HTTPCLIENT_DEFAULT_TCP_TIMEOUT (5000)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_connection_lost","title":"define HTTPC_ERROR_CONNECTION_LOST","text":"<pre><code>#define HTTPC_ERROR_CONNECTION_LOST (-5)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_connection_refused","title":"define HTTPC_ERROR_CONNECTION_REFUSED","text":"<pre><code>#define HTTPC_ERROR_CONNECTION_REFUSED (-1)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_encoding","title":"define HTTPC_ERROR_ENCODING","text":"<pre><code>#define HTTPC_ERROR_ENCODING (-9)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_not_connected","title":"define HTTPC_ERROR_NOT_CONNECTED","text":"<pre><code>#define HTTPC_ERROR_NOT_CONNECTED (-4)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_no_http_server","title":"define HTTPC_ERROR_NO_HTTP_SERVER","text":"<pre><code>#define HTTPC_ERROR_NO_HTTP_SERVER (-7)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_no_stream","title":"define HTTPC_ERROR_NO_STREAM","text":"<pre><code>#define HTTPC_ERROR_NO_STREAM (-6)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_read_timeout","title":"define HTTPC_ERROR_READ_TIMEOUT","text":"<pre><code>#define HTTPC_ERROR_READ_TIMEOUT (-11)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_send_header_failed","title":"define HTTPC_ERROR_SEND_HEADER_FAILED","text":"<pre><code>#define HTTPC_ERROR_SEND_HEADER_FAILED (-2)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_send_payload_failed","title":"define HTTPC_ERROR_SEND_PAYLOAD_FAILED","text":"<pre><code>#define HTTPC_ERROR_SEND_PAYLOAD_FAILED (-3)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_stream_write","title":"define HTTPC_ERROR_STREAM_WRITE","text":"<pre><code>#define HTTPC_ERROR_STREAM_WRITE (-10)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_too_less_ram","title":"define HTTPC_ERROR_TOO_LESS_RAM","text":"<pre><code>#define HTTPC_ERROR_TOO_LESS_RAM (-8)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-http_tcp_buffer_size","title":"define HTTP_TCP_BUFFER_SIZE","text":"<pre><code>#define HTTP_TCP_BUFFER_SIZE (1460)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/_h_t_t_p_client_8h_source/","title":"File HTTPClient.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; HTTPClient &gt; HTTPClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef HTTPClient_H_\n#define HTTPClient_H_\n\n#ifndef HTTPCLIENT_1_1_COMPATIBLE\n#define HTTPCLIENT_1_1_COMPATIBLE\n#endif\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;WiFiClientSecure.h&gt;\n#include &lt;memory&gt;\n\n#include &lt;vector&gt;\n\n#define HTTPCLIENT_DEFAULT_TCP_TIMEOUT (5000)\n\n#define HTTPC_ERROR_CONNECTION_REFUSED  (-1)\n#define HTTPC_ERROR_SEND_HEADER_FAILED  (-2)\n#define HTTPC_ERROR_SEND_PAYLOAD_FAILED (-3)\n#define HTTPC_ERROR_NOT_CONNECTED       (-4)\n#define HTTPC_ERROR_CONNECTION_LOST     (-5)\n#define HTTPC_ERROR_NO_STREAM           (-6)\n#define HTTPC_ERROR_NO_HTTP_SERVER      (-7)\n#define HTTPC_ERROR_TOO_LESS_RAM        (-8)\n#define HTTPC_ERROR_ENCODING            (-9)\n#define HTTPC_ERROR_STREAM_WRITE        (-10)\n#define HTTPC_ERROR_READ_TIMEOUT        (-11)\n\n#define HTTP_TCP_BUFFER_SIZE (1460)\n\ntypedef enum {\n    HTTP_CODE_CONTINUE                        = 100,\n    HTTP_CODE_SWITCHING_PROTOCOLS             = 101,\n    HTTP_CODE_PROCESSING                      = 102,\n    HTTP_CODE_OK                              = 200,\n    HTTP_CODE_CREATED                         = 201,\n    HTTP_CODE_ACCEPTED                        = 202,\n    HTTP_CODE_NON_AUTHORITATIVE_INFORMATION   = 203,\n    HTTP_CODE_NO_CONTENT                      = 204,\n    HTTP_CODE_RESET_CONTENT                   = 205,\n    HTTP_CODE_PARTIAL_CONTENT                 = 206,\n    HTTP_CODE_MULTI_STATUS                    = 207,\n    HTTP_CODE_ALREADY_REPORTED                = 208,\n    HTTP_CODE_IM_USED                         = 226,\n    HTTP_CODE_MULTIPLE_CHOICES                = 300,\n    HTTP_CODE_MOVED_PERMANENTLY               = 301,\n    HTTP_CODE_FOUND                           = 302,\n    HTTP_CODE_SEE_OTHER                       = 303,\n    HTTP_CODE_NOT_MODIFIED                    = 304,\n    HTTP_CODE_USE_PROXY                       = 305,\n    HTTP_CODE_TEMPORARY_REDIRECT              = 307,\n    HTTP_CODE_PERMANENT_REDIRECT              = 308,\n    HTTP_CODE_BAD_REQUEST                     = 400,\n    HTTP_CODE_UNAUTHORIZED                    = 401,\n    HTTP_CODE_PAYMENT_REQUIRED                = 402,\n    HTTP_CODE_FORBIDDEN                       = 403,\n    HTTP_CODE_NOT_FOUND                       = 404,\n    HTTP_CODE_METHOD_NOT_ALLOWED              = 405,\n    HTTP_CODE_NOT_ACCEPTABLE                  = 406,\n    HTTP_CODE_PROXY_AUTHENTICATION_REQUIRED   = 407,\n    HTTP_CODE_REQUEST_TIMEOUT                 = 408,\n    HTTP_CODE_CONFLICT                        = 409,\n    HTTP_CODE_GONE                            = 410,\n    HTTP_CODE_LENGTH_REQUIRED                 = 411,\n    HTTP_CODE_PRECONDITION_FAILED             = 412,\n    HTTP_CODE_PAYLOAD_TOO_LARGE               = 413,\n    HTTP_CODE_URI_TOO_LONG                    = 414,\n    HTTP_CODE_UNSUPPORTED_MEDIA_TYPE          = 415,\n    HTTP_CODE_RANGE_NOT_SATISFIABLE           = 416,\n    HTTP_CODE_EXPECTATION_FAILED              = 417,\n    HTTP_CODE_MISDIRECTED_REQUEST             = 421,\n    HTTP_CODE_UNPROCESSABLE_ENTITY            = 422,\n    HTTP_CODE_LOCKED                          = 423,\n    HTTP_CODE_FAILED_DEPENDENCY               = 424,\n    HTTP_CODE_UPGRADE_REQUIRED                = 426,\n    HTTP_CODE_PRECONDITION_REQUIRED           = 428,\n    HTTP_CODE_TOO_MANY_REQUESTS               = 429,\n    HTTP_CODE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n    HTTP_CODE_INTERNAL_SERVER_ERROR           = 500,\n    HTTP_CODE_NOT_IMPLEMENTED                 = 501,\n    HTTP_CODE_BAD_GATEWAY                     = 502,\n    HTTP_CODE_SERVICE_UNAVAILABLE             = 503,\n    HTTP_CODE_GATEWAY_TIMEOUT                 = 504,\n    HTTP_CODE_HTTP_VERSION_NOT_SUPPORTED      = 505,\n    HTTP_CODE_VARIANT_ALSO_NEGOTIATES         = 506,\n    HTTP_CODE_INSUFFICIENT_STORAGE            = 507,\n    HTTP_CODE_LOOP_DETECTED                   = 508,\n    HTTP_CODE_NOT_EXTENDED                    = 510,\n    HTTP_CODE_NETWORK_AUTHENTICATION_REQUIRED = 511\n} t_http_codes;\n\ntypedef enum { HTTPC_TE_IDENTITY, HTTPC_TE_CHUNKED } transferEncoding_t;\n\ntypedef enum {\n    HTTPC_DISABLE_FOLLOW_REDIRECTS,\n    HTTPC_STRICT_FOLLOW_REDIRECTS,\n    HTTPC_FORCE_FOLLOW_REDIRECTS\n} followRedirects_t;\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nclass TransportTraits;\ntypedef std::unique_ptr&lt;TransportTraits&gt; TransportTraitsPtr;\n#endif\n\n// cookie jar support\ntypedef struct {\n    String host; // host which tries to set the cookie\n    time_t date; // timestamp of the response that set the cookie\n    String name;\n    String value;\n    String domain;\n    String path = \"\";\n\n    struct {\n        time_t date = 0;\n        bool valid  = false;\n    } expires;\n\n    struct {\n        time_t duration = 0;\n        bool valid      = false;\n    } max_age;\n\n    bool http_only = false;\n    bool secure    = false;\n} Cookie;\n\ntypedef std::vector&lt;Cookie&gt; CookieJar;\n\nclass HTTPClient {\n  public:\n    HTTPClient();\n    ~HTTPClient();\n\n    /*\n     * Since both begin() functions take a reference to client as a parameter, you need to\n     * ensure the client object lives the entire time of the HTTPClient\n     */\n    bool begin(WiFiClient &amp;client, String url);\n    bool begin(WiFiClient &amp;client, String host, uint16_t port, String uri = \"/\", bool https = false);\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    bool begin(String url);\n    bool begin(String url, const char *CAcert);\n    bool begin(String host, uint16_t port, String uri = \"/\");\n    bool begin(String host, uint16_t port, String uri, const char *CAcert);\n    bool begin(String host, uint16_t port, String uri, const char *CAcert, const char *cli_cert, const char *cli_key);\n#endif\n\n    void end(void);\n\n    bool connected(void);\n\n    void setReuse(bool reuse); \n    void setUserAgent(const String &amp;userAgent);\n    void setAuthorization(const char *user, const char *password);\n    void setAuthorization(const char *auth);\n    void setAuthorizationType(const char *authType);\n    void setConnectTimeout(int32_t connectTimeout);\n    void setTimeout(uint16_t timeout);\n\n    // Redirections\n    void setFollowRedirects(followRedirects_t follow);\n    void setRedirectLimit(uint16_t limit); // max redirects to follow for a single request\n\n    bool setURL(const String &amp;url);\n    void useHTTP10(bool usehttp10 = true);\n\n    int GET();\n    int PATCH(uint8_t *payload, size_t size);\n    int PATCH(String payload);\n    int POST(uint8_t *payload, size_t size);\n    int POST(String payload);\n    int PUT(uint8_t *payload, size_t size);\n    int PUT(String payload);\n    int sendRequest(const char *type, String payload);\n    int sendRequest(const char *type, uint8_t *payload = NULL, size_t size = 0);\n    int sendRequest(const char *type, Stream *stream, size_t size = 0);\n\n    void addHeader(const String &amp;name, const String &amp;value, bool first = false, bool replace = true);\n\n    void collectHeaders(const char *headerKeys[], const size_t headerKeysCount);\n    String header(const char *name);  // get request header value by name\n    String header(size_t i);          // get request header value by number\n    String headerName(size_t i);      // get request header name by number\n    int headers();                    // get header count\n    bool hasHeader(const char *name); // check if header exists\n\n    int getSize(void);\n    const String &amp;getLocation(void);\n\n    WiFiClient &amp;getStream(void);\n    WiFiClient *getStreamPtr(void);\n    int writeToStream(Stream *stream);\n    // String getString(void);\n\n    static String errorToString(int error);\n\n    void setCookieJar(CookieJar *cookieJar);\n    void resetCookieJar();\n    void clearAllCookies();\n\n  protected:\n    struct RequestArgument {\n        String key;\n        String value;\n    };\n\n    bool beginInternal(String url, const char *expectedProtocol);\n    void disconnect(bool preserveClient = false);\n    void clear();\n    int returnError(int error);\n    bool connect(void);\n    bool sendHeader(const char *type);\n    int handleHeaderResponse();\n    int writeToStreamDataBlock(Stream *stream, int len);\n\n    void setCookie(String date, String headerValue);\n    bool generateCookieString(String *cookieString);\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    TransportTraitsPtr _transportTraits;\n    std::unique_ptr&lt;WiFiClient&gt; _tcpDeprecated;\n#endif\n\n    WiFiClient *_client = nullptr;\n\n    String _host;\n    uint16_t _port          = 0;\n    int32_t _connectTimeout = -1;\n    bool _reuse             = true;\n    uint16_t _tcpTimeout    = HTTPCLIENT_DEFAULT_TCP_TIMEOUT;\n    bool _useHTTP10         = false;\n    bool _secure            = false;\n\n    String _uri;\n    String _protocol;\n    String _headers;\n    String _userAgent = \"ESP32HTTPClient\";\n    String _base64Authorization;\n    String _authorizationType = \"Basic\";\n\n    RequestArgument *_currentHeaders = nullptr;\n    size_t _headerKeysCount          = 0;\n\n    int _returnCode                    = 0;\n    int _size                          = -1;\n    bool _canReuse                     = false;\n    followRedirects_t _followRedirects = HTTPC_DISABLE_FOLLOW_REDIRECTS;\n    uint16_t _redirectLimit            = 10;\n    String _location;\n    transferEncoding_t _transferEncoding = HTTPC_TE_IDENTITY;\n\n    CookieJar *_cookieJar = nullptr;\n};\n\n#endif /* HTTPClient_H_ */\n</code></pre>"},{"location":"ltapi/dir_0a3ac6ff289d4ebfcd0c797d13f9a373/","title":"Dir cores/common/arduino/libraries/ext/StreamString","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; StreamString</p>"},{"location":"ltapi/dir_0a3ac6ff289d4ebfcd0c797d13f9a373/#files","title":"Files","text":"Type Name     file StreamString.cpp    file StreamString.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/StreamString/</code></p>"},{"location":"ltapi/_stream_string_8cpp/","title":"File StreamString.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; StreamString &gt; StreamString.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"StreamString.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/StreamString/StreamString.cpp</code></p>"},{"location":"ltapi/_stream_string_8cpp_source/","title":"File StreamString.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; StreamString &gt; StreamString.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"StreamString.h\"\n\nsize_t StreamString::write(const uint8_t *data, size_t size) {\n    if(size &amp;&amp; data) {\n        concat(data, size);\n        return size;\n    }\n    return 0;\n}\n\nsize_t StreamString::write(uint8_t data) {\n    return concat((char) data);\n}\n\nint StreamString::available() {\n    return length();\n}\n\nint StreamString::read() {\n    if(length()) {\n        char c = charAt(0);\n        remove(0, 1);\n        return c;\n\n    }\n    return -1;\n}\n\nint StreamString::peek() {\n    if(length()) {\n        char c = charAt(0);\n        return c;\n    }\n    return -1;\n}\n\nvoid StreamString::flush() {\n}\n</code></pre>"},{"location":"ltapi/_stream_string_8h/","title":"File StreamString.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; StreamString &gt; StreamString.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_stream_string_8h/#classes","title":"Classes","text":"Type Name     class StreamString      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/StreamString/StreamString.h</code></p>"},{"location":"ltapi/_stream_string_8h_source/","title":"File StreamString.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; StreamString &gt; StreamString.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef STREAMSTRING_H_\n#define STREAMSTRING_H_\n\n\nclass StreamString: public Stream, public String\n{\npublic:\n    size_t write(const uint8_t *buffer, size_t size) override;\n    size_t write(uint8_t data) override;\n\n    int available() override;\n    int read() override;\n    int peek() override;\n    void flush() override;\n};\n\n\n#endif /* STREAMSTRING_H_ */\n</code></pre>"},{"location":"ltapi/dir_f2f13d16dd1b4421bdcca863af8fd41a/","title":"Dir cores/common/arduino/libraries/ext/WebServer","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer</p>"},{"location":"ltapi/dir_f2f13d16dd1b4421bdcca863af8fd41a/#files","title":"Files","text":"Type Name     file HTTP_Method.h    file Parsing.cpp    file Uri.h    file WebServer.cpp    file WebServer.h"},{"location":"ltapi/dir_f2f13d16dd1b4421bdcca863af8fd41a/#directories","title":"Directories","text":"Type Name     dir detail    dir uri      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/</code></p>"},{"location":"ltapi/_h_t_t_p___method_8h/","title":"File HTTP_Method.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; HTTP_Method.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_h_t_t_p___method_8h/#public-types","title":"Public Types","text":"Type Name     typedef enum http_method HTTPMethod    enum http_method"},{"location":"ltapi/_h_t_t_p___method_8h/#macros","title":"Macros","text":"Type Name     define HTTP_ANY  (HTTPMethod)(255)   define HTTP_METHOD_MAP (XX)    define XX (num, name, string) HTTP_##name = num,"},{"location":"ltapi/_h_t_t_p___method_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_h_t_t_p___method_8h/#typedef-httpmethod","title":"typedef HTTPMethod","text":"<pre><code>typedef enum http_method HTTPMethod;\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#enum-http_method","title":"enum http_method","text":"<pre><code>enum http_method;\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_h_t_t_p___method_8h/#define-http_any","title":"define HTTP_ANY","text":"<pre><code>#define HTTP_ANY (HTTPMethod)(255)\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#define-http_method_map","title":"define HTTP_METHOD_MAP","text":"<pre><code>#define HTTP_METHOD_MAP (\n    XX\n) \n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#define-xx","title":"define XX","text":"<pre><code>#define XX (\n    num,\n    name,\n    string\n) HTTP_##name = num,\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/HTTP_Method.h</code></p>"},{"location":"ltapi/_h_t_t_p___method_8h_source/","title":"File HTTP_Method.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; HTTP_Method.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n/* Request Methods */\n#define HTTP_METHOD_MAP(XX)          \\\n    XX(0, DELETE, DELETE)            \\\n    XX(1, GET, GET)                  \\\n    XX(2, HEAD, HEAD)                \\\n    XX(3, POST, POST)                \\\n    XX(4, PUT, PUT)                  \\\n    /* pathological */               \\\n    XX(5, CONNECT, CONNECT)          \\\n    XX(6, OPTIONS, OPTIONS)          \\\n    XX(7, TRACE, TRACE)              \\\n    /* WebDAV */                     \\\n    XX(8, COPY, COPY)                \\\n    XX(9, LOCK, LOCK)                \\\n    XX(10, MKCOL, MKCOL)             \\\n    XX(11, MOVE, MOVE)               \\\n    XX(12, PROPFIND, PROPFIND)       \\\n    XX(13, PROPPATCH, PROPPATCH)     \\\n    XX(14, SEARCH, SEARCH)           \\\n    XX(15, UNLOCK, UNLOCK)           \\\n    XX(16, BIND, BIND)               \\\n    XX(17, REBIND, REBIND)           \\\n    XX(18, UNBIND, UNBIND)           \\\n    XX(19, ACL, ACL)                 \\\n    /* subversion */                 \\\n    XX(20, REPORT, REPORT)           \\\n    XX(21, MKACTIVITY, MKACTIVITY)   \\\n    XX(22, CHECKOUT, CHECKOUT)       \\\n    XX(23, MERGE, MERGE)             \\\n    /* upnp */                       \\\n    XX(24, MSEARCH, M - SEARCH)      \\\n    XX(25, NOTIFY, NOTIFY)           \\\n    XX(26, SUBSCRIBE, SUBSCRIBE)     \\\n    XX(27, UNSUBSCRIBE, UNSUBSCRIBE) \\\n    /* RFC-5789 */                   \\\n    XX(28, PATCH, PATCH)             \\\n    XX(29, PURGE, PURGE)             \\\n    /* CalDAV */                     \\\n    XX(30, MKCALENDAR, MKCALENDAR)   \\\n    /* RFC-2068, section 19.6.1.2 */ \\\n    XX(31, LINK, LINK)               \\\n    XX(32, UNLINK, UNLINK)           \\\n    /* icecast */                    \\\n    XX(33, SOURCE, SOURCE)\n\nenum http_method {\n\n#define XX(num, name, string) HTTP_##name = num,\n    HTTP_METHOD_MAP(XX)\n#undef XX\n};\n\ntypedef enum http_method HTTPMethod;\n#define HTTP_ANY (HTTPMethod)(255)\n</code></pre>"},{"location":"ltapi/_parsing_8cpp/","title":"File Parsing.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; Parsing.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/Parsing.cpp</code></p>"},{"location":"ltapi/_parsing_8cpp_source/","title":"File Parsing.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; Parsing.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Parsing.cpp - HTTP request parsing.\n\n  Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#include \"WebServer.h\"\n#include \"WiFiClient.h\"\n#include \"WiFiServer.h\"\n#include \"detail/mimetable.h\"\n\n#ifndef WEBSERVER_MAX_POST_ARGS\n#define WEBSERVER_MAX_POST_ARGS 32\n#endif\n\n#define __STR(a) #a\n#define _STR(a)  __STR(a)\nconst char *_http_method_str[] = {\n#define XX(num, name, string) _STR(name),\n    HTTP_METHOD_MAP(XX)\n#undef XX\n};\n\nstatic const char Content_Type[] PROGMEM = \"Content-Type\";\nstatic const char filename[] PROGMEM     = \"filename\";\n\nstatic char *readBytesWithTimeout(WiFiClient &amp;client, size_t maxLength, size_t &amp;dataLength, int timeout_ms) {\n    char *buf  = nullptr;\n    dataLength = 0;\n    while (dataLength &lt; maxLength) {\n        int tries = timeout_ms;\n        size_t newLength;\n        while (!(newLength = client.available()) &amp;&amp; tries--)\n            delay(1);\n        if (!newLength) {\n            break;\n        }\n        if (!buf) {\n            buf = (char *)malloc(newLength + 1);\n            if (!buf) {\n                return nullptr;\n            }\n        } else {\n            char *newBuf = (char *)realloc(buf, dataLength + newLength + 1);\n            if (!newBuf) {\n                free(buf);\n                return nullptr;\n            }\n            buf = newBuf;\n        }\n        client.readBytes(buf + dataLength, newLength);\n        dataLength += newLength;\n        buf[dataLength] = '\\0';\n    }\n    return buf;\n}\n\nbool WebServer::_parseRequest(WiFiClient &amp;client) {\n    // Read the first line of HTTP request\n    String req = client.readStringUntil('\\r');\n    client.readStringUntil('\\n');\n    // reset header value\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        _currentHeaders[i].value = String();\n    }\n\n    // First line of HTTP request looks like \"GET /path HTTP/1.1\"\n    // Retrieve the \"/path\" part by finding the spaces\n    int addr_start = req.indexOf(' ');\n    int addr_end   = req.indexOf(' ', addr_start + 1);\n    if (addr_start == -1 || addr_end == -1) {\n        log_e(\"Invalid request: %s\", req.c_str());\n        return false;\n    }\n\n    String methodStr  = req.substring(0, addr_start);\n    String url        = req.substring(addr_start + 1, addr_end);\n    String versionEnd = req.substring(addr_end + 8);\n    _currentVersion   = atoi(versionEnd.c_str());\n    String searchStr  = \"\";\n    int hasSearch     = url.indexOf('?');\n    if (hasSearch != -1) {\n        searchStr = url.substring(hasSearch + 1);\n        url       = url.substring(0, hasSearch);\n    }\n    _currentUri = url;\n    _chunked    = false;\n\n    HTTPMethod method  = HTTP_ANY;\n    size_t num_methods = sizeof(_http_method_str) / sizeof(const char *);\n    for (size_t i = 0; i &lt; num_methods; i++) {\n        if (methodStr == _http_method_str[i]) {\n            method = (HTTPMethod)i;\n            break;\n        }\n    }\n    if (method == HTTP_ANY) {\n        log_e(\"Unknown HTTP Method: %s\", methodStr.c_str());\n        return false;\n    }\n    _currentMethod = method;\n\n    log_v(\"method: %s url: %s search: %s\", methodStr.c_str(), url.c_str(), searchStr.c_str());\n\n    // attach handler\n    RequestHandler *handler;\n    for (handler = _firstHandler; handler; handler = handler-&gt;next()) {\n        if (handler-&gt;canHandle(_currentMethod, _currentUri))\n            break;\n    }\n    _currentHandler = handler;\n\n    String formData;\n    // below is needed only when POST type request\n    if (method == HTTP_POST || method == HTTP_PUT || method == HTTP_PATCH || method == HTTP_DELETE) {\n        String boundaryStr;\n        String headerName;\n        String headerValue;\n        bool isForm            = false;\n        bool isEncoded         = false;\n        uint32_t contentLength = 0;\n        // parse headers\n        while (1) {\n            req = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (req == \"\")\n                break; // no moar headers\n            int headerDiv = req.indexOf(':');\n            if (headerDiv == -1) {\n                break;\n            }\n            headerName  = req.substring(0, headerDiv);\n            headerValue = req.substring(headerDiv + 1);\n            headerValue.trim();\n            _collectHeader(headerName.c_str(), headerValue.c_str());\n\n            log_v(\"headerName: %s\", headerName.c_str());\n            log_v(\"headerValue: %s\", headerValue.c_str());\n\n            if (headerName.equalsIgnoreCase(FPSTR(Content_Type))) {\n                using namespace mime;\n                if (headerValue.startsWith(FPSTR(mimeTable[txt].mimeType))) {\n                    isForm = false;\n                } else if (headerValue.startsWith(F(\"application/x-www-form-urlencoded\"))) {\n                    isForm    = false;\n                    isEncoded = true;\n                } else if (headerValue.startsWith(F(\"multipart/\"))) {\n                    boundaryStr = headerValue.substring(headerValue.indexOf('=') + 1);\n                    boundaryStr.replace(\"\\\"\", \"\");\n                    isForm = true;\n                }\n            } else if (headerName.equalsIgnoreCase(F(\"Content-Length\"))) {\n                contentLength = headerValue.toInt();\n            } else if (headerName.equalsIgnoreCase(F(\"Host\"))) {\n                _hostHeader = headerValue;\n            }\n        }\n\n        if (!isForm) {\n            size_t plainLength;\n            char *plainBuf = readBytesWithTimeout(client, contentLength, plainLength, HTTP_MAX_POST_WAIT);\n            if (plainLength &lt; contentLength) {\n                free(plainBuf);\n                return false;\n            }\n            if (contentLength &gt; 0) {\n                if (isEncoded) {\n                    // url encoded form\n                    if (searchStr != \"\")\n                        searchStr += '&amp;';\n                    searchStr += plainBuf;\n                }\n                _parseArguments(searchStr);\n                if (!isEncoded) {\n                    // plain post json or other data\n                    RequestArgument &amp;arg = _currentArgs[_currentArgCount++];\n                    arg.key              = F(\"plain\");\n                    arg.value            = String(plainBuf);\n                }\n\n                log_v(\"Plain: %s\", plainBuf);\n                free(plainBuf);\n            } else {\n                // No content - but we can still have arguments in the URL.\n                _parseArguments(searchStr);\n            }\n        }\n\n        if (isForm) {\n            _parseArguments(searchStr);\n            if (!_parseForm(client, boundaryStr, contentLength)) {\n                return false;\n            }\n        }\n    } else {\n        String headerName;\n        String headerValue;\n        // parse headers\n        while (1) {\n            req = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (req == \"\")\n                break; // no moar headers\n            int headerDiv = req.indexOf(':');\n            if (headerDiv == -1) {\n                break;\n            }\n            headerName  = req.substring(0, headerDiv);\n            headerValue = req.substring(headerDiv + 2);\n            _collectHeader(headerName.c_str(), headerValue.c_str());\n\n            log_v(\"headerName: %s\", headerName.c_str());\n            log_v(\"headerValue: %s\", headerValue.c_str());\n\n            if (headerName.equalsIgnoreCase(\"Host\")) {\n                _hostHeader = headerValue;\n            }\n        }\n        _parseArguments(searchStr);\n    }\n    client.flush();\n\n    log_v(\"Request: %s\", url.c_str());\n    log_v(\" Arguments: %s\", searchStr.c_str());\n\n    return true;\n}\n\nbool WebServer::_collectHeader(const char *headerName, const char *headerValue) {\n    for (int i = 0; i &lt; _headerKeysCount; i++) {\n        if (_currentHeaders[i].key.equalsIgnoreCase(headerName)) {\n            _currentHeaders[i].value = headerValue;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid WebServer::_parseArguments(String data) {\n    log_v(\"args: %s\", data.c_str());\n    if (_currentArgs)\n        delete[] _currentArgs;\n    _currentArgs = 0;\n    if (data.length() == 0) {\n        _currentArgCount = 0;\n        _currentArgs     = new RequestArgument[1];\n        return;\n    }\n    _currentArgCount = 1;\n\n    for (int i = 0; i &lt; (int)data.length();) {\n        i = data.indexOf('&amp;', i);\n        if (i == -1)\n            break;\n        ++i;\n        ++_currentArgCount;\n    }\n    log_v(\"args count: %d\", _currentArgCount);\n\n    _currentArgs = new RequestArgument[_currentArgCount + 1];\n    int pos      = 0;\n    int iarg;\n    for (iarg = 0; iarg &lt; _currentArgCount;) {\n        int equal_sign_index = data.indexOf('=', pos);\n        int next_arg_index   = data.indexOf('&amp;', pos);\n        log_v(\"pos %d =@%d &amp;@%d\", pos, equal_sign_index, next_arg_index);\n        if ((equal_sign_index == -1) || ((equal_sign_index &gt; next_arg_index) &amp;&amp; (next_arg_index != -1))) {\n            log_e(\"arg missing value: %d\", iarg);\n            if (next_arg_index == -1)\n                break;\n            pos = next_arg_index + 1;\n            continue;\n        }\n        RequestArgument &amp;arg = _currentArgs[iarg];\n        arg.key              = urlDecode(data.substring(pos, equal_sign_index));\n        arg.value            = urlDecode(data.substring(equal_sign_index + 1, next_arg_index));\n        log_v(\"arg %d key: %s value: %s\", iarg, arg.key.c_str(), arg.value.c_str());\n        ++iarg;\n        if (next_arg_index == -1)\n            break;\n        pos = next_arg_index + 1;\n    }\n    _currentArgCount = iarg;\n    log_v(\"args count: %d\", _currentArgCount);\n}\n\nvoid WebServer::_uploadWriteByte(uint8_t b) {\n    if (_currentUpload-&gt;currentSize == HTTP_UPLOAD_BUFLEN) {\n        if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n            _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n        _currentUpload-&gt;totalSize += _currentUpload-&gt;currentSize;\n        _currentUpload-&gt;currentSize = 0;\n    }\n    _currentUpload-&gt;buf[_currentUpload-&gt;currentSize++] = b;\n}\n\nint WebServer::_uploadReadByte(WiFiClient &amp;client) {\n    int res = client.read();\n    if (res &lt; 0) {\n        // keep trying until you either read a valid byte or timeout\n        unsigned long startMillis  = millis();\n        long timeoutIntervalMillis = client.getTimeout();\n        boolean timedOut           = false;\n        for (;;) {\n            if (!client.connected())\n                return -1;\n            // loosely modeled after blinkWithoutDelay pattern\n            while (!timedOut &amp;&amp; !client.available() &amp;&amp; client.connected()) {\n                delay(2);\n                timedOut = millis() - startMillis &gt;= timeoutIntervalMillis;\n            }\n\n            res = client.read();\n            if (res &gt;= 0) {\n                return res; // exit on a valid read\n            }\n            // NOTE: it is possible to get here and have all of the following\n            //       assertions hold true\n            //\n            //       -- client.available() &gt; 0\n            //       -- client.connected == true\n            //       -- res == -1\n            //\n            //       a simple retry strategy overcomes this which is to say the\n            //       assertion is not permanent, but the reason that this works\n            //       is elusive, and possibly indicative of a more subtle underlying\n            //       issue\n\n            timedOut = millis() - startMillis &gt;= timeoutIntervalMillis;\n            if (timedOut) {\n                return res; // exit on a timeout\n            }\n        }\n    }\n\n    return res;\n}\n\nbool WebServer::_parseForm(WiFiClient &amp;client, String boundary, uint32_t len) {\n    (void)len;\n    log_v(\"Parse Form: Boundary: %s Length: %d\", boundary.c_str(), len);\n    String line;\n    int retry = 0;\n    do {\n        line = client.readStringUntil('\\r');\n        ++retry;\n    } while (line.length() == 0 &amp;&amp; retry &lt; 3);\n\n    client.readStringUntil('\\n');\n    // start reading the form\n    if (line == (\"--\" + boundary)) {\n        if (_postArgs)\n            delete[] _postArgs;\n        _postArgs    = new RequestArgument[WEBSERVER_MAX_POST_ARGS];\n        _postArgsLen = 0;\n        while (1) {\n            String argName;\n            String argValue;\n            String argType;\n            String argFilename;\n            bool argIsFile = false;\n\n            line = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (line.length() &gt; 19 &amp;&amp; line.substring(0, 19).equalsIgnoreCase(F(\"Content-Disposition\"))) {\n                int nameStart = line.indexOf('=');\n                if (nameStart != -1) {\n                    argName   = line.substring(nameStart + 2);\n                    nameStart = argName.indexOf('=');\n                    if (nameStart == -1) {\n                        argName = argName.substring(0, argName.length() - 1);\n                    } else {\n                        argFilename = argName.substring(nameStart + 2, argName.length() - 1);\n                        argName     = argName.substring(0, argName.indexOf('\"'));\n                        argIsFile   = true;\n                        log_v(\"PostArg FileName: %s\", argFilename.c_str());\n                        // use GET to set the filename if uploading using blob\n                        if (argFilename == F(\"blob\") &amp;&amp; hasArg(FPSTR(filename)))\n                            argFilename = arg(FPSTR(filename));\n                    }\n                    log_v(\"PostArg Name: %s\", argName.c_str());\n                    using namespace mime;\n                    argType = FPSTR(mimeTable[txt].mimeType);\n                    line    = client.readStringUntil('\\r');\n                    client.readStringUntil('\\n');\n                    if (line.length() &gt; 12 &amp;&amp; line.substring(0, 12).equalsIgnoreCase(FPSTR(Content_Type))) {\n                        argType = line.substring(line.indexOf(':') + 2);\n                        // skip next line\n                        client.readStringUntil('\\r');\n                        client.readStringUntil('\\n');\n                    }\n                    log_v(\"PostArg Type: %s\", argType.c_str());\n                    if (!argIsFile) {\n                        while (1) {\n                            line = client.readStringUntil('\\r');\n                            client.readStringUntil('\\n');\n                            if (line.startsWith(\"--\" + boundary))\n                                break;\n                            if (argValue.length() &gt; 0)\n                                argValue += \"\\n\";\n                            argValue += line;\n                        }\n                        log_v(\"PostArg Value: %s\", argValue.c_str());\n\n                        RequestArgument &amp;arg = _postArgs[_postArgsLen++];\n                        arg.key              = argName;\n                        arg.value            = argValue;\n\n                        if (line == (\"--\" + boundary + \"--\")) {\n                            log_v(\"Done Parsing POST\");\n                            break;\n                        } else if (_postArgsLen &gt;= WEBSERVER_MAX_POST_ARGS) {\n                            log_e(\"Too many PostArgs (max: %d) in request.\", WEBSERVER_MAX_POST_ARGS);\n                            return false;\n                        }\n                    } else {\n                        _currentUpload.reset(new HTTPUpload());\n                        _currentUpload-&gt;status      = UPLOAD_FILE_START;\n                        _currentUpload-&gt;name        = argName;\n                        _currentUpload-&gt;filename    = argFilename;\n                        _currentUpload-&gt;type        = argType;\n                        _currentUpload-&gt;totalSize   = 0;\n                        _currentUpload-&gt;currentSize = 0;\n                        log_v(\n                            \"Start File: %s Type: %s\",\n                            _currentUpload-&gt;filename.c_str(),\n                            _currentUpload-&gt;type.c_str()\n                        );\n                        if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                            _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                        _currentUpload-&gt;status = UPLOAD_FILE_WRITE;\n                        int argByte            = _uploadReadByte(client);\n                    readfile:\n\n                        while (argByte != 0x0D) {\n                            if (argByte &lt; 0)\n                                return _parseFormUploadAborted();\n                            _uploadWriteByte(argByte);\n                            argByte = _uploadReadByte(client);\n                        }\n\n                        argByte = _uploadReadByte(client);\n                        if (argByte &lt; 0)\n                            return _parseFormUploadAborted();\n                        if (argByte == 0x0A) {\n                            argByte = _uploadReadByte(client);\n                            if (argByte &lt; 0)\n                                return _parseFormUploadAborted();\n                            if ((char)argByte != '-') {\n                                // continue reading the file\n                                _uploadWriteByte(0x0D);\n                                _uploadWriteByte(0x0A);\n                                goto readfile;\n                            } else {\n                                argByte = _uploadReadByte(client);\n                                if (argByte &lt; 0)\n                                    return _parseFormUploadAborted();\n                                if ((char)argByte != '-') {\n                                    // continue reading the file\n                                    _uploadWriteByte(0x0D);\n                                    _uploadWriteByte(0x0A);\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    goto readfile;\n                                }\n                            }\n\n                            uint8_t endBuf[boundary.length()];\n                            uint32_t i = 0;\n                            while (i &lt; boundary.length()) {\n                                argByte = _uploadReadByte(client);\n                                if (argByte &lt; 0)\n                                    return _parseFormUploadAborted();\n                                if ((char)argByte == 0x0D) {\n                                    _uploadWriteByte(0x0D);\n                                    _uploadWriteByte(0x0A);\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    uint32_t j = 0;\n                                    while (j &lt; i) {\n                                        _uploadWriteByte(endBuf[j++]);\n                                    }\n                                    goto readfile;\n                                }\n                                endBuf[i++] = (uint8_t)argByte;\n                            }\n\n                            if (strstr((const char *)endBuf, boundary.c_str()) != NULL) {\n                                if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                                    _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                                _currentUpload-&gt;totalSize += _currentUpload-&gt;currentSize;\n                                _currentUpload-&gt;status = UPLOAD_FILE_END;\n                                if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                                    _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                                log_v(\n                                    \"End File: %s Type: %s Size: %d\",\n                                    _currentUpload-&gt;filename.c_str(),\n                                    _currentUpload-&gt;type.c_str(),\n                                    _currentUpload-&gt;totalSize\n                                );\n                                line = client.readStringUntil(0x0D);\n                                client.readStringUntil(0x0A);\n                                if (line == \"--\") {\n                                    log_v(\"Done Parsing POST\");\n                                    break;\n                                }\n                                continue;\n                            } else {\n                                _uploadWriteByte(0x0D);\n                                _uploadWriteByte(0x0A);\n                                _uploadWriteByte((uint8_t)('-'));\n                                _uploadWriteByte((uint8_t)('-'));\n                                uint32_t i = 0;\n                                while (i &lt; boundary.length()) {\n                                    _uploadWriteByte(endBuf[i++]);\n                                }\n                                argByte = _uploadReadByte(client);\n                                goto readfile;\n                            }\n                        } else {\n                            _uploadWriteByte(0x0D);\n                            goto readfile;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        int iarg;\n        int totalArgs = ((WEBSERVER_MAX_POST_ARGS - _postArgsLen) &lt; _currentArgCount)\n                            ? (WEBSERVER_MAX_POST_ARGS - _postArgsLen)\n                            : _currentArgCount;\n        for (iarg = 0; iarg &lt; totalArgs; iarg++) {\n            RequestArgument &amp;arg = _postArgs[_postArgsLen++];\n            arg.key              = _currentArgs[iarg].key;\n            arg.value            = _currentArgs[iarg].value;\n        }\n        if (_currentArgs)\n            delete[] _currentArgs;\n        _currentArgs = new RequestArgument[_postArgsLen];\n        for (iarg = 0; iarg &lt; _postArgsLen; iarg++) {\n            RequestArgument &amp;arg = _currentArgs[iarg];\n            arg.key              = _postArgs[iarg].key;\n            arg.value            = _postArgs[iarg].value;\n        }\n        _currentArgCount = iarg;\n        if (_postArgs) {\n            delete[] _postArgs;\n            _postArgs    = nullptr;\n            _postArgsLen = 0;\n        }\n        return true;\n    }\n    log_e(\"Error: line: %s\", line.c_str());\n    return false;\n}\n\nString WebServer::urlDecode(const String &amp;text) {\n    String decoded   = \"\";\n    char temp[]      = \"0x00\";\n    unsigned int len = text.length();\n    unsigned int i   = 0;\n    while (i &lt; len) {\n        char decodedChar;\n        char encodedChar = text.charAt(i++);\n        if ((encodedChar == '%') &amp;&amp; (i + 1 &lt; len)) {\n            temp[2] = text.charAt(i++);\n            temp[3] = text.charAt(i++);\n\n            decodedChar = strtol(temp, NULL, 16);\n        } else {\n            if (encodedChar == '+') {\n                decodedChar = ' ';\n            } else {\n                decodedChar = encodedChar; // normal ascii char\n            }\n        }\n        decoded += decodedChar;\n    }\n    return decoded;\n}\n\nbool WebServer::_parseFormUploadAborted() {\n    _currentUpload-&gt;status = UPLOAD_FILE_ABORTED;\n    if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n        _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n    return false;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_uri_8h/","title":"File Uri.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; Uri.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_uri_8h/#classes","title":"Classes","text":"Type Name     class Uri      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/Uri.h</code></p>"},{"location":"ltapi/_uri_8h_source/","title":"File Uri.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; Uri.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;vector&gt;\n\nclass Uri {\n\n  protected:\n    const String _uri;\n\n  public:\n    Uri(const char *uri) : _uri(uri) {}\n\n    Uri(const String &amp;uri) : _uri(uri) {}\n\n    Uri(const __FlashStringHelper *uri) : _uri(String(uri)) {}\n\n    virtual ~Uri() {}\n\n    virtual Uri *clone() const {\n        return new Uri(_uri);\n    };\n\n    virtual void initPathArgs(__attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) {}\n\n    virtual bool canHandle(const String &amp;requestUri, __attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) {\n        return _uri == requestUri;\n    }\n};\n</code></pre>"},{"location":"ltapi/_web_server_8cpp/","title":"File WebServer.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; WebServer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/WebServer.cpp</code></p>"},{"location":"ltapi/_web_server_8cpp_source/","title":"File WebServer.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; WebServer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WebServer.cpp - Dead simple web-server.\n  Supports only one simultaneous client, knows how to handle GET and POST.\n\n  Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#include \"FS.h\"\n#include \"WebServer.h\"\n#include \"WiFiClient.h\"\n#include \"WiFiServer.h\"\n#include \"detail/RequestHandlersImpl.h\"\n// #include \"mbedtls/md5.h\"\n#include &lt;libb64/cencode.h&gt;\n\nstatic const char AUTHORIZATION_HEADER[]    = \"Authorization\";\nstatic const char qop_auth[] PROGMEM        = \"qop=auth\";\nstatic const char qop_auth_quoted[] PROGMEM = \"qop=\\\"auth\\\"\";\nstatic const char WWW_Authenticate[]        = \"WWW-Authenticate\";\nstatic const char Content_Length[]          = \"Content-Length\";\n\nWebServer::WebServer(IPAddress addr, int port)\n    : _corsEnabled(false), _server(addr, port), _currentMethod(HTTP_ANY), _currentVersion(0), _currentStatus(HC_NONE),\n      _statusChange(0), _nullDelay(true), _currentHandler(nullptr), _firstHandler(nullptr), _lastHandler(nullptr),\n      _currentArgCount(0), _currentArgs(nullptr), _postArgsLen(0), _postArgs(nullptr), _headerKeysCount(0),\n      _currentHeaders(nullptr), _contentLength(0), _chunked(false) {\n    log_v(\"WebServer::Webserver(addr=%s, port=%d)\", ipToString(addr).c_str(), port);\n}\n\nWebServer::WebServer(int port)\n    : _corsEnabled(false), _server(port), _currentMethod(HTTP_ANY), _currentVersion(0), _currentStatus(HC_NONE),\n      _statusChange(0), _nullDelay(true), _currentHandler(nullptr), _firstHandler(nullptr), _lastHandler(nullptr),\n      _currentArgCount(0), _currentArgs(nullptr), _postArgsLen(0), _postArgs(nullptr), _headerKeysCount(0),\n      _currentHeaders(nullptr), _contentLength(0), _chunked(false) {\n    log_v(\"WebServer::Webserver(port=%d)\", port);\n}\n\nWebServer::~WebServer() {\n    _server.close();\n    if (_currentHeaders)\n        delete[] _currentHeaders;\n    RequestHandler *handler = _firstHandler;\n    while (handler) {\n        RequestHandler *next = handler-&gt;next();\n        delete handler;\n        handler = next;\n    }\n}\n\nvoid WebServer::begin() {\n    close();\n    _server.begin();\n    _server.setNoDelay(true);\n}\n\nvoid WebServer::begin(uint16_t port) {\n    close();\n    _server.begin(port);\n    _server.setNoDelay(true);\n}\n\nString WebServer::_extractParam(String &amp;authReq, const String &amp;param, const char delimit) {\n    int _begin = authReq.indexOf(param);\n    if (_begin == -1)\n        return \"\";\n    return authReq.substring(_begin + param.length(), authReq.indexOf(delimit, _begin + param.length()));\n}\n\nstatic String md5str(String &amp;in) {\n    /* char out[33] = {0};\n    mbedtls_md5_context _ctx;\n    uint8_t i;\n    uint8_t *_buf = (uint8_t *)malloc(16);\n    if (_buf == NULL)\n        return String(out);\n    memset(_buf, 0x00, 16);\n    mbedtls_md5_init(&amp;_ctx);\n    mbedtls_md5_starts_ret(&amp;_ctx);\n    mbedtls_md5_update_ret(&amp;_ctx, (const uint8_t *)in.c_str(), in.length());\n    mbedtls_md5_finish_ret(&amp;_ctx, _buf);\n    for (i = 0; i &lt; 16; i++) {\n        sprintf(out + (i * 2), \"%02x\", _buf[i]);\n    }\n    out[32] = 0;\n    free(_buf);\n    return String(out); */\n    return \"\";\n}\n\nbool WebServer::authenticate(const char *username, const char *password) {\n    if (hasHeader(FPSTR(AUTHORIZATION_HEADER))) {\n        String authReq = header(FPSTR(AUTHORIZATION_HEADER));\n        if (authReq.startsWith(F(\"Basic\"))) {\n            authReq = authReq.substring(6);\n            authReq.trim();\n            char toencodeLen = strlen(username) + strlen(password) + 1;\n            char *toencode   = new char[toencodeLen + 1];\n            if (toencode == NULL) {\n                authReq = \"\";\n                return false;\n            }\n            char *encoded = new char[base64_encode_expected_len(toencodeLen) + 1];\n            if (encoded == NULL) {\n                authReq = \"\";\n                delete[] toencode;\n                return false;\n            }\n            sprintf(toencode, \"%s:%s\", username, password);\n            if (base64_encode_chars(toencode, toencodeLen, encoded) &gt; 0 &amp;&amp; authReq.equals(encoded)) {\n                authReq = \"\";\n                delete[] toencode;\n                delete[] encoded;\n                return true;\n            }\n            delete[] toencode;\n            delete[] encoded;\n        } else if (authReq.startsWith(F(\"Digest\"))) {\n            authReq = authReq.substring(7);\n            log_v(\"%s\", authReq.c_str());\n            String _username = _extractParam(authReq, F(\"username=\\\"\"), '\\\"');\n            if (!_username.length() || _username != String(username)) {\n                authReq = \"\";\n                return false;\n            }\n            // extracting required parameters for RFC 2069 simpler Digest\n            String _realm    = _extractParam(authReq, F(\"realm=\\\"\"), '\\\"');\n            String _nonce    = _extractParam(authReq, F(\"nonce=\\\"\"), '\\\"');\n            String _uri      = _extractParam(authReq, F(\"uri=\\\"\"), '\\\"');\n            String _response = _extractParam(authReq, F(\"response=\\\"\"), '\\\"');\n            String _opaque   = _extractParam(authReq, F(\"opaque=\\\"\"), '\\\"');\n\n            if ((!_realm.length()) || (!_nonce.length()) || (!_uri.length()) || (!_response.length()) ||\n                (!_opaque.length())) {\n                authReq = \"\";\n                return false;\n            }\n            if ((_opaque != _sopaque) || (_nonce != _snonce) || (_realm != _srealm)) {\n                authReq = \"\";\n                return false;\n            }\n            // parameters for the RFC 2617 newer Digest\n            String _nc, _cnonce;\n            if (authReq.indexOf(FPSTR(qop_auth)) != -1 || authReq.indexOf(FPSTR(qop_auth_quoted)) != -1) {\n                _nc     = _extractParam(authReq, F(\"nc=\"), ',');\n                _cnonce = _extractParam(authReq, F(\"cnonce=\\\"\"), '\\\"');\n            }\n            String _H1 = md5str(String(username) + ':' + _realm + ':' + String(password));\n            log_v(\"Hash of user:realm:pass=%s\", _H1.c_str());\n            String _H2 = \"\";\n            if (_currentMethod == HTTP_GET) {\n                _H2 = md5str(String(F(\"GET:\")) + _uri);\n            } else if (_currentMethod == HTTP_POST) {\n                _H2 = md5str(String(F(\"POST:\")) + _uri);\n            } else if (_currentMethod == HTTP_PUT) {\n                _H2 = md5str(String(F(\"PUT:\")) + _uri);\n            } else if (_currentMethod == HTTP_DELETE) {\n                _H2 = md5str(String(F(\"DELETE:\")) + _uri);\n            } else {\n                _H2 = md5str(String(F(\"GET:\")) + _uri);\n            }\n            log_v(\"Hash of GET:uri=%s\", _H2.c_str());\n            String _responsecheck = \"\";\n            if (authReq.indexOf(FPSTR(qop_auth)) != -1 || authReq.indexOf(FPSTR(qop_auth_quoted)) != -1) {\n                _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _nc + ':' + _cnonce + F(\":auth:\") + _H2);\n            } else {\n                _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _H2);\n            }\n            log_v(\"The Proper response=%s\", _responsecheck.c_str());\n            if (_response == _responsecheck) {\n                authReq = \"\";\n                return true;\n            }\n        }\n        authReq = \"\";\n    }\n    return false;\n}\n\nString WebServer::_getRandomHexString() {\n    char buffer[33]; // buffer to hold 32 Hex Digit + /0\n    int i;\n    for (i = 0; i &lt; 4; i++) {\n        sprintf(buffer + (i * 8), \"%08x\", rand());\n    }\n    return String(buffer);\n}\n\nvoid WebServer::requestAuthentication(HTTPAuthMethod mode, const char *realm, const String &amp;authFailMsg) {\n    if (realm == NULL) {\n        _srealm = String(F(\"Login Required\"));\n    } else {\n        _srealm = String(realm);\n    }\n    if (mode == BASIC_AUTH) {\n        sendHeader(String(FPSTR(WWW_Authenticate)), String(F(\"Basic realm=\\\"\")) + _srealm + String(F(\"\\\"\")));\n    } else {\n        _snonce  = _getRandomHexString();\n        _sopaque = _getRandomHexString();\n        sendHeader(\n            String(FPSTR(WWW_Authenticate)),\n            String(F(\"Digest realm=\\\"\")) + _srealm + String(F(\"\\\", qop=\\\"auth\\\", nonce=\\\"\")) + _snonce +\n                String(F(\"\\\", opaque=\\\"\")) + _sopaque + String(F(\"\\\"\"))\n        );\n    }\n    using namespace mime;\n    send(401, String(FPSTR(mimeTable[html].mimeType)), authFailMsg);\n}\n\nvoid WebServer::on(const Uri &amp;uri, WebServer::THandlerFunction handler) {\n    on(uri, HTTP_ANY, handler);\n}\n\nvoid WebServer::on(const Uri &amp;uri, HTTPMethod method, WebServer::THandlerFunction fn) {\n    on(uri, method, fn, _fileUploadHandler);\n}\n\nvoid WebServer::on(const Uri &amp;uri, HTTPMethod method, WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn) {\n    _addRequestHandler(new FunctionRequestHandler(fn, ufn, uri, method));\n}\n\nvoid WebServer::addHandler(RequestHandler *handler) {\n    _addRequestHandler(handler);\n}\n\nvoid WebServer::_addRequestHandler(RequestHandler *handler) {\n    if (!_lastHandler) {\n        _firstHandler = handler;\n        _lastHandler  = handler;\n    } else {\n        _lastHandler-&gt;next(handler);\n        _lastHandler = handler;\n    }\n}\n\nvoid WebServer::serveStatic(const char *uri, FS &amp;fs, const char *path, const char *cache_header) {\n    _addRequestHandler(new StaticRequestHandler(fs, path, uri, cache_header));\n}\n\nvoid WebServer::handleClient() {\n    if (_currentStatus == HC_NONE) {\n        WiFiClient client = _server.available();\n        if (!client) {\n            if (_nullDelay) {\n                delay(1);\n            }\n            return;\n        }\n\n        log_v(\"New client: client.localIP()=%s\", ipToString(client.localIP()).c_str());\n\n        _currentClient = client;\n        _currentStatus = HC_WAIT_READ;\n        _statusChange  = millis();\n    }\n\n    bool keepCurrentClient = false;\n    bool callYield         = false;\n\n    if (_currentClient.connected()) {\n        switch (_currentStatus) {\n            case HC_NONE:\n                // No-op to avoid C++ compiler warning\n                break;\n            case HC_WAIT_READ:\n                // Wait for data from client to become available\n                if (_currentClient.available()) {\n                    if (_parseRequest(_currentClient)) {\n                        // because HTTP_MAX_SEND_WAIT is expressed in milliseconds,\n                        // it must be divided by 1000\n                        _currentClient.setTimeout(HTTP_MAX_SEND_WAIT / 1000);\n                        _contentLength = CONTENT_LENGTH_NOT_SET;\n                        _handleRequest();\n\n                        // Fix for issue with Chrome based browsers:\n                        // https://github.com/espressif/arduino-esp32/issues/3652\n                        //           if (_currentClient.connected()) {\n                        //             _currentStatus = HC_WAIT_CLOSE;\n                        //             _statusChange = millis();\n                        //             keepCurrentClient = true;\n                        //           }\n                    }\n                } else { // !_currentClient.available()\n                    if (millis() - _statusChange &lt;= HTTP_MAX_DATA_WAIT) {\n                        keepCurrentClient = true;\n                    }\n                    callYield = true;\n                }\n                break;\n            case HC_WAIT_CLOSE:\n                // Wait for client to close the connection\n                if (millis() - _statusChange &lt;= HTTP_MAX_CLOSE_WAIT) {\n                    keepCurrentClient = true;\n                    callYield         = true;\n                }\n        }\n    }\n\n    if (!keepCurrentClient) {\n        _currentClient = WiFiClient();\n        _currentStatus = HC_NONE;\n        _currentUpload.reset();\n    }\n\n    if (callYield) {\n        yield();\n    }\n}\n\nvoid WebServer::close() {\n    _server.close();\n    _currentStatus = HC_NONE;\n    if (!_headerKeysCount)\n        collectHeaders(0, 0);\n}\n\nvoid WebServer::stop() {\n    close();\n}\n\nvoid WebServer::sendHeader(const String &amp;name, const String &amp;value, bool first) {\n    String headerLine = name;\n    headerLine += F(\": \");\n    headerLine += value;\n    headerLine += \"\\r\\n\";\n\n    if (first) {\n        _responseHeaders = headerLine + _responseHeaders;\n    } else {\n        _responseHeaders += headerLine;\n    }\n}\n\nvoid WebServer::setContentLength(const size_t contentLength) {\n    _contentLength = contentLength;\n}\n\nvoid WebServer::enableDelay(boolean value) {\n    _nullDelay = value;\n}\n\nvoid WebServer::enableCORS(boolean value) {\n    _corsEnabled = value;\n}\n\nvoid WebServer::enableCrossOrigin(boolean value) {\n    enableCORS(value);\n}\n\nvoid WebServer::_prepareHeader(String &amp;response, int code, const char *content_type, size_t contentLength) {\n    response = String(F(\"HTTP/1.\")) + String(_currentVersion) + ' ';\n    response += String(code);\n    response += ' ';\n    response += _responseCodeToString(code);\n    response += \"\\r\\n\";\n\n    using namespace mime;\n    if (!content_type)\n        content_type = mimeTable[html].mimeType;\n\n    sendHeader(String(F(\"Content-Type\")), String(FPSTR(content_type)), true);\n    if (_contentLength == CONTENT_LENGTH_NOT_SET) {\n        sendHeader(String(FPSTR(Content_Length)), String(contentLength));\n    } else if (_contentLength != CONTENT_LENGTH_UNKNOWN) {\n        sendHeader(String(FPSTR(Content_Length)), String(_contentLength));\n    } else if (_contentLength == CONTENT_LENGTH_UNKNOWN &amp;&amp; _currentVersion) { // HTTP/1.1 or above client\n        // let's do chunked\n        _chunked = true;\n        sendHeader(String(F(\"Accept-Ranges\")), String(F(\"none\")));\n        sendHeader(String(F(\"Transfer-Encoding\")), String(F(\"chunked\")));\n    }\n    if (_corsEnabled) {\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Origin\")), String(\"*\"));\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Methods\")), String(\"*\"));\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Headers\")), String(\"*\"));\n    }\n    sendHeader(String(F(\"Connection\")), String(F(\"close\")));\n\n    response += _responseHeaders;\n    response += \"\\r\\n\";\n    _responseHeaders = \"\";\n}\n\nvoid WebServer::send(int code, const char *content_type, const String &amp;content) {\n    String header;\n    // Can we asume the following?\n    // if(code == 200 &amp;&amp; content.length() == 0 &amp;&amp; _contentLength == CONTENT_LENGTH_NOT_SET)\n    //  _contentLength = CONTENT_LENGTH_UNKNOWN;\n    _prepareHeader(header, code, content_type, content.length());\n    _currentClientWrite(header.c_str(), header.length());\n    if (content.length())\n        sendContent(content);\n}\n\nvoid WebServer::send_P(int code, PGM_P content_type, PGM_P content) {\n    size_t contentLength = 0;\n\n    if (content != NULL) {\n        contentLength = strlen_P(content);\n    }\n\n    String header;\n    char type[64];\n    strncpy_P(type, (PGM_P)content_type, sizeof(type));\n    _prepareHeader(header, code, (const char *)type, contentLength);\n    _currentClientWrite(header.c_str(), header.length());\n    sendContent_P(content);\n}\n\nvoid WebServer::send_P(int code, PGM_P content_type, PGM_P content, size_t contentLength) {\n    String header;\n    char type[64];\n    strncpy_P(type, (PGM_P)content_type, sizeof(type));\n    _prepareHeader(header, code, (const char *)type, contentLength);\n    sendContent(header);\n    sendContent_P(content, contentLength);\n}\n\nvoid WebServer::send(int code, char *content_type, const String &amp;content) {\n    send(code, (const char *)content_type, content);\n}\n\nvoid WebServer::send(int code, const String &amp;content_type, const String &amp;content) {\n    send(code, (const char *)content_type.c_str(), content);\n}\n\nvoid WebServer::sendContent(const String &amp;content) {\n    sendContent(content.c_str(), content.length());\n}\n\nvoid WebServer::sendContent(const char *content, size_t contentLength) {\n    const char *footer = \"\\r\\n\";\n    if (_chunked) {\n        char *chunkSize = (char *)malloc(11);\n        if (chunkSize) {\n            sprintf(chunkSize, \"%x%s\", contentLength, footer);\n            _currentClientWrite(chunkSize, strlen(chunkSize));\n            free(chunkSize);\n        }\n    }\n    _currentClientWrite(content, contentLength);\n    if (_chunked) {\n        _currentClient.write(footer, 2);\n        if (contentLength == 0) {\n            _chunked = false;\n        }\n    }\n}\n\nvoid WebServer::sendContent_P(PGM_P content) {\n    sendContent_P(content, strlen_P(content));\n}\n\nvoid WebServer::sendContent_P(PGM_P content, size_t size) {\n    const char *footer = \"\\r\\n\";\n    if (_chunked) {\n        char *chunkSize = (char *)malloc(11);\n        if (chunkSize) {\n            sprintf(chunkSize, \"%x%s\", size, footer);\n            _currentClientWrite(chunkSize, strlen(chunkSize));\n            free(chunkSize);\n        }\n    }\n    _currentClientWrite_P(content, size);\n    if (_chunked) {\n        _currentClient.write(footer, 2);\n        if (size == 0) {\n            _chunked = false;\n        }\n    }\n}\n\nvoid WebServer::_streamFileCore(const size_t fileSize, const String &amp;fileName, const String &amp;contentType) {\n    using namespace mime;\n    setContentLength(fileSize);\n    if (fileName.endsWith(String(FPSTR(mimeTable[gz].endsWith))) &amp;&amp;\n        contentType != String(FPSTR(mimeTable[gz].mimeType)) &amp;&amp;\n        contentType != String(FPSTR(mimeTable[none].mimeType))) {\n        sendHeader(F(\"Content-Encoding\"), F(\"gzip\"));\n    }\n    send(200, contentType, \"\");\n}\n\nString WebServer::pathArg(unsigned int i) {\n    if (_currentHandler != nullptr)\n        return _currentHandler-&gt;pathArg(i);\n    return \"\";\n}\n\nString WebServer::arg(String name) {\n    for (int j = 0; j &lt; _postArgsLen; ++j) {\n        if (_postArgs[j].key == name)\n            return _postArgs[j].value;\n    }\n    for (int i = 0; i &lt; _currentArgCount; ++i) {\n        if (_currentArgs[i].key == name)\n            return _currentArgs[i].value;\n    }\n    return \"\";\n}\n\nString WebServer::arg(int i) {\n    if (i &lt; _currentArgCount)\n        return _currentArgs[i].value;\n    return \"\";\n}\n\nString WebServer::argName(int i) {\n    if (i &lt; _currentArgCount)\n        return _currentArgs[i].key;\n    return \"\";\n}\n\nint WebServer::args() {\n    return _currentArgCount;\n}\n\nbool WebServer::hasArg(String name) {\n    for (int j = 0; j &lt; _postArgsLen; ++j) {\n        if (_postArgs[j].key == name)\n            return true;\n    }\n    for (int i = 0; i &lt; _currentArgCount; ++i) {\n        if (_currentArgs[i].key == name)\n            return true;\n    }\n    return false;\n}\n\nString WebServer::header(String name) {\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        if (_currentHeaders[i].key.equalsIgnoreCase(name))\n            return _currentHeaders[i].value;\n    }\n    return \"\";\n}\n\nvoid WebServer::collectHeaders(const char *headerKeys[], const size_t headerKeysCount) {\n    _headerKeysCount = headerKeysCount + 1;\n    if (_currentHeaders)\n        delete[] _currentHeaders;\n    _currentHeaders        = new RequestArgument[_headerKeysCount];\n    _currentHeaders[0].key = FPSTR(AUTHORIZATION_HEADER);\n    for (int i = 1; i &lt; _headerKeysCount; i++) {\n        _currentHeaders[i].key = headerKeys[i - 1];\n    }\n}\n\nString WebServer::header(int i) {\n    if (i &lt; _headerKeysCount)\n        return _currentHeaders[i].value;\n    return \"\";\n}\n\nString WebServer::headerName(int i) {\n    if (i &lt; _headerKeysCount)\n        return _currentHeaders[i].key;\n    return \"\";\n}\n\nint WebServer::headers() {\n    return _headerKeysCount;\n}\n\nbool WebServer::hasHeader(String name) {\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        if ((_currentHeaders[i].key.equalsIgnoreCase(name)) &amp;&amp; (_currentHeaders[i].value.length() &gt; 0))\n            return true;\n    }\n    return false;\n}\n\nString WebServer::hostHeader() {\n    return _hostHeader;\n}\n\nvoid WebServer::onFileUpload(THandlerFunction fn) {\n    _fileUploadHandler = fn;\n}\n\nvoid WebServer::onNotFound(THandlerFunction fn) {\n    _notFoundHandler = fn;\n}\n\nvoid WebServer::_handleRequest() {\n    bool handled = false;\n    if (!_currentHandler) {\n        log_e(\"request handler not found\");\n    } else {\n        handled = _currentHandler-&gt;handle(*this, _currentMethod, _currentUri);\n        if (!handled) {\n            log_e(\"request handler failed to handle request\");\n        }\n    }\n    if (!handled &amp;&amp; _notFoundHandler) {\n        _notFoundHandler();\n        handled = true;\n    }\n    if (!handled) {\n        using namespace mime;\n        send(404, String(FPSTR(mimeTable[html].mimeType)), String(F(\"Not found: \")) + _currentUri);\n        handled = true;\n    }\n    if (handled) {\n        _finalizeResponse();\n    }\n    _currentUri = \"\";\n}\n\nvoid WebServer::_finalizeResponse() {\n    if (_chunked) {\n        sendContent(\"\");\n    }\n}\n\nString WebServer::_responseCodeToString(int code) {\n    switch (code) {\n        case 100:\n            return F(\"Continue\");\n        case 101:\n            return F(\"Switching Protocols\");\n        case 200:\n            return F(\"OK\");\n        case 201:\n            return F(\"Created\");\n        case 202:\n            return F(\"Accepted\");\n        case 203:\n            return F(\"Non-Authoritative Information\");\n        case 204:\n            return F(\"No Content\");\n        case 205:\n            return F(\"Reset Content\");\n        case 206:\n            return F(\"Partial Content\");\n        case 300:\n            return F(\"Multiple Choices\");\n        case 301:\n            return F(\"Moved Permanently\");\n        case 302:\n            return F(\"Found\");\n        case 303:\n            return F(\"See Other\");\n        case 304:\n            return F(\"Not Modified\");\n        case 305:\n            return F(\"Use Proxy\");\n        case 307:\n            return F(\"Temporary Redirect\");\n        case 400:\n            return F(\"Bad Request\");\n        case 401:\n            return F(\"Unauthorized\");\n        case 402:\n            return F(\"Payment Required\");\n        case 403:\n            return F(\"Forbidden\");\n        case 404:\n            return F(\"Not Found\");\n        case 405:\n            return F(\"Method Not Allowed\");\n        case 406:\n            return F(\"Not Acceptable\");\n        case 407:\n            return F(\"Proxy Authentication Required\");\n        case 408:\n            return F(\"Request Time-out\");\n        case 409:\n            return F(\"Conflict\");\n        case 410:\n            return F(\"Gone\");\n        case 411:\n            return F(\"Length Required\");\n        case 412:\n            return F(\"Precondition Failed\");\n        case 413:\n            return F(\"Request Entity Too Large\");\n        case 414:\n            return F(\"Request-URI Too Large\");\n        case 415:\n            return F(\"Unsupported Media Type\");\n        case 416:\n            return F(\"Requested range not satisfiable\");\n        case 417:\n            return F(\"Expectation Failed\");\n        case 500:\n            return F(\"Internal Server Error\");\n        case 501:\n            return F(\"Not Implemented\");\n        case 502:\n            return F(\"Bad Gateway\");\n        case 503:\n            return F(\"Service Unavailable\");\n        case 504:\n            return F(\"Gateway Time-out\");\n        case 505:\n            return F(\"HTTP Version not supported\");\n        default:\n            return F(\"\");\n    }\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_web_server_8h/","title":"File WebServer.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; WebServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"HTTP_Method.h\"</code></li> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;WiFi.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"detail/RequestHandler.h\"</code></li> </ul>"},{"location":"ltapi/_web_server_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace fs"},{"location":"ltapi/_web_server_8h/#classes","title":"Classes","text":"Type Name     struct HTTPUpload    class WebServer"},{"location":"ltapi/_web_server_8h/#public-types","title":"Public Types","text":"Type Name     enum HTTPAuthMethod    enum HTTPClientStatus    enum HTTPUploadStatus"},{"location":"ltapi/_web_server_8h/#macros","title":"Macros","text":"Type Name     define CONTENT_LENGTH_NOT_SET  ((size_t)-2)   define CONTENT_LENGTH_UNKNOWN  ((size_t)-1)   define HTTP_DOWNLOAD_UNIT_SIZE  1436   define HTTP_MAX_CLOSE_WAIT  2000   define HTTP_MAX_DATA_WAIT  5000   define HTTP_MAX_POST_WAIT  5000   define HTTP_MAX_SEND_WAIT  5000   define HTTP_UPLOAD_BUFLEN  1436"},{"location":"ltapi/_web_server_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_web_server_8h/#enum-httpauthmethod","title":"enum HTTPAuthMethod","text":"<pre><code>enum HTTPAuthMethod {\n    BASIC_AUTH,\n    DIGEST_AUTH\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#enum-httpclientstatus","title":"enum HTTPClientStatus","text":"<pre><code>enum HTTPClientStatus {\n    HC_NONE,\n    HC_WAIT_READ,\n    HC_WAIT_CLOSE\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#enum-httpuploadstatus","title":"enum HTTPUploadStatus","text":"<pre><code>enum HTTPUploadStatus {\n    UPLOAD_FILE_START,\n    UPLOAD_FILE_WRITE,\n    UPLOAD_FILE_END,\n    UPLOAD_FILE_ABORTED\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_web_server_8h/#define-content_length_not_set","title":"define CONTENT_LENGTH_NOT_SET","text":"<pre><code>#define CONTENT_LENGTH_NOT_SET ((size_t)-2)\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-content_length_unknown","title":"define CONTENT_LENGTH_UNKNOWN","text":"<pre><code>#define CONTENT_LENGTH_UNKNOWN ((size_t)-1)\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_download_unit_size","title":"define HTTP_DOWNLOAD_UNIT_SIZE","text":"<pre><code>#define HTTP_DOWNLOAD_UNIT_SIZE 1436\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_close_wait","title":"define HTTP_MAX_CLOSE_WAIT","text":"<pre><code>#define HTTP_MAX_CLOSE_WAIT 2000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_data_wait","title":"define HTTP_MAX_DATA_WAIT","text":"<pre><code>#define HTTP_MAX_DATA_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_post_wait","title":"define HTTP_MAX_POST_WAIT","text":"<pre><code>#define HTTP_MAX_POST_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_send_wait","title":"define HTTP_MAX_SEND_WAIT","text":"<pre><code>#define HTTP_MAX_SEND_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_upload_buflen","title":"define HTTP_UPLOAD_BUFLEN","text":"<pre><code>#define HTTP_UPLOAD_BUFLEN 1436\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/WebServer.h</code></p>"},{"location":"ltapi/_web_server_8h_source/","title":"File WebServer.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; WebServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WebServer.h - Dead simple web-server.\n  Supports only one simultaneous client, knows how to handle GET and POST.\n\n  Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#pragma once\n\n#include \"HTTP_Method.h\"\n#include \"Uri.h\"\n#include &lt;WiFi.h&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n\nenum HTTPUploadStatus { UPLOAD_FILE_START, UPLOAD_FILE_WRITE, UPLOAD_FILE_END, UPLOAD_FILE_ABORTED };\n\nenum HTTPClientStatus { HC_NONE, HC_WAIT_READ, HC_WAIT_CLOSE };\n\nenum HTTPAuthMethod { BASIC_AUTH, DIGEST_AUTH };\n\n#define HTTP_DOWNLOAD_UNIT_SIZE 1436\n\n#ifndef HTTP_UPLOAD_BUFLEN\n#define HTTP_UPLOAD_BUFLEN 1436\n#endif\n\n#define HTTP_MAX_DATA_WAIT  5000 // ms to wait for the client to send the request\n#define HTTP_MAX_POST_WAIT  5000 // ms to wait for POST data to arrive\n#define HTTP_MAX_SEND_WAIT  5000 // ms to wait for data chunk to be ACKed\n#define HTTP_MAX_CLOSE_WAIT 2000 // ms to wait for the client to close the connection\n\n#define CONTENT_LENGTH_UNKNOWN ((size_t)-1)\n#define CONTENT_LENGTH_NOT_SET ((size_t)-2)\n\nclass WebServer;\n\ntypedef struct {\n    HTTPUploadStatus status;\n    String filename;\n    String name;\n    String type;\n    size_t totalSize;   // file size\n    size_t currentSize; // size of data currently in buf\n    uint8_t buf[HTTP_UPLOAD_BUFLEN];\n} HTTPUpload;\n\n#include \"detail/RequestHandler.h\"\n\nnamespace fs {\nclass FS;\n}\n\nclass WebServer {\n  public:\n    WebServer(IPAddress addr, int port = 80);\n    WebServer(int port = 80);\n    virtual ~WebServer();\n\n    virtual void begin();\n    virtual void begin(uint16_t port);\n    virtual void handleClient();\n\n    virtual void close();\n    void stop();\n\n    bool authenticate(const char *username, const char *password);\n    void requestAuthentication(\n        HTTPAuthMethod mode       = BASIC_AUTH,\n        const char *realm         = NULL,\n        const String &amp;authFailMsg = String(\"\")\n    );\n\n    typedef std::function&lt;void(void)&gt; THandlerFunction;\n    void on(const Uri &amp;uri, THandlerFunction fn);\n    void on(const Uri &amp;uri, HTTPMethod method, THandlerFunction fn);\n    void on(const Uri &amp;uri, HTTPMethod method, THandlerFunction fn, THandlerFunction ufn); // ufn handles file uploads\n    void addHandler(RequestHandler *handler);\n    void serveStatic(const char *uri, fs::FS &amp;fs, const char *path, const char *cache_header = NULL);\n    void onNotFound(THandlerFunction fn);    // called when handler is not assigned\n    void onFileUpload(THandlerFunction ufn); // handle file uploads\n\n    String uri() {\n        return _currentUri;\n    }\n\n    HTTPMethod method() {\n        return _currentMethod;\n    }\n\n    virtual WiFiClient client() {\n        return _currentClient;\n    }\n\n    HTTPUpload &amp;upload() {\n        return *_currentUpload;\n    }\n\n    String pathArg(unsigned int i);                                              // get request path argument by number\n    String arg(String name);                                                     // get request argument value by name\n    String arg(int i);                                                           // get request argument value by number\n    String argName(int i);                                                       // get request argument name by number\n    int args();                                                                  // get arguments count\n    bool hasArg(String name);                                                    // check if argument exists\n    void collectHeaders(const char *headerKeys[], const size_t headerKeysCount); // set the request headers to collect\n    String header(String name);                                                  // get request header value by name\n    String header(int i);                                                        // get request header value by number\n    String headerName(int i);                                                    // get request header name by number\n    int headers();                                                               // get header count\n    bool hasHeader(String name);                                                 // check if header exists\n\n    String hostHeader(); // get request host header if available or empty String if not\n\n    // send response to the client\n    // code - HTTP response code, can be 200 or 404\n    // content_type - HTTP content type, like \"text/plain\" or \"image/png\"\n    // content - actual content body\n    void send(int code, const char *content_type = NULL, const String &amp;content = String(\"\"));\n    void send(int code, char *content_type, const String &amp;content);\n    void send(int code, const String &amp;content_type, const String &amp;content);\n    void send_P(int code, PGM_P content_type, PGM_P content);\n    void send_P(int code, PGM_P content_type, PGM_P content, size_t contentLength);\n\n    void enableDelay(boolean value);\n    void enableCORS(boolean value = true);\n    void enableCrossOrigin(boolean value = true);\n\n    void setContentLength(const size_t contentLength);\n    void sendHeader(const String &amp;name, const String &amp;value, bool first = false);\n    void sendContent(const String &amp;content);\n    void sendContent(const char *content, size_t contentLength);\n    void sendContent_P(PGM_P content);\n    void sendContent_P(PGM_P content, size_t size);\n\n    static String urlDecode(const String &amp;text);\n\n    template &lt;typename T&gt;\n    size_t streamFile(T &amp;file, const String &amp;contentType) {\n        _streamFileCore(file.size(), file.name(), contentType);\n        return _currentClient.write(file);\n    }\n\n  protected:\n    virtual size_t _currentClientWrite(const char *b, size_t l) {\n        return _currentClient.write(b, l);\n    }\n\n    virtual size_t _currentClientWrite_P(PGM_P b, size_t l) {\n        return _currentClient.write_P(b, l);\n    }\n\n    void _addRequestHandler(RequestHandler *handler);\n    void _handleRequest();\n    void _finalizeResponse();\n    bool _parseRequest(WiFiClient &amp;client);\n    void _parseArguments(String data);\n    static String _responseCodeToString(int code);\n    bool _parseForm(WiFiClient &amp;client, String boundary, uint32_t len);\n    bool _parseFormUploadAborted();\n    void _uploadWriteByte(uint8_t b);\n    int _uploadReadByte(WiFiClient &amp;client);\n    void _prepareHeader(String &amp;response, int code, const char *content_type, size_t contentLength);\n    bool _collectHeader(const char *headerName, const char *headerValue);\n\n    void _streamFileCore(const size_t fileSize, const String &amp;fileName, const String &amp;contentType);\n\n    String _getRandomHexString();\n    // for extracting Auth parameters\n    String _extractParam(String &amp;authReq, const String &amp;param, const char delimit = '\"');\n\n    struct RequestArgument {\n        String key;\n        String value;\n    };\n\n    boolean _corsEnabled;\n    WiFiServer _server;\n\n    WiFiClient _currentClient;\n    HTTPMethod _currentMethod;\n    String _currentUri;\n    uint8_t _currentVersion;\n    HTTPClientStatus _currentStatus;\n    unsigned long _statusChange;\n    boolean _nullDelay;\n\n    RequestHandler *_currentHandler;\n    RequestHandler *_firstHandler;\n    RequestHandler *_lastHandler;\n    THandlerFunction _notFoundHandler;\n    THandlerFunction _fileUploadHandler;\n\n    int _currentArgCount;\n    RequestArgument *_currentArgs;\n    int _postArgsLen;\n    RequestArgument *_postArgs;\n\n    std::unique_ptr&lt;HTTPUpload&gt; _currentUpload;\n\n    int _headerKeysCount;\n    RequestArgument *_currentHeaders;\n    size_t _contentLength;\n    String _responseHeaders;\n\n    String _hostHeader;\n    bool _chunked;\n\n    String _snonce; // Store noance and opaque for future comparison\n    String _sopaque;\n    String _srealm; // Store the Auth realm between Calls\n};\n</code></pre>"},{"location":"ltapi/dir_84f0c24223fe15b4f2fbb2a476e54856/","title":"Dir cores/common/arduino/libraries/ext/WebServer/detail","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail</p>"},{"location":"ltapi/dir_84f0c24223fe15b4f2fbb2a476e54856/#files","title":"Files","text":"Type Name     file RequestHandler.h    file RequestHandlersImpl.h    file mimetable.cpp    file mimetable.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/</code></p>"},{"location":"ltapi/_request_handler_8h/","title":"File RequestHandler.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; RequestHandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_request_handler_8h/#classes","title":"Classes","text":"Type Name     class RequestHandler      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/RequestHandler.h</code></p>"},{"location":"ltapi/_request_handler_8h_source/","title":"File RequestHandler.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; RequestHandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;assert.h&gt;\n#include &lt;vector&gt;\n\nclass RequestHandler {\n  public:\n    virtual ~RequestHandler() {}\n\n    virtual bool canHandle(HTTPMethod method, String uri) {\n        (void)method;\n        (void)uri;\n        return false;\n    }\n\n    virtual bool canUpload(String uri) {\n        (void)uri;\n        return false;\n    }\n\n    virtual bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) {\n        (void)server;\n        (void)requestMethod;\n        (void)requestUri;\n        return false;\n    }\n\n    virtual void upload(WebServer &amp;server, String requestUri, HTTPUpload &amp;upload) {\n        (void)server;\n        (void)requestUri;\n        (void)upload;\n    }\n\n    RequestHandler *next() {\n        return _next;\n    }\n\n    void next(RequestHandler *r) {\n        _next = r;\n    }\n\n  private:\n    RequestHandler *_next = nullptr;\n\n  protected:\n    std::vector&lt;String&gt; pathArgs;\n\n  public:\n    const String &amp;pathArg(unsigned int i) {\n        assert(i &lt; pathArgs.size());\n        return pathArgs[i];\n    }\n};\n</code></pre>"},{"location":"ltapi/_request_handlers_impl_8h/","title":"File RequestHandlersImpl.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; RequestHandlersImpl.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RequestHandler.h\"</code></li> <li><code>#include \"Uri.h\"</code></li> <li><code>#include \"WString.h\"</code></li> <li><code>#include \"mimetable.h\"</code></li> </ul>"},{"location":"ltapi/_request_handlers_impl_8h/#classes","title":"Classes","text":"Type Name     class FunctionRequestHandler    class StaticRequestHandler      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/_request_handlers_impl_8h_source/","title":"File RequestHandlersImpl.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; RequestHandlersImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"RequestHandler.h\"\n#include \"Uri.h\"\n#include \"WString.h\"\n#include \"mimetable.h\"\n\nusing namespace mime;\n\nclass FunctionRequestHandler : public RequestHandler {\n  public:\n    FunctionRequestHandler(\n        WebServer::THandlerFunction fn,\n        WebServer::THandlerFunction ufn,\n        const Uri &amp;uri,\n        HTTPMethod method\n    )\n        : _fn(fn), _ufn(ufn), _uri(uri.clone()), _method(method) {\n        _uri-&gt;initPathArgs(pathArgs);\n    }\n\n    ~FunctionRequestHandler() {\n        delete _uri;\n    }\n\n    bool canHandle(HTTPMethod requestMethod, String requestUri) override {\n        if (_method != HTTP_ANY &amp;&amp; _method != requestMethod)\n            return false;\n\n        return _uri-&gt;canHandle(requestUri, pathArgs);\n    }\n\n    bool canUpload(String requestUri) override {\n        if (!_ufn || !canHandle(HTTP_POST, requestUri))\n            return false;\n\n        return true;\n    }\n\n    bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) override {\n        (void)server;\n        if (!canHandle(requestMethod, requestUri))\n            return false;\n\n        _fn();\n        return true;\n    }\n\n    void upload(WebServer &amp;server, String requestUri, HTTPUpload &amp;upload) override {\n        (void)server;\n        (void)upload;\n        if (canUpload(requestUri))\n            _ufn();\n    }\n\n  protected:\n    WebServer::THandlerFunction _fn;\n    WebServer::THandlerFunction _ufn;\n    Uri *_uri;\n    HTTPMethod _method;\n};\n\nclass StaticRequestHandler : public RequestHandler {\n  public:\n    StaticRequestHandler(FS &amp;fs, const char *path, const char *uri, const char *cache_header)\n        : _fs(fs), _uri(uri), _path(path), _cache_header(cache_header) {\n        File f  = fs.open(path);\n        _isFile = (f &amp;&amp; (!f.isDirectory()));\n        log_v(\n            \"StaticRequestHandler: path=%s uri=%s isFile=%d, cache_header=%s\\r\\n\",\n            path,\n            uri,\n            _isFile,\n            cache_header ? cache_header : \"\"\n        ); // issue 5506 - cache_header can be nullptr\n        _baseUriLength = _uri.length();\n    }\n\n    bool canHandle(HTTPMethod requestMethod, String requestUri) override {\n        if (requestMethod != HTTP_GET)\n            return false;\n\n        if ((_isFile &amp;&amp; requestUri != _uri) || !requestUri.startsWith(_uri))\n            return false;\n\n        return true;\n    }\n\n    bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) override {\n        if (!canHandle(requestMethod, requestUri))\n            return false;\n\n        log_v(\"StaticRequestHandler::handle: request=%s _uri=%s\\r\\n\", requestUri.c_str(), _uri.c_str());\n\n        String path(_path);\n\n        if (!_isFile) {\n            // Base URI doesn't point to a file.\n            // If a directory is requested, look for index file.\n            if (requestUri.endsWith(\"/\"))\n                requestUri += \"index.htm\";\n\n            // Append whatever follows this URI in request to get the file path.\n            path += requestUri.substring(_baseUriLength);\n        }\n        log_v(\"StaticRequestHandler::handle: path=%s, isFile=%d\\r\\n\", path.c_str(), _isFile);\n\n        String contentType = getContentType(path);\n\n        // look for gz file, only if the original specified path is not a gz.  So part only works to send gzip via\n        // content encoding when a non compressed is asked for if you point the the path to gzip you will serve the gzip\n        // as content type \"application/x-gzip\", not text or javascript etc...\n        if (!path.endsWith(FPSTR(mimeTable[gz].endsWith)) &amp;&amp; !_fs.exists(path)) {\n            String pathWithGz = path + FPSTR(mimeTable[gz].endsWith);\n            if (_fs.exists(pathWithGz))\n                path += FPSTR(mimeTable[gz].endsWith);\n        }\n\n        File f = _fs.open(path, \"r\");\n        if (!f || !f.available())\n            return false;\n\n        if (_cache_header.length() != 0)\n            server.sendHeader(\"Cache-Control\", _cache_header);\n\n        server.streamFile(f, contentType);\n        return true;\n    }\n\n    static String getContentType(const String &amp;path) {\n        char buff[sizeof(mimeTable[0].mimeType)];\n        // Check all entries but last one for match, return if found\n        for (size_t i = 0; i &lt; sizeof(mimeTable) / sizeof(mimeTable[0]) - 1; i++) {\n            strcpy_P(buff, mimeTable[i].endsWith);\n            if (path.endsWith(buff)) {\n                strcpy_P(buff, mimeTable[i].mimeType);\n                return String(buff);\n            }\n        }\n        // Fall-through and just return default type\n        strcpy_P(buff, mimeTable[sizeof(mimeTable) / sizeof(mimeTable[0]) - 1].mimeType);\n        return String(buff);\n    }\n\n  protected:\n    FS _fs;\n    String _uri;\n    String _path;\n    String _cache_header;\n    bool _isFile;\n    size_t _baseUriLength;\n};\n</code></pre>"},{"location":"ltapi/mimetable_8cpp/","title":"File mimetable.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; mimetable.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mimetable.h\"</code></li> <li><code>#include \"pgmspace.h\"</code></li> </ul>"},{"location":"ltapi/mimetable_8cpp/#namespaces","title":"Namespaces","text":"Type Name     namespace mime      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/mimetable.cpp</code></p>"},{"location":"ltapi/mimetable_8cpp_source/","title":"File mimetable.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; mimetable.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"mimetable.h\"\n#include \"pgmspace.h\"\n\nnamespace mime {\n\n// Table of extension-&gt;MIME strings stored in PROGMEM, needs to be global due to GCC section typing rules\nconst Entry mimeTable[maxType] = {\n    {\".html\",     \"text/html\"                    },\n    {\".htm\",         \"text/html\"                    },\n    {\".css\",         \"text/css\"                    },\n    {\".txt\",         \"text/plain\"                    },\n    {\".js\",     \"application/javascript\"        },\n    {\".json\",     \"application/json\"                },\n    {\".png\",         \"image/png\"                    },\n    {\".gif\",         \"image/gif\"                    },\n    {\".jpg\",         \"image/jpeg\"                    },\n    {\".ico\",         \"image/x-icon\"                },\n    {\".svg\",         \"image/svg+xml\"                },\n    {\".ttf\",         \"application/x-font-ttf\"        },\n    {\".otf\",         \"application/x-font-opentype\"  },\n    {\".woff\",     \"application/font-woff\"        },\n    {\".woff2\",     \"application/font-woff2\"    },\n    {\".eot\",         \"application/vnd.ms-fontobject\"},\n    {\".sfnt\",     \"application/font-sfnt\"        },\n    {\".xml\",         \"text/xml\"                    },\n    {\".pdf\",         \"application/pdf\"            },\n    {\".zip\",         \"application/zip\"            },\n    {\".gz\",     \"application/x-gzip\"            },\n    {\".appcache\", \"text/cache-manifest\"        },\n    {\"\",          \"application/octet-stream\"       }\n};\n\n} // namespace mime\n</code></pre>"},{"location":"ltapi/mimetable_8h/","title":"File mimetable.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; mimetable.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/mimetable_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace mime"},{"location":"ltapi/mimetable_8h/#classes","title":"Classes","text":"Type Name     struct Entry      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/detail/mimetable.h</code></p>"},{"location":"ltapi/mimetable_8h_source/","title":"File mimetable.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; detail &gt; mimetable.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nnamespace mime {\n\nenum type {\n    html,\n    htm,\n    css,\n    txt,\n    js,\n    json,\n    png,\n    gif,\n    jpg,\n    ico,\n    svg,\n    ttf,\n    otf,\n    woff,\n    woff2,\n    eot,\n    sfnt,\n    xml,\n    pdf,\n    zip,\n    gz,\n    appcache,\n    none,\n    maxType\n};\n\nstruct Entry {\n    const char endsWith[16];\n    const char mimeType[32];\n};\n\nextern const Entry mimeTable[maxType];\n} // namespace mime\n</code></pre>"},{"location":"ltapi/dir_d96db7fd7f8e0e902a4f4b8f7da27505/","title":"Dir cores/common/arduino/libraries/ext/WebServer/uri","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri</p>"},{"location":"ltapi/dir_d96db7fd7f8e0e902a4f4b8f7da27505/#files","title":"Files","text":"Type Name     file UriBraces.h    file UriGlob.h    file UriRegex.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/</code></p>"},{"location":"ltapi/_uri_braces_8h/","title":"File UriBraces.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriBraces.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> </ul>"},{"location":"ltapi/_uri_braces_8h/#classes","title":"Classes","text":"Type Name     class UriBraces      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriBraces.h</code></p>"},{"location":"ltapi/_uri_braces_8h_source/","title":"File UriBraces.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriBraces.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n\nclass UriBraces : public Uri {\n\n  public:\n    explicit UriBraces(const char *uri) : Uri(uri) {};\n    explicit UriBraces(const String &amp;uri) : Uri(uri) {};\n\n    Uri *clone() const override final {\n        return new UriBraces(_uri);\n    };\n\n    void initPathArgs(std::vector&lt;String&gt; &amp;pathArgs) override final {\n        int numParams = 0, start = 0;\n        do {\n            start = _uri.indexOf(\"{}\", start);\n            if (start &gt; 0) {\n                numParams++;\n                start += 2;\n            }\n        } while (start &gt; 0);\n        pathArgs.resize(numParams);\n    }\n\n    bool canHandle(const String &amp;requestUri, std::vector&lt;String&gt; &amp;pathArgs) override final {\n        if (Uri::canHandle(requestUri, pathArgs))\n            return true;\n\n        size_t uriLength             = _uri.length();\n        unsigned int pathArgIndex    = 0;\n        unsigned int requestUriIndex = 0;\n        for (unsigned int i = 0; i &lt; uriLength; i++, requestUriIndex++) {\n            char uriChar        = _uri[i];\n            char requestUriChar = requestUri[requestUriIndex];\n\n            if (uriChar == requestUriChar)\n                continue;\n            if (uriChar != '{')\n                return false;\n\n            i += 2; // index of char after '}'\n            if (i &gt;= uriLength) {\n                // there is no char after '}'\n                pathArgs[pathArgIndex] = requestUri.substring(requestUriIndex);\n                return pathArgs[pathArgIndex].indexOf(\"/\") == -1; // path argument may not contain a '/'\n            } else {\n                char charEnd = _uri[i];\n                int uriIndex = requestUri.indexOf(charEnd, requestUriIndex);\n                if (uriIndex &lt; 0)\n                    return false;\n                pathArgs[pathArgIndex] = requestUri.substring(requestUriIndex, uriIndex);\n                requestUriIndex        = (unsigned int)uriIndex;\n            }\n            pathArgIndex++;\n        }\n\n        return requestUriIndex &gt;= requestUri.length();\n    }\n};\n</code></pre>"},{"location":"ltapi/_uri_glob_8h/","title":"File UriGlob.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriGlob.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;fnmatch.h&gt;</code></li> </ul>"},{"location":"ltapi/_uri_glob_8h/#classes","title":"Classes","text":"Type Name     class UriGlob      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriGlob.h</code></p>"},{"location":"ltapi/_uri_glob_8h_source/","title":"File UriGlob.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriGlob.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n#include &lt;fnmatch.h&gt;\n\nclass UriGlob : public Uri {\n\n  public:\n    explicit UriGlob(const char *uri) : Uri(uri) {};\n    explicit UriGlob(const String &amp;uri) : Uri(uri) {};\n\n    Uri *clone() const override final {\n        return new UriGlob(_uri);\n    };\n\n    bool canHandle(const String &amp;requestUri, __attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) override final {\n        return fnmatch(_uri.c_str(), requestUri.c_str(), 0) == 0;\n    }\n};\n</code></pre>"},{"location":"ltapi/_uri_regex_8h/","title":"File UriRegex.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriRegex.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"ltapi/_uri_regex_8h/#classes","title":"Classes","text":"Type Name     class UriRegex      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WebServer/uri/UriRegex.h</code></p>"},{"location":"ltapi/_uri_regex_8h_source/","title":"File UriRegex.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WebServer &gt; uri &gt; UriRegex.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n#include &lt;regex&gt;\n\nclass UriRegex : public Uri {\n\n  public:\n    explicit UriRegex(const char *uri) : Uri(uri) {};\n    explicit UriRegex(const String &amp;uri) : Uri(uri) {};\n\n    Uri *clone() const override final {\n        return new UriRegex(_uri);\n    };\n\n    void initPathArgs(std::vector&lt;String&gt; &amp;pathArgs) override final {\n        std::regex rgx((_uri + \"|\").c_str());\n        std::smatch matches;\n        std::string s{\"\"};\n        std::regex_search(s, matches, rgx);\n        pathArgs.resize(matches.size() - 1);\n    }\n\n    bool canHandle(const String &amp;requestUri, std::vector&lt;String&gt; &amp;pathArgs) override final {\n        if (Uri::canHandle(requestUri, pathArgs))\n            return true;\n\n        unsigned int pathArgIndex = 0;\n        std::regex rgx(_uri.c_str());\n        std::smatch matches;\n        std::string s(requestUri.c_str());\n        if (std::regex_search(s, matches, rgx)) {\n            for (size_t i = 1; i &lt; matches.size(); ++i) { // skip first\n                pathArgs[pathArgIndex] = String(matches[i].str().c_str());\n                pathArgIndex++;\n            }\n            return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"ltapi/dir_466525e97edd1426939c6f6f1c4cc401/","title":"Dir cores/common/arduino/libraries/ext/WiFiMulti","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WiFiMulti</p>"},{"location":"ltapi/dir_466525e97edd1426939c6f6f1c4cc401/#files","title":"Files","text":"Type Name     file WiFiMulti.cpp    file WiFiMulti.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WiFiMulti/</code></p>"},{"location":"ltapi/_wi_fi_multi_8cpp/","title":"File WiFiMulti.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WiFiMulti &gt; WiFiMulti.cpp</p> <p>Go to the source code of this file.</p> <p>More...</p>"},{"location":"ltapi/_wi_fi_multi_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>16.05.2015 </p> <p>Author:</p> <p>Markus Sattler</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the esp8266 core for Arduino environment.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WiFiMulti/WiFiMulti.cpp</code></p>"},{"location":"ltapi/_wi_fi_multi_8cpp_source/","title":"File WiFiMulti.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WiFiMulti &gt; WiFiMulti.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_ARD_HAS_WIFI\n\n#include \"WiFiMulti.h\"\n#include &lt;Arduino.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;string.h&gt;\n\nWiFiMulti::WiFiMulti() {}\n\nWiFiMulti::~WiFiMulti() {\n    for (uint32_t i = 0; i &lt; APlist.size(); i++) {\n        WifiAPlist_t entry = APlist[i];\n        if (entry.ssid) {\n            free(entry.ssid);\n        }\n        if (entry.passphrase) {\n            free(entry.passphrase);\n        }\n    }\n    APlist.clear();\n}\n\nbool WiFiMulti::addAP(const char *ssid, const char *passphrase) {\n    WifiAPlist_t newAP;\n\n    if (!ssid || *ssid == 0x00 || strlen(ssid) &gt; 31) {\n        // fail SSID too long or missing!\n        LT_EM(WIFI, \"SSID missing or too long\");\n        return false;\n    }\n\n    if (passphrase &amp;&amp; strlen(passphrase) &gt; 64) {\n        // fail passphrase too long!\n        LT_EM(WIFI, \"Passphrase too long\");\n        return false;\n    }\n\n    newAP.ssid = strdup(ssid);\n\n    if (!newAP.ssid) {\n        LT_EM(WIFI, \"Fail newAP.ssid == 0\");\n        return false;\n    }\n\n    if (passphrase &amp;&amp; *passphrase != 0x00) {\n        newAP.passphrase = strdup(passphrase);\n        if (!newAP.passphrase) {\n            LT_EM(WIFI, \"Fail newAP.passphrase == 0\");\n            free(newAP.ssid);\n            return false;\n        }\n    } else {\n        newAP.passphrase = NULL;\n    }\n\n    APlist.push_back(newAP);\n    LT_VM(WIFI, \"Add SSID: %s\", newAP.ssid);\n    return true;\n}\n\nuint8_t WiFiMulti::run(uint32_t connectTimeout) {\n    int8_t scanResult;\n    uint8_t status = WiFi.status();\n    if (status == WL_CONNECTED) {\n        for (uint32_t x = 0; x &lt; APlist.size(); x++) {\n            if (WiFi.SSID() == APlist[x].ssid) {\n                return status;\n            }\n        }\n        WiFi.disconnect(false);\n        delay(10);\n        status = WiFi.status();\n    }\n\n    scanResult = WiFi.scanNetworks();\n    if (scanResult == WIFI_SCAN_RUNNING) {\n        // scan is running\n        return WL_NO_SSID_AVAIL;\n    } else if (scanResult &gt;= 0) {\n        // scan done analyze\n        WifiAPlist_t bestNetwork{NULL, NULL};\n        int bestNetworkDb = INT_MIN;\n        uint8_t bestBSSID[6];\n        int32_t bestChannel = 0;\n\n        LT_IM(WIFI, \"Scan finished\");\n\n        if (scanResult == 0) {\n            LT_IM(WIFI, \"No networks found\");\n        } else {\n            LT_IM(WIFI, \"%d networks found\", scanResult);\n            for (int8_t i = 0; i &lt; scanResult; ++i) {\n\n                String ssid_scan;\n                int32_t rssi_scan;\n                WiFiAuthMode sec_scan;\n                uint8_t *BSSID_scan;\n                int32_t chan_scan;\n\n                WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);\n\n                bool known = false;\n                for (uint32_t x = APlist.size(); x &gt; 0; x--) {\n                    WifiAPlist_t entry = APlist[x - 1];\n\n                    if (ssid_scan == entry.ssid) { // SSID match\n                        known = true;\n                        if (rssi_scan &gt; bestNetworkDb) { // best network\n                            if (sec_scan == WIFI_AUTH_OPEN ||\n                                entry.passphrase) { // check for passphrase if not open wlan\n                                bestNetworkDb = rssi_scan;\n                                bestChannel   = chan_scan;\n                                memcpy((void *)&amp;bestNetwork, (void *)&amp;entry, sizeof(bestNetwork));\n                                memcpy((void *)&amp;bestBSSID, (void *)BSSID_scan, sizeof(bestBSSID));\n                            }\n                        }\n                        break;\n                    }\n                }\n\n                if (known) {\n                    LT_DM(\n                        WIFI,\n                        \" ---&gt;   %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\",\n                        i,\n                        chan_scan,\n                        BSSID_scan[0],\n                        BSSID_scan[1],\n                        BSSID_scan[2],\n                        BSSID_scan[3],\n                        BSSID_scan[4],\n                        BSSID_scan[5],\n                        ssid_scan.c_str(),\n                        rssi_scan,\n                        (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*'\n                    );\n                } else {\n                    LT_DM(\n                        WIFI,\n                        \"       %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\",\n                        i,\n                        chan_scan,\n                        BSSID_scan[0],\n                        BSSID_scan[1],\n                        BSSID_scan[2],\n                        BSSID_scan[3],\n                        BSSID_scan[4],\n                        BSSID_scan[5],\n                        ssid_scan.c_str(),\n                        rssi_scan,\n                        (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*'\n                    );\n                }\n            }\n        }\n\n        // clean up ram\n        WiFi.scanDelete();\n\n        if (bestNetwork.ssid) {\n            LT_IM(\n                WIFI,\n                \"Connecting to BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channel: %d (%d)\",\n                bestBSSID[0],\n                bestBSSID[1],\n                bestBSSID[2],\n                bestBSSID[3],\n                bestBSSID[4],\n                bestBSSID[5],\n                bestNetwork.ssid,\n                bestChannel,\n                bestNetworkDb\n            );\n\n            WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);\n            status = WiFi.status();\n\n            auto startTime = millis();\n            // wait for connection, fail, or timeout\n            while (status != WL_CONNECTED &amp;&amp; status != WL_NO_SSID_AVAIL &amp;&amp; status != WL_CONNECT_FAILED &amp;&amp;\n                   (millis() - startTime) &lt;= connectTimeout) {\n                delay(10);\n                status = WiFi.status();\n            }\n\n            IPAddress ip;\n            switch (status) {\n                case WL_CONNECTED:\n                    LT_IM(WIFI, \"Connecting done\");\n                    LT_DM(WIFI, \"SSID: %s\", WiFi.SSID().c_str());\n                    // TODO fix this after implementing IP format for printf()\n                    ip = WiFi.localIP();\n                    LT_DM(WIFI, \"IP: %u.%u.%u.%u\", ip[0], ip[1], ip[2], ip[3]);\n                    LT_DM(WIFI, \"MAC: %s\", WiFi.BSSIDstr().c_str());\n                    LT_DM(WIFI, \"Channel: %d\", WiFi.channel());\n                    break;\n                case WL_NO_SSID_AVAIL:\n                    LT_EM(WIFI, \"Connecting failed; AP not found\");\n                    break;\n                case WL_CONNECT_FAILED:\n                    LT_EM(WIFI, \"Connecting failed\");\n                    break;\n                default:\n                    LT_EM(WIFI, \"Connecting failed (%d)\", status);\n                    break;\n            }\n        } else {\n            LT_EM(WIFI, \"No matching network found!\");\n        }\n    } else {\n        // start scan\n        LT_VM(WIFI, \"Delete old wifi config...\");\n        WiFi.disconnect();\n\n        LT_DM(WIFI, \"Start scan\");\n        // scan wifi async mode\n        WiFi.scanNetworks(true);\n    }\n\n    return status;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_wi_fi_multi_8h/","title":"File WiFiMulti.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; WiFiMulti &gt; WiFiMulti.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_multi_8h/#classes","title":"Classes","text":"Type Name     class WiFiMulti    struct WifiAPlist_t      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/_wi_fi_multi_8h_source/","title":"File WiFiMulti.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; WiFiMulti &gt; WiFiMulti.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"WiFi.h\"\n#include &lt;vector&gt;\n\ntypedef struct {\n    char *ssid;\n    char *passphrase;\n} WifiAPlist_t;\n\nclass WiFiMulti {\n  public:\n    WiFiMulti();\n    ~WiFiMulti();\n\n    bool addAP(const char *ssid, const char *passphrase = NULL);\n\n    uint8_t run(uint32_t connectTimeout = 10000);\n\n  private:\n    std::vector&lt;WifiAPlist_t&gt; APlist;\n};\n</code></pre>"},{"location":"ltapi/dir_e7aea143128db3d890560fea5ce624b6/","title":"Dir cores/common/arduino/libraries/ext/base64","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64</p>"},{"location":"ltapi/dir_e7aea143128db3d890560fea5ce624b6/#files","title":"Files","text":"Type Name     file base64.cpp    file base64.h"},{"location":"ltapi/dir_e7aea143128db3d890560fea5ce624b6/#directories","title":"Directories","text":"Type Name     dir libb64      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/</code></p>"},{"location":"ltapi/base64_8cpp/","title":"File base64.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; base64.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"libb64/cdecode.h\"</code></li> <li><code>#include \"libb64/cencode.h\"</code></li> <li><code>#include \"base64.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/base64.cpp</code></p>"},{"location":"ltapi/base64_8cpp_source/","title":"File base64.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; base64.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Arduino.h\"\nextern \"C\" {\n#include \"libb64/cdecode.h\"\n#include \"libb64/cencode.h\"\n}\n#include \"base64.h\"\n\nString base64::encode(const uint8_t * data, size_t length)\n{\n    size_t size = base64_encode_expected_len(length) + 1;\n    char * buffer = (char *) malloc(size);\n    if(buffer) {\n        base64_encodestate _state;\n        base64_init_encodestate(&amp;_state);\n        int len = base64_encode_block((const char *) &amp;data[0], length, &amp;buffer[0], &amp;_state);\n        len = base64_encode_blockend((buffer + len), &amp;_state);\n\n        String base64 = String(buffer);\n        free(buffer);\n        return base64;\n    }\n    return String(\"-FAIL-\");\n}\n\nString base64::encode(const String&amp; text)\n{\n    return base64::encode((uint8_t *) text.c_str(), text.length());\n}\n</code></pre>"},{"location":"ltapi/base64_8h/","title":"File base64.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; base64.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/base64_8h/#classes","title":"Classes","text":"Type Name     class base64      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/base64.h</code></p>"},{"location":"ltapi/base64_8h_source/","title":"File base64.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; base64.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n\nclass base64 {\n  public:\n    static String encode(const uint8_t *data, size_t length);\n    static String encode(const String &amp;text);\n};\n</code></pre>"},{"location":"ltapi/dir_8526abab122814721f0f43c2acad511e/","title":"Dir cores/common/arduino/libraries/ext/base64/libb64","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64</p>"},{"location":"ltapi/dir_8526abab122814721f0f43c2acad511e/#files","title":"Files","text":"Type Name     file cdecode.c    file cdecode.h    file cencode.c    file cencode.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/</code></p>"},{"location":"ltapi/cdecode_8c/","title":"File cdecode.c","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cdecode.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cdecode.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/cdecode_8c/#public-functions","title":"Public Functions","text":"Type Name     int base64_decode_block (const char * code_in, const int length_in, char * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars (const char * code_in, const int length_in, char * plaintext_out)    int base64_decode_value (char value_in)    void base64_init_decodestate (base64_decodestate * state_in)"},{"location":"ltapi/cdecode_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name     int base64_decode_block_signed (const int8_t * code_in, const int length_in, int8_t * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars_signed (const int8_t * code_in, const int length_in, int8_t * plaintext_out)    int base64_decode_value_signed (int8_t value_in)"},{"location":"ltapi/cdecode_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cdecode_8c/#function-base64_decode_block","title":"function base64_decode_block","text":"<pre><code>int base64_decode_block (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_chars","title":"function base64_decode_chars","text":"<pre><code>int base64_decode_chars (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_value","title":"function base64_decode_value","text":"<pre><code>int base64_decode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_init_decodestate","title":"function base64_init_decodestate","text":"<pre><code>void base64_init_decodestate (\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/cdecode_8c/#function-base64_decode_block_signed","title":"function base64_decode_block_signed","text":"<pre><code>static int base64_decode_block_signed (\n    const int8_t * code_in,\n    const int length_in,\n    int8_t * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_chars_signed","title":"function base64_decode_chars_signed","text":"<pre><code>static int base64_decode_chars_signed (\n    const int8_t * code_in,\n    const int length_in,\n    int8_t * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_value_signed","title":"function base64_decode_value_signed","text":"<pre><code>static int base64_decode_value_signed (\n    int8_t value_in\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cdecode.c</code></p>"},{"location":"ltapi/cdecode_8c_source/","title":"File cdecode.c","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cdecode.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncdecoder.c - c source to a base64 decoding algorithm implementation\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#include \"cdecode.h\"\n#include &lt;stdint.h&gt;\n\nstatic int base64_decode_value_signed(int8_t value_in){\n  static const int8_t decoding[] = {62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const int8_t decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in &lt; 0 || value_in &gt;= decoding_size) return -1;\n  return decoding[(int)value_in];\n}\n\nvoid base64_init_decodestate(base64_decodestate* state_in){\n  state_in-&gt;step = step_a;\n  state_in-&gt;plainchar = 0;\n}\n\nstatic int base64_decode_block_signed(const int8_t* code_in, const int length_in, int8_t* plaintext_out, base64_decodestate* state_in){\n  const int8_t* codechar = code_in;\n  int8_t* plainchar = plaintext_out;\n  int8_t fragment;\n\n  *plainchar = state_in-&gt;plainchar;\n\n  switch (state_in-&gt;step){\n    while (1){\n      case step_a:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_a;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar    = (fragment &amp; 0x03f) &lt;&lt; 2;\n      case step_b:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_b;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++ |= (fragment &amp; 0x030) &gt;&gt; 4;\n        *plainchar    = (fragment &amp; 0x00f) &lt;&lt; 4;\n      case step_c:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_c;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++ |= (fragment &amp; 0x03c) &gt;&gt; 2;\n        *plainchar    = (fragment &amp; 0x003) &lt;&lt; 6;\n      case step_d:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_d;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++   |= (fragment &amp; 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}\n\nstatic int base64_decode_chars_signed(const int8_t* code_in, const int length_in, int8_t* plaintext_out){\n  base64_decodestate _state;\n  base64_init_decodestate(&amp;_state);\n  int len = base64_decode_block_signed(code_in, length_in, plaintext_out, &amp;_state);\n  if(len &gt; 0) plaintext_out[len] = 0;\n  return len;\n}\n\nint base64_decode_value(char value_in){\n  return base64_decode_value_signed(*((int8_t *) &amp;value_in));\n}\n\nint base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in){\n  return base64_decode_block_signed((int8_t *) code_in, length_in, (int8_t *) plaintext_out, state_in);\n}\n\nint base64_decode_chars(const char* code_in, const int length_in, char* plaintext_out){\n  return base64_decode_chars_signed((int8_t *) code_in, length_in, (int8_t *) plaintext_out);\n}\n</code></pre>"},{"location":"ltapi/cdecode_8h/","title":"File cdecode.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cdecode.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/cdecode_8h/#classes","title":"Classes","text":"Type Name     struct base64_decodestate"},{"location":"ltapi/cdecode_8h/#public-types","title":"Public Types","text":"Type Name     enum base64_decodestep"},{"location":"ltapi/cdecode_8h/#public-functions","title":"Public Functions","text":"Type Name     int base64_decode_block (const char * code_in, const int length_in, char * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars (const char * code_in, const int length_in, char * plaintext_out)    int base64_decode_value (char value_in)    void base64_init_decodestate (base64_decodestate * state_in)"},{"location":"ltapi/cdecode_8h/#macros","title":"Macros","text":"Type Name     define base64_decode_expected_len (n) ((n * 3) / 4)"},{"location":"ltapi/cdecode_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/cdecode_8h/#enum-base64_decodestep","title":"enum base64_decodestep","text":"<pre><code>enum base64_decodestep {\n    step_a,\n    step_b,\n    step_c,\n    step_d\n};\n</code></pre>"},{"location":"ltapi/cdecode_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cdecode_8h/#function-base64_decode_block","title":"function base64_decode_block","text":"<pre><code>int base64_decode_block (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_decode_chars","title":"function base64_decode_chars","text":"<pre><code>int base64_decode_chars (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_decode_value","title":"function base64_decode_value","text":"<pre><code>int base64_decode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_init_decodestate","title":"function base64_init_decodestate","text":"<pre><code>void base64_init_decodestate (\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/cdecode_8h/#define-base64_decode_expected_len","title":"define base64_decode_expected_len","text":"<pre><code>#define base64_decode_expected_len (\n    n\n) ((n * 3) / 4)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cdecode.h</code></p>"},{"location":"ltapi/cdecode_8h_source/","title":"File cdecode.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cdecode.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncdecode.h - c header for a base64 decoding algorithm\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#ifndef BASE64_CDECODE_H\n#define BASE64_CDECODE_H\n\n#define base64_decode_expected_len(n) ((n * 3) / 4)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    step_a, step_b, step_c, step_d\n} base64_decodestep;\n\ntypedef struct {\n    base64_decodestep step;\n    char plainchar;\n} base64_decodestate;\n\nvoid base64_init_decodestate(base64_decodestate* state_in);\n\nint base64_decode_value(char value_in);\n\nint base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in);\n\nint base64_decode_chars(const char* code_in, const int length_in, char* plaintext_out);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* BASE64_CDECODE_H */\n</code></pre>"},{"location":"ltapi/cencode_8c/","title":"File cencode.c","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cencode.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cencode.h\"</code></li> </ul>"},{"location":"ltapi/cencode_8c/#public-functions","title":"Public Functions","text":"Type Name     int base64_encode_block (const char * plaintext_in, int length_in, char * code_out, base64_encodestate * state_in)    int base64_encode_blockend (char * code_out, base64_encodestate * state_in)    int base64_encode_chars (const char * plaintext_in, int length_in, char * code_out)    char base64_encode_value (char value_in)    void base64_init_encodestate (base64_encodestate * state_in)"},{"location":"ltapi/cencode_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cencode_8c/#function-base64_encode_block","title":"function base64_encode_block","text":"<pre><code>int base64_encode_block (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_blockend","title":"function base64_encode_blockend","text":"<pre><code>int base64_encode_blockend (\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_chars","title":"function base64_encode_chars","text":"<pre><code>int base64_encode_chars (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_value","title":"function base64_encode_value","text":"<pre><code>char base64_encode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_init_encodestate","title":"function base64_init_encodestate","text":"<pre><code>void base64_init_encodestate (\n    base64_encodestate * state_in\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cencode.c</code></p>"},{"location":"ltapi/cencode_8c_source/","title":"File cencode.c","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cencode.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncencoder.c - c source to a base64 encoding algorithm implementation\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#include \"cencode.h\"\n\nvoid base64_init_encodestate(base64_encodestate* state_in)\n{\n    state_in-&gt;step = step_A;\n    state_in-&gt;result = 0;\n}\n\nchar base64_encode_value(char value_in)\n{\n    static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    if (value_in &gt; 63) {\n        return '=';\n    }\n    return encoding[(int)value_in];\n}\n\nint base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in)\n{\n    const char* plainchar = plaintext_in;\n    const char* const plaintextend = plaintext_in + length_in;\n    char* codechar = code_out;\n    char result;\n    char fragment;\n\n    result = state_in-&gt;result;\n\n    switch (state_in-&gt;step) {\n        while (1) {\n        case step_A:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_A;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result = (fragment &amp; 0x0fc) &gt;&gt; 2;\n            *codechar++ = base64_encode_value(result);\n            result = (fragment &amp; 0x003) &lt;&lt; 4;\n        case step_B:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_B;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result |= (fragment &amp; 0x0f0) &gt;&gt; 4;\n            *codechar++ = base64_encode_value(result);\n            result = (fragment &amp; 0x00f) &lt;&lt; 2;\n        case step_C:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_C;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result |= (fragment &amp; 0x0c0) &gt;&gt; 6;\n            *codechar++ = base64_encode_value(result);\n            result  = (fragment &amp; 0x03f) &gt;&gt; 0;\n            *codechar++ = base64_encode_value(result);\n        }\n    }\n    /* control should not reach here */\n    return codechar - code_out;\n}\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in)\n{\n    char* codechar = code_out;\n\n    switch (state_in-&gt;step) {\n    case step_B:\n        *codechar++ = base64_encode_value(state_in-&gt;result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n    case step_C:\n        *codechar++ = base64_encode_value(state_in-&gt;result);\n        *codechar++ = '=';\n        break;\n    case step_A:\n        break;\n    }\n    *codechar = 0x00;\n\n    return codechar - code_out;\n}\n\nint base64_encode_chars(const char* plaintext_in, int length_in, char* code_out)\n{\n    base64_encodestate _state;\n    base64_init_encodestate(&amp;_state);\n    int len = base64_encode_block(plaintext_in, length_in, code_out, &amp;_state);\n    return len + base64_encode_blockend((code_out + len), &amp;_state);\n}\n</code></pre>"},{"location":"ltapi/cencode_8h/","title":"File cencode.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cencode.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/cencode_8h/#classes","title":"Classes","text":"Type Name     struct base64_encodestate"},{"location":"ltapi/cencode_8h/#public-types","title":"Public Types","text":"Type Name     enum base64_encodestep"},{"location":"ltapi/cencode_8h/#public-functions","title":"Public Functions","text":"Type Name     int base64_encode_block (const char * plaintext_in, int length_in, char * code_out, base64_encodestate * state_in)    int base64_encode_blockend (char * code_out, base64_encodestate * state_in)    int base64_encode_chars (const char * plaintext_in, int length_in, char * code_out)    char base64_encode_value (char value_in)    void base64_init_encodestate (base64_encodestate * state_in)"},{"location":"ltapi/cencode_8h/#macros","title":"Macros","text":"Type Name     define base64_encode_expected_len (n) ((((4 * n) / 3) + 3) &amp; ~3)"},{"location":"ltapi/cencode_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/cencode_8h/#enum-base64_encodestep","title":"enum base64_encodestep","text":"<pre><code>enum base64_encodestep {\n    step_A,\n    step_B,\n    step_C\n};\n</code></pre>"},{"location":"ltapi/cencode_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cencode_8h/#function-base64_encode_block","title":"function base64_encode_block","text":"<pre><code>int base64_encode_block (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_blockend","title":"function base64_encode_blockend","text":"<pre><code>int base64_encode_blockend (\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_chars","title":"function base64_encode_chars","text":"<pre><code>int base64_encode_chars (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_value","title":"function base64_encode_value","text":"<pre><code>char base64_encode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_init_encodestate","title":"function base64_init_encodestate","text":"<pre><code>void base64_init_encodestate (\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/cencode_8h/#define-base64_encode_expected_len","title":"define base64_encode_expected_len","text":"<pre><code>#define base64_encode_expected_len (\n    n\n) ((((4 * n) / 3) + 3) &amp; ~3)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/base64/libb64/cencode.h</code></p>"},{"location":"ltapi/cencode_8h_source/","title":"File cencode.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; base64 &gt; libb64 &gt; cencode.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncencode.h - c header for a base64 encoding algorithm\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#ifndef BASE64_CENCODE_H\n#define BASE64_CENCODE_H\n\n#define base64_encode_expected_len(n) ((((4 * n) / 3) + 3) &amp; ~3)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    step_A, step_B, step_C\n} base64_encodestep;\n\ntypedef struct {\n    base64_encodestep step;\n    char result;\n    int stepcount;\n} base64_encodestate;\n\nvoid base64_init_encodestate(base64_encodestate* state_in);\n\nchar base64_encode_value(char value_in);\n\nint base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in);\n\nint base64_encode_chars(const char* plaintext_in, int length_in, char* code_out);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* BASE64_CENCODE_H */\n</code></pre>"},{"location":"ltapi/dir_ac62547f78cd9f887119f688c741ca23/","title":"Dir cores/common/arduino/libraries/ext/cbuf","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; cbuf</p>"},{"location":"ltapi/dir_ac62547f78cd9f887119f688c741ca23/#files","title":"Files","text":"Type Name     file cbuf.cpp    file cbuf.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/cbuf/</code></p>"},{"location":"ltapi/cbuf_8cpp/","title":"File cbuf.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; cbuf &gt; cbuf.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cbuf.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/cbuf/cbuf.cpp</code></p>"},{"location":"ltapi/cbuf_8cpp_source/","title":"File cbuf.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; cbuf &gt; cbuf.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n cbuf.cpp - Circular buffer implementation\n Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"cbuf.h\"\n\ncbuf::cbuf(size_t size) :\n    next(NULL), _size(size+1), _buf(new char[size+1]), _bufend(_buf + size + 1), _begin(_buf), _end(_begin)\n{\n}\n\ncbuf::~cbuf()\n{\n    delete[] _buf;\n}\n\nsize_t cbuf::resizeAdd(size_t addSize)\n{\n    return resize(_size + addSize);\n}\n\nsize_t cbuf::resize(size_t newSize)\n{\n\n    size_t bytes_available = available();\n    newSize += 1;\n    // not lose any data\n    // if data can be lost use remove or flush before resize\n    if((newSize &lt; bytes_available) || (newSize == _size)) {\n        return _size;\n    }\n\n    char *newbuf = new char[newSize];\n    char *oldbuf = _buf;\n\n    if(!newbuf) {\n        return _size;\n    }\n\n    if(_buf) {\n        read(newbuf, bytes_available);\n        memset((newbuf + bytes_available), 0x00, (newSize - bytes_available));\n    }\n\n    _begin = newbuf;\n    _end = newbuf + bytes_available;\n    _bufend = newbuf + newSize;\n    _size = newSize;\n\n    _buf = newbuf;\n    delete[] oldbuf;\n\n    return _size;\n}\n\nsize_t cbuf::available() const\n{\n    if(_end &gt;= _begin) {\n        return _end - _begin;\n    }\n    return _size - (_begin - _end);\n}\n\nsize_t cbuf::size()\n{\n    return _size;\n}\n\nsize_t cbuf::room() const\n{\n    if(_end &gt;= _begin) {\n        return _size - (_end - _begin) - 1;\n    }\n    return _begin - _end - 1;\n}\n\nint cbuf::peek()\n{\n    if(empty()) {\n        return -1;\n    }\n\n    return static_cast&lt;int&gt;(*_begin);\n}\n\nsize_t cbuf::peek(char *dst, size_t size)\n{\n    size_t bytes_available = available();\n    size_t size_to_read = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_read = size_to_read;\n    char * begin = _begin;\n    if(_end &lt; _begin &amp;&amp; size_to_read &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        memcpy(dst, _begin, top_size);\n        begin = _buf;\n        size_to_read -= top_size;\n        dst += top_size;\n    }\n    memcpy(dst, begin, size_to_read);\n    return size_read;\n}\n\nint cbuf::read()\n{\n    if(empty()) {\n        return -1;\n    }\n\n    char result = *_begin;\n    _begin = wrap_if_bufend(_begin + 1);\n    return static_cast&lt;int&gt;(result);\n}\n\nsize_t cbuf::read(char* dst, size_t size)\n{\n    size_t bytes_available = available();\n    size_t size_to_read = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_read = size_to_read;\n    if(_end &lt; _begin &amp;&amp; size_to_read &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        memcpy(dst, _begin, top_size);\n        _begin = _buf;\n        size_to_read -= top_size;\n        dst += top_size;\n    }\n    memcpy(dst, _begin, size_to_read);\n    _begin = wrap_if_bufend(_begin + size_to_read);\n    return size_read;\n}\n\nsize_t cbuf::write(char c)\n{\n    if(full()) {\n        return 0;\n    }\n\n    *_end = c;\n    _end = wrap_if_bufend(_end + 1);\n    return 1;\n}\n\nsize_t cbuf::write(const char* src, size_t size)\n{\n    size_t bytes_available = room();\n    size_t size_to_write = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_written = size_to_write;\n    if(_end &gt;= _begin &amp;&amp; size_to_write &gt; (size_t) (_bufend - _end)) {\n        size_t top_size = _bufend - _end;\n        memcpy(_end, src, top_size);\n        _end = _buf;\n        size_to_write -= top_size;\n        src += top_size;\n    }\n    memcpy(_end, src, size_to_write);\n    _end = wrap_if_bufend(_end + size_to_write);\n    return size_written;\n}\n\nvoid cbuf::flush()\n{\n    _begin = _buf;\n    _end = _buf;\n}\n\nsize_t cbuf::remove(size_t size)\n{\n    size_t bytes_available = available();\n    if(size &gt;= bytes_available) {\n        flush();\n        return 0;\n    }\n    size_t size_to_remove = (size &lt; bytes_available) ? size : bytes_available;\n    if(_end &lt; _begin &amp;&amp; size_to_remove &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        _begin = _buf;\n        size_to_remove -= top_size;\n    }\n    _begin = wrap_if_bufend(_begin + size_to_remove);\n    return available();\n}\n</code></pre>"},{"location":"ltapi/cbuf_8h/","title":"File cbuf.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; ext &gt; cbuf &gt; cbuf.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/cbuf_8h/#classes","title":"Classes","text":"Type Name     class cbuf      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/ext/cbuf/cbuf.h</code></p>"},{"location":"ltapi/cbuf_8h_source/","title":"File cbuf.h","text":"<p>File List &gt; arduino &gt; libraries &gt; ext &gt; cbuf &gt; cbuf.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n cbuf.h - Circular buffer implementation\n Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef __cbuf_h\n#define __cbuf_h\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\nclass cbuf\n{\npublic:\n    cbuf(size_t size);\n    ~cbuf();\n\n    size_t resizeAdd(size_t addSize);\n    size_t resize(size_t newSize);\n    size_t available() const;\n    size_t size();\n\n    size_t room() const;\n\n    inline bool empty() const\n    {\n        return _begin == _end;\n    }\n\n    inline bool full() const\n    {\n        return wrap_if_bufend(_end + 1) == _begin;\n    }\n\n    int peek();\n    size_t peek(char *dst, size_t size);\n\n    int read();\n    size_t read(char* dst, size_t size);\n\n    size_t write(char c);\n    size_t write(const char* src, size_t size);\n\n    void flush();\n    size_t remove(size_t size);\n\n    cbuf *next;\n\nprotected:\n    inline char* wrap_if_bufend(char* ptr) const\n    {\n        return (ptr == _bufend) ? _buf : ptr;\n    }\n\n    size_t _size;\n    char* _buf;\n    const char* _bufend;\n    char* _begin;\n    char* _end;\n\n};\n\n#endif//__cbuf_h\n</code></pre>"},{"location":"ltapi/dir_930634efd5dc4a957bbb6e685a3ccda1/","title":"Dir cores/common/arduino/libraries/inline","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline</p>"},{"location":"ltapi/dir_930634efd5dc4a957bbb6e685a3ccda1/#files","title":"Files","text":"Type Name     file Singletons.cpp"},{"location":"ltapi/dir_930634efd5dc4a957bbb6e685a3ccda1/#directories","title":"Directories","text":"Type Name     dir ESP    dir Flash    dir LT    dir OTA    dir WDT      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/</code></p>"},{"location":"ltapi/_singletons_8cpp/","title":"File Singletons.cpp","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; Singletons.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;LT.h&gt;</code></li> <li><code>#include &lt;Flash.h&gt;</code></li> </ul>"},{"location":"ltapi/_singletons_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     EspClass ESP    FlashClass Flash    LibreTiny LT    LibreTinyOTA OTA    LibreTinyWDT WDT"},{"location":"ltapi/_singletons_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_singletons_8cpp/#variable-esp","title":"variable ESP","text":"<pre><code>EspClass ESP;\n</code></pre>"},{"location":"ltapi/_singletons_8cpp/#variable-flash","title":"variable Flash","text":"<pre><code>FlashClass Flash;\n</code></pre>"},{"location":"ltapi/_singletons_8cpp/#variable-lt","title":"variable LT","text":"<pre><code>LibreTiny LT;\n</code></pre>"},{"location":"ltapi/_singletons_8cpp/#variable-ota","title":"variable OTA","text":"<pre><code>LibreTinyOTA OTA;\n</code></pre>"},{"location":"ltapi/_singletons_8cpp/#variable-wdt","title":"variable WDT","text":"<pre><code>LibreTinyWDT WDT;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/Singletons.cpp</code></p>"},{"location":"ltapi/_singletons_8cpp_source/","title":"File Singletons.cpp","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; Singletons.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-10. */\n\n#include &lt;LT.h&gt;\n\n#include &lt;Flash.h&gt;\n\nLibreTiny LT;\nLibreTinyOTA OTA;\nLibreTinyWDT WDT;\nEspClass ESP;\nFlashClass Flash;\n</code></pre>"},{"location":"ltapi/dir_2f50d07e877c964a6683aa974aacc5a9/","title":"Dir cores/common/arduino/libraries/inline/ESP","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; ESP</p>"},{"location":"ltapi/dir_2f50d07e877c964a6683aa974aacc5a9/#files","title":"Files","text":"Type Name     file ESP.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/ESP/</code></p>"},{"location":"ltapi/_e_s_p_8h/","title":"File ESP.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; ESP &gt; ESP.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_e_s_p_8h/#classes","title":"Classes","text":"Type Name     class EspClass ESP Arduino Core compatibility class."},{"location":"ltapi/_e_s_p_8h/#public-attributes","title":"Public Attributes","text":"Type Name     EspClass ESP"},{"location":"ltapi/_e_s_p_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_e_s_p_8h/#variable-esp","title":"variable ESP","text":"<pre><code>EspClass ESP;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/ESP/ESP.h</code></p>"},{"location":"ltapi/_e_s_p_8h_source/","title":"File ESP.h","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; ESP &gt; ESP.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-20.() */\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\n\nclass EspClass {\n  public:\n    inline void wdtEnable(uint32_t timeout_ms = 0) { lt_wdt_enable(timeout_ms); }\n\n    inline void wdtDisable() { lt_wdt_disable(); }\n\n    inline void wdtFeed() { lt_wdt_feed(); }\n\n    inline void reset() { lt_reboot(); }\n\n    inline void restart() { lt_reboot(); }\n\n    inline void rebootIntoUartDownloadMode() { lt_reboot_download_mode(); }\n\n    inline uint16_t getVcc() { return 3300; }\n\n    inline uint32_t getChipId() { return lt_cpu_get_mac_id(); }\n\n    inline uint32_t getFreeHeap() { return lt_heap_get_free(); }\n\n    inline uint16_t getMaxFreeBlockSize() { return lt_heap_get_max_alloc(); }\n\n    inline const char *getSdkVersion() { return LT_VERSION_STR; }\n\n    inline String getCoreVersion() { return LT_VERSION_STR; }\n\n    inline String getFullVersion() { return LT_BANNER_STR; }\n\n    inline uint8_t getBootVersion() { return 0; }\n\n    inline uint8_t getBootMode() { return 0; }\n\n    inline uint8_t getCpuFreqMHz() { return lt_cpu_get_freq_mhz(); }\n\n    inline uint32_t getFlashChipId() {\n        lt_flash_id_t id = lt_flash_get_id();\n        return id.manufacturer_id &lt;&lt; 16 | id.chip_id &lt;&lt; 7 | id.chip_size_id;\n    }\n\n    inline uint8_t getFlashChipVendorId() { return lt_flash_get_id().manufacturer_id; }\n\n    inline uint32_t getFlashChipRealSize() { return lt_flash_get_size(); }\n\n    inline uint32_t getFlashChipSize() { return lt_flash_get_size(); }\n\n    inline uint32_t getFlashChipMode() { return 0xFF; }\n\n    inline uint32_t getFlashChipSizeByChipId() { return lt_flash_get_size(); }\n\n    inline bool flashEraseSector(uint32_t sector) { return lt_flash_erase_block(sector); }\n\n    inline bool flashWrite(uint32_t address, const uint8_t *data, size_t size) {\n        return lt_flash_write(address, data, size) == size;\n    }\n\n    inline bool flashRead(uint32_t address, uint8_t *data, size_t size) {\n        return lt_flash_read(address, data, size) == size;\n    }\n\n    inline String getResetReason() { return lt_get_reboot_reason_name(lt_get_reboot_reason()); }\n\n    inline String getResetInfo() { return lt_get_reboot_reason_name(lt_get_reboot_reason()); }\n\n    inline uint8_t *random(uint8_t *resultArray, const size_t outputSizeBytes) {\n        lt_rand_bytes(resultArray, (size_t)outputSizeBytes);\n        return resultArray;\n    }\n\n    inline uint32_t random() {\n        uint32_t i;\n        lt_rand_bytes((uint8_t *)&amp;i, 4);\n        return i;\n    }\n\n    inline uint32_t getCycleCount() { return lt_cpu_get_cycle_count(); }\n};\n\nextern EspClass ESP;\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_e3ef11b23e60019cef556571ad08a868/","title":"Dir cores/common/arduino/libraries/inline/Flash","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; Flash</p>"},{"location":"ltapi/dir_e3ef11b23e60019cef556571ad08a868/#files","title":"Files","text":"Type Name     file Flash.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/Flash/</code></p>"},{"location":"ltapi/_flash_8h/","title":"File Flash.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; Flash &gt; Flash.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_flash_8h/#classes","title":"Classes","text":"Type Name     class FlashClass"},{"location":"ltapi/_flash_8h/#public-attributes","title":"Public Attributes","text":"Type Name     FlashClass Flash"},{"location":"ltapi/_flash_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_flash_8h/#variable-flash","title":"variable Flash","text":"<pre><code>FlashClass Flash;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/Flash/Flash.h</code></p>"},{"location":"ltapi/_flash_8h_source/","title":"File Flash.h","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; Flash &gt; Flash.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-24. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\n\nclass FlashClass {\n  public:\n    inline FlashId getChipId() { return lt_flash_get_id(); }\n\n    inline uint32_t getSize() { return lt_flash_get_size(); }\n\n    inline bool eraseSector(uint32_t offset) {\n        //\n        return lt_flash_erase_block(offset);\n    }\n\n    inline bool readBlock(uint32_t offset, uint8_t *data, size_t length) {\n        //\n        return lt_flash_read(offset, data, length) == length;\n    }\n\n    inline bool writeBlock(uint32_t offset, const uint8_t *data, size_t length) {\n        //\n        return lt_flash_write(offset, data, length) == length;\n    }\n};\n\nextern FlashClass Flash;\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_264b85d2860d8f7b79a05bde705c2149/","title":"Dir cores/common/arduino/libraries/inline/LT","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; LT</p>"},{"location":"ltapi/dir_264b85d2860d8f7b79a05bde705c2149/#files","title":"Files","text":"Type Name     file LT.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/LT/</code></p>"},{"location":"ltapi/_l_t_8h/","title":"File LT.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; LT &gt; LT.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;ESP.h&gt;</code></li> <li><code>#include &lt;OTA.h&gt;</code></li> <li><code>#include &lt;WDT.h&gt;</code></li> </ul>"},{"location":"ltapi/_l_t_8h/#classes","title":"Classes","text":"Type Name     class LibreTiny Main LibreTiny API class."},{"location":"ltapi/_l_t_8h/#public-attributes","title":"Public Attributes","text":"Type Name     LibreTiny LT"},{"location":"ltapi/_l_t_8h/#macros","title":"Macros","text":"Type Name     define ChipFamily  lt_cpu_family_t   define ChipType  lt_cpu_model_t   define FlashId lt_flash_id_t   define ResetReason  lt_reboot_reason_t"},{"location":"ltapi/_l_t_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_l_t_8h/#variable-lt","title":"variable LT","text":"<pre><code>LibreTiny LT;\n</code></pre>"},{"location":"ltapi/_l_t_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_l_t_8h/#define-chipfamily","title":"define ChipFamily","text":"<pre><code>#define ChipFamily lt_cpu_family_t\n</code></pre>"},{"location":"ltapi/_l_t_8h/#define-chiptype","title":"define ChipType","text":"<pre><code>#define ChipType lt_cpu_model_t\n</code></pre>"},{"location":"ltapi/_l_t_8h/#define-flashid","title":"define FlashId","text":"<pre><code>#define FlashId lt_flash_id_t\n</code></pre>"},{"location":"ltapi/_l_t_8h/#define-resetreason","title":"define ResetReason","text":"<pre><code>#define ResetReason lt_reboot_reason_t\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/LT/LT.h</code></p>"},{"location":"ltapi/_l_t_8h_source/","title":"File LT.h","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; LT &gt; LT.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-06. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;ESP.h&gt;\n#include &lt;OTA.h&gt;\n#include &lt;WDT.h&gt;\n\n#ifdef __cplusplus\n\n#define ChipFamily  lt_cpu_family_t\n#define ChipType    lt_cpu_model_t\n#define ResetReason lt_reboot_reason_t\n#define FlashId     lt_flash_id_t\n\nclass LibreTiny {\n  public: /* lt_cpu.h */\n    inline ChipFamily getChipFamily() { return lt_cpu_get_family(); }\n\n    inline const char *getChipFamilyName() { return lt_cpu_get_family_name(); }\n\n    inline ChipType getChipType() { return lt_cpu_get_model(); }\n\n    inline const char *getChipModel() { return lt_cpu_get_model_name(); }\n\n    inline uint32_t getChipId() { return lt_cpu_get_mac_id(); }\n\n    inline uint8_t getChipCores() { return lt_cpu_get_core_count(); }\n\n    inline const char *getChipCoreType() { return lt_cpu_get_core_type(); }\n\n    inline uint32_t getCpuFreq() { return lt_cpu_get_freq(); }\n\n    inline uint32_t getCpuFreqMHz() { return lt_cpu_get_freq_mhz(); }\n\n    inline uint32_t getCycleCount() { return lt_cpu_get_cycle_count(); }\n\n  public: /* lt_device.h */\n    inline const char *getVersion() { return lt_get_version(); }\n\n    inline const char *getBoard() { return lt_get_board_code(); }\n\n    inline const char *getDeviceName() { return lt_get_device_name(); }\n\n    inline void restart() { lt_reboot(); }\n\n    inline void restartDownloadMode() { lt_reboot_download_mode(); }\n\n    inline ResetReason getResetReason() { return lt_get_reboot_reason(); }\n\n    inline const char *getResetReasonName(ResetReason reason = lt_get_reboot_reason()) {\n        return lt_get_reboot_reason_name(reason);\n    }\n\n    inline void gpioRecover() { lt_gpio_recover(); }\n\n  public: /* lt_flash.h */\n    inline FlashId getFlashChipId() { return lt_flash_get_id(); }\n\n    inline uint32_t getFlashChipSize() { return lt_flash_get_size(); }\n\n  public: /* lt_mem.h */\n    inline uint32_t getRamSize() { return lt_ram_get_size(); }\n\n    inline uint32_t getHeapSize() { return lt_heap_get_size(); }\n\n    inline uint32_t getFreeHeap() { return lt_heap_get_free(); }\n\n    inline uint32_t getMinFreeHeap() { return lt_heap_get_min_free(); }\n\n    inline uint32_t getMaxAllocHeap() { return lt_heap_get_max_alloc(); }\n\n    inline uint32_t getMaxFreeBlockSize() { return lt_heap_get_max_alloc(); }\n};\n\nextern LibreTiny LT;\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_1f237d2cf3ecae9e1cbbfcb1aefdc1b7/","title":"Dir cores/common/arduino/libraries/inline/OTA","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; OTA</p>"},{"location":"ltapi/dir_1f237d2cf3ecae9e1cbbfcb1aefdc1b7/#files","title":"Files","text":"Type Name     file OTA.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/OTA/</code></p>"},{"location":"ltapi/_o_t_a_8h/","title":"File OTA.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; OTA &gt; OTA.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_o_t_a_8h/#classes","title":"Classes","text":"Type Name     class LibreTinyOTA Over-the-Air updates helper class."},{"location":"ltapi/_o_t_a_8h/#public-attributes","title":"Public Attributes","text":"Type Name     LibreTinyOTA OTA"},{"location":"ltapi/_o_t_a_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_o_t_a_8h/#variable-ota","title":"variable OTA","text":"<pre><code>LibreTinyOTA OTA;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/OTA/OTA.h</code></p>"},{"location":"ltapi/_o_t_a_8h_source/","title":"File OTA.h","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; OTA &gt; OTA.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-10. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\n\nclass LibreTinyOTA {\n  public: /* lt_ota.h */\n    inline lt_ota_type_t getType() { return lt_ota_get_type(); }\n\n    inline bool isValid(uint8_t index) { return lt_ota_is_valid(index); }\n\n    inline bool canRollback() { return lt_ota_can_rollback(); }\n\n    inline uint8_t getCurrentIndex() { return lt_ota_dual_get_current(); }\n\n    inline uint8_t getStoredIndex() { return lt_ota_dual_get_stored(); }\n\n    inline uf2_ota_scheme_t getUF2Scheme() { return lt_ota_get_uf2_scheme(); }\n\n    inline bool switchImage(bool revert = false) { return lt_ota_switch(revert); }\n};\n\nextern LibreTinyOTA OTA;\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_bd1e4bd763507df1c98830c76e327ffd/","title":"Dir cores/common/arduino/libraries/inline/WDT","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; WDT</p>"},{"location":"ltapi/dir_bd1e4bd763507df1c98830c76e327ffd/#files","title":"Files","text":"Type Name     file WDT.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/WDT/</code></p>"},{"location":"ltapi/_w_d_t_8h/","title":"File WDT.h","text":"<p>FileList &gt; arduino &gt; libraries &gt; inline &gt; WDT &gt; WDT.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_w_d_t_8h/#classes","title":"Classes","text":"Type Name     class LibreTinyWDT Watchdog control class."},{"location":"ltapi/_w_d_t_8h/#public-attributes","title":"Public Attributes","text":"Type Name     LibreTinyWDT WDT"},{"location":"ltapi/_w_d_t_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_w_d_t_8h/#variable-wdt","title":"variable WDT","text":"<pre><code>LibreTinyWDT WDT;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/libraries/inline/WDT/WDT.h</code></p>"},{"location":"ltapi/_w_d_t_8h_source/","title":"File WDT.h","text":"<p>File List &gt; arduino &gt; libraries &gt; inline &gt; WDT &gt; WDT.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-10. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\n\nclass LibreTinyWDT {\n  public: /* lt_wdt.h */\n    inline bool enable(uint32_t timeout = 10000) { return lt_wdt_enable(timeout); }\n\n    inline void disable() { lt_wdt_disable(); }\n\n    inline void feed() { lt_wdt_feed(); }\n};\n\nextern LibreTinyWDT WDT;\n\n#endif\n</code></pre>"},{"location":"ltapi/dir_cd39a9ca7156574bbf526216c63c01b5/","title":"Dir cores/common/arduino/src","text":"<p>FileList &gt; arduino &gt; src</p>"},{"location":"ltapi/dir_cd39a9ca7156574bbf526216c63c01b5/#files","title":"Files","text":"Type Name     file Arduino.h    file Events.cpp    file Events.h    file HardwareI2C.h    file main.c"},{"location":"ltapi/dir_cd39a9ca7156574bbf526216c63c01b5/#directories","title":"Directories","text":"Type Name     dir common    dir compat    dir posix    dir wiring      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/</code></p>"},{"location":"ltapi/_arduino_8h/","title":"File Arduino.h","text":"<p>FileList &gt; arduino &gt; src &gt; Arduino.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> <li><code>#include &lt;sys/time.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;api/ArduinoAPI.h&gt;</code></li> <li><code>#include &lt;LT.h&gt;</code></li> <li><code>#include &lt;ArduinoFamily.h&gt;</code></li> <li><code>#include \"wiring_compat.h\"</code></li> <li><code>#include \"wiring_custom.h\"</code></li> <li><code>#include &lt;FreeRTOS.h&gt;</code></li> <li><code>#include &lt;task.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Arduino.h</code></p>"},{"location":"ltapi/_arduino_8h_source/","title":"File Arduino.h","text":"<p>File List &gt; arduino &gt; src &gt; Arduino.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-14. */\n\n#pragma once\n\n// LibreTiny C API (with C standard libraries)\n#include &lt;libretiny.h&gt;\n\n// Additional C libraries\n#include &lt;sys/time.h&gt;\n#include &lt;time.h&gt;\n\n// C++ standard libraries\n#ifdef __cplusplus\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\nusing ::round;\nusing std::abs;\nusing std::isinf;\nusing std::isnan;\nusing std::max;\nusing std::min;\n#endif\n\n// Arduino Core and LT class\n#include &lt;api/ArduinoAPI.h&gt;\n#ifdef __cplusplus\n#include &lt;LT.h&gt;\nusing namespace arduino;\n#endif\n\n// Include family-specific code\n#include &lt;ArduinoFamily.h&gt;\n\n// Additional Wiring headers\n#include \"wiring_compat.h\"\n#include \"wiring_custom.h\"\n\n// FreeRTOS kernel\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n\n// Define available serial ports\n#if defined(__cplusplus) &amp;&amp; LT_ARD_HAS_SERIAL\n#include &lt;Serial.h&gt;\n\n#if HAS_SERIAL_CLASS\n#if LT_HW_UART0\nextern SerialClass Serial0;\n#endif\n#if LT_HW_UART1\nextern SerialClass Serial1;\n#endif\n#if LT_HW_UART2\nextern SerialClass Serial2;\n#endif\n#endif\n\n#define SerialN(x) Serial##x\n#define SerialM(x) SerialN(x)\n#define Serial     SerialM(LT_UART_DEFAULT_SERIAL)\n#endif\n</code></pre>"},{"location":"ltapi/_events_8cpp/","title":"File Events.cpp","text":"<p>FileList &gt; arduino &gt; src &gt; Events.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Events.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Events.cpp</code></p>"},{"location":"ltapi/_events_8cpp_source/","title":"File Events.cpp","text":"<p>File List &gt; arduino &gt; src &gt; Events.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-17. */\n\n#include \"Events.h\"\n\nuint16_t EventHandler_s::lastId = 1;\n</code></pre>"},{"location":"ltapi/_events_8h/","title":"File Events.h","text":"<p>FileList &gt; arduino &gt; src &gt; Events.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"ltapi/_events_8h/#classes","title":"Classes","text":"Type Name     struct EventHandler_s    struct arduino_event_t"},{"location":"ltapi/_events_8h/#public-types","title":"Public Types","text":"Type Name     typedef void(* EventCb    typedef std::function&lt; void(EventId event, EventInfo info)&gt; EventFuncCb    typedef struct EventHandler_s EventHandler    typedef void(* EventSysCb    enum arduino_event_id_t    union arduino_event_info_t"},{"location":"ltapi/_events_8h/#macros","title":"Macros","text":"Type Name     define EventId  arduino_event_id_t   define EventId_t  arduino_event_id_t   define EventInfo arduino_event_info_t   define EventInfo_t arduino_event_info_t   define Event_t arduino_event_t"},{"location":"ltapi/_events_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_events_8h/#typedef-eventcb","title":"typedef EventCb","text":"<pre><code>typedef void(* EventCb) (EventId event);\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventfunccb","title":"typedef EventFuncCb","text":"<pre><code>typedef std::function&lt;void(EventId event, EventInfo info)&gt; EventFuncCb;\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventhandler","title":"typedef EventHandler","text":"<pre><code>typedef struct EventHandler_s EventHandler;\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventsyscb","title":"typedef EventSysCb","text":"<pre><code>typedef void(* EventSysCb) (Event_t *event);\n</code></pre>"},{"location":"ltapi/_events_8h/#enum-arduino_event_id_t","title":"enum arduino_event_id_t","text":"<pre><code>enum arduino_event_id_t {\n    ARDUINO_EVENT_WIFI_READY = 0,\n    ARDUINO_EVENT_WIFI_SCAN_DONE,\n    ARDUINO_EVENT_WIFI_STA_START,\n    ARDUINO_EVENT_WIFI_STA_STOP,\n    ARDUINO_EVENT_WIFI_STA_CONNECTED,\n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,\n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,\n    ARDUINO_EVENT_WIFI_AP_STOP,\n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED,\n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT,\n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,\n    ARDUINO_EVENT_WPS_ER_FAILED,\n    ARDUINO_EVENT_WPS_ER_TIMEOUT,\n    ARDUINO_EVENT_WPS_ER_PIN,\n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP,\n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n};\n</code></pre>"},{"location":"ltapi/_events_8h/#union-arduino_event_info_t","title":"union arduino_event_info_t","text":""},{"location":"ltapi/_events_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_events_8h/#define-eventid","title":"define EventId","text":"<pre><code>#define EventId arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventid_t","title":"define EventId_t","text":"<pre><code>#define EventId_t arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventinfo","title":"define EventInfo","text":"<pre><code>#define EventInfo arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventinfo_t","title":"define EventInfo_t","text":"<pre><code>#define EventInfo_t arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-event_t","title":"define Event_t","text":"<pre><code>#define Event_t arduino_event_t\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/Events.h</code></p>"},{"location":"ltapi/_events_8h_source/","title":"File Events.h","text":"<p>File List &gt; arduino &gt; src &gt; Events.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n ESP8266WiFiGeneric.h - esp8266 Wifi support.\n Based on WiFi.h from Ardiono WiFi shield library.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n Reworked by Markus Sattler, December 2015\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFiEvents.h&gt;\n#include &lt;functional&gt;\n\ntypedef enum {\n    ARDUINO_EVENT_WIFI_READY = 0,           \n    ARDUINO_EVENT_WIFI_SCAN_DONE,           \n    ARDUINO_EVENT_WIFI_STA_START,           \n    ARDUINO_EVENT_WIFI_STA_STOP,            \n    ARDUINO_EVENT_WIFI_STA_CONNECTED,       \n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,    \n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE, \n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,           \n    ARDUINO_EVENT_WIFI_AP_STOP,            \n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,    \n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED, \n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED, \n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT, \n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,     \n    ARDUINO_EVENT_WPS_ER_FAILED,      \n    ARDUINO_EVENT_WPS_ER_TIMEOUT,     \n    ARDUINO_EVENT_WPS_ER_PIN,         \n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP, \n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n} arduino_event_id_t;\n\ntypedef union {\n    wifi_event_sta_scan_done_t wifi_scan_done;\n    wifi_event_sta_authmode_change_t wifi_sta_authmode_change;\n    wifi_event_sta_connected_t wifi_sta_connected;\n    wifi_event_sta_disconnected_t wifi_sta_disconnected;\n    wifi_event_sta_wps_er_pin_t wps_er_pin;\n    wifi_event_sta_wps_fail_reason_t wps_fail_reason;\n    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved;\n    wifi_event_ap_staconnected_t wifi_ap_staconnected;\n    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected;\n    wifi_event_ftm_report_t wifi_ftm_report;\n    ip_event_ap_staipassigned_t wifi_ap_staipassigned;\n    ip_event_got_ip_t got_ip;\n    ip_event_got_ip6_t got_ip6;\n    // smartconfig_event_got_ssid_pswd_t sc_got_ssid_pswd;\n    // esp_eth_handle_t eth_connected;\n    // wifi_sta_config_t prov_cred_recv;\n    // wifi_prov_sta_fail_reason_t prov_fail_reason;\n} arduino_event_info_t;\n\ntypedef struct {\n    arduino_event_id_t event_id;\n    arduino_event_info_t event_info;\n} arduino_event_t;\n\n#define EventId     arduino_event_id_t\n#define EventId_t   arduino_event_id_t\n#define EventInfo   arduino_event_info_t\n#define EventInfo_t arduino_event_info_t\n#define Event_t     arduino_event_t\n\ntypedef void (*EventCb)(EventId event);\ntypedef std::function&lt;void(EventId event, EventInfo info)&gt; EventFuncCb;\ntypedef void (*EventSysCb)(Event_t *event);\n\ntypedef struct EventHandler_s {\n    static uint16_t lastId;\n    uint16_t id;\n    EventCb cb;\n    EventFuncCb fcb;\n    EventSysCb scb;\n    EventId eventId;\n\n    EventHandler_s() : id(lastId++), cb(NULL), fcb(NULL), scb(NULL) {}\n} EventHandler;\n</code></pre>"},{"location":"ltapi/_hardware_i2_c_8h/","title":"File HardwareI2C.h","text":"<p>FileList &gt; arduino &gt; src &gt; HardwareI2C.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/Stream.h&gt;</code></li> </ul>"},{"location":"ltapi/_hardware_i2_c_8h/#classes","title":"Classes","text":"Type Name     class HardwareI2C      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/HardwareI2C.h</code></p>"},{"location":"ltapi/_hardware_i2_c_8h_source/","title":"File HardwareI2C.h","text":"<p>File List &gt; arduino &gt; src &gt; HardwareI2C.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-09. */\n\n#include &lt;api/Stream.h&gt;\n\nclass HardwareI2C : public Stream {\n  protected:\n    int8_t _sda    = -1;\n    int8_t _scl    = -1;\n    uint32_t _freq = 0;\n\n    void (*onRequestCallback)(void);\n    void (*onReceiveCallback)(int);\n\n  public:\n    bool begin() {\n        return begin(_sda, _scl, _freq);\n    }\n\n    bool begin(uint8_t address) {\n        return begin(address, _sda, _scl, _freq);\n    }\n\n    virtual bool setPins(int8_t sda, int8_t scl) = 0;\n\n    virtual bool begin(int8_t sda, int8_t scl, uint32_t frequency = 0)                  = 0;\n    virtual bool begin(uint8_t address, int8_t sda, int8_t scl, uint32_t frequency = 0) = 0;\n    virtual bool end()                                                                  = 0;\n\n    virtual bool setClock(uint32_t freq) = 0;\n\n    virtual void beginTransmission(uint8_t address) = 0;\n    virtual uint8_t endTransmission(bool stopBit)   = 0;\n\n    virtual size_t requestFrom(uint8_t address, size_t len, bool stopBit) = 0;\n\n    virtual size_t write(const uint8_t *data, size_t len) = 0;\n\n    virtual int available() = 0;\n    virtual int read()      = 0;\n    virtual int peek()      = 0;\n    virtual void flush()    = 0;\n\n    uint32_t getClock() {\n        return _freq;\n    }\n\n    uint8_t endTransmission() {\n        return endTransmission(true);\n    }\n\n    size_t requestFrom(uint8_t address, size_t len) {\n        return requestFrom(address, len, true);\n    }\n\n    virtual size_t write(uint8_t data) {\n        return write(&amp;data, 1);\n    }\n\n    void onReceive(void (*cb)(int)) {\n        onReceiveCallback = cb;\n    }\n\n    void onRequest(void (*cb)(void)) {\n        onRequestCallback = cb;\n    }\n};\n</code></pre>"},{"location":"ltapi/dir_bdd93a4e8b1efe1644b5e8d87982bdbf/","title":"Dir cores/common/arduino/src/common","text":"<p>FileList &gt; arduino &gt; src &gt; common</p>"},{"location":"ltapi/dir_bdd93a4e8b1efe1644b5e8d87982bdbf/#files","title":"Files","text":"Type Name     file abi.cpp    file dtostrf.c    file serial_event.cpp      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/common/</code></p>"},{"location":"ltapi/abi_8cpp/","title":"File abi.cpp","text":"<p>FileList &gt; arduino &gt; src &gt; common &gt; abi.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"ltapi/abi_8cpp/#public-functions","title":"Public Functions","text":"Type Name     void __cxa_deleted_virtual (void)    void __cxa_pure_virtual (void)"},{"location":"ltapi/abi_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/abi_8cpp/#function-__cxa_deleted_virtual","title":"function __cxa_deleted_virtual","text":"<pre><code>void __cxa_deleted_virtual (\n    void\n) \n</code></pre>"},{"location":"ltapi/abi_8cpp/#function-__cxa_pure_virtual","title":"function __cxa_pure_virtual","text":"<pre><code>void __cxa_pure_virtual (\n    void\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/common/abi.cpp</code></p>"},{"location":"ltapi/abi_8cpp_source/","title":"File abi.cpp","text":"<p>File List &gt; arduino &gt; src &gt; common &gt; abi.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;stdlib.h&gt;\n\nextern \"C\" void __cxa_pure_virtual(void) __attribute__((__noreturn__));\nextern \"C\" void __cxa_deleted_virtual(void) __attribute__((__noreturn__));\n\nvoid __cxa_pure_virtual(void) {\n    // We might want to write some diagnostics to uart in this case\n    // std::terminate();\n    while (1)\n        ;\n}\n\nvoid __cxa_deleted_virtual(void) {\n    // We might want to write some diagnostics to uart in this case\n    // std::terminate();\n    while (1)\n        ;\n}\n</code></pre>"},{"location":"ltapi/dtostrf_8c/","title":"File dtostrf.c","text":"<p>FileList &gt; arduino &gt; src &gt; common &gt; dtostrf.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/dtostrf_8c/#public-functions","title":"Public Functions","text":"Type Name     char * dtostrf (double val, signed char width, unsigned char prec, char * sout)"},{"location":"ltapi/dtostrf_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/dtostrf_8c/#function-dtostrf","title":"function dtostrf","text":"<pre><code>char * dtostrf (\n    double val,\n    signed char width,\n    unsigned char prec,\n    char * sout\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/common/dtostrf.c</code></p>"},{"location":"ltapi/dtostrf_8c_source/","title":"File dtostrf.c","text":"<p>File List &gt; arduino &gt; src &gt; common &gt; dtostrf.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  dtostrf - Emulation for dtostrf function from avr-libc\n  Copyright (c) 2013 Arduino.  All rights reserved.\n  Written by Cristian Maglie &lt;c.maglie@arduino.cc&gt;\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n\nchar *dtostrf(double val, signed char width, unsigned char prec, char *sout) {\n    char fmt[20];\n    sprintf(fmt, \"%%%d.%df\", width, prec);\n    sprintf(sout, fmt, val);\n    return sout;\n}\n</code></pre>"},{"location":"ltapi/serial__event_8cpp/","title":"File serial_event.cpp","text":"<p>FileList &gt; arduino &gt; src &gt; common &gt; serial_event.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/serial__event_8cpp/#public-functions","title":"Public Functions","text":"Type Name     bool Serial_available ()    void serialEvent ()    void serialEventRun (void)"},{"location":"ltapi/serial__event_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/serial__event_8cpp/#function-serial_available","title":"function Serial_available","text":"<pre><code>bool Serial_available () \n</code></pre>"},{"location":"ltapi/serial__event_8cpp/#function-serialevent","title":"function serialEvent","text":"<pre><code>void serialEvent () \n</code></pre>"},{"location":"ltapi/serial__event_8cpp/#function-serialeventrun","title":"function serialEventRun","text":"<pre><code>void serialEventRun (\n    void\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/common/serial_event.cpp</code></p>"},{"location":"ltapi/serial__event_8cpp_source/","title":"File serial_event.cpp","text":"<p>File List &gt; arduino &gt; src &gt; common &gt; serial_event.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#include &lt;Arduino.h&gt;\n\nvoid serialEvent() __attribute__((weak));\nbool Serial_available() __attribute__((weak));\n\nvoid serialEventRun(void) {\n    if (Serial_available &amp;&amp; serialEvent &amp;&amp; Serial_available())\n        serialEvent();\n}\n</code></pre>"},{"location":"ltapi/dir_1927ccce0cee954fb29eb9cedf1bc791/","title":"Dir cores/common/arduino/src/compat","text":"<p>FileList &gt; arduino &gt; src &gt; compat</p>"},{"location":"ltapi/dir_1927ccce0cee954fb29eb9cedf1bc791/#files","title":"Files","text":"Type Name     file ESPmDNS.h    file FS.h    file FSImpl.h    file WiFiAP.h    file md5.h    file pgmspace.h    file vfs_api.h      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/</code></p>"},{"location":"ltapi/_e_s_pm_d_n_s_8h/","title":"File ESPmDNS.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; ESPmDNS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mDNS.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/ESPmDNS.h</code></p>"},{"location":"ltapi/_e_s_pm_d_n_s_8h_source/","title":"File ESPmDNS.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; ESPmDNS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#pragma once\n\n#include \"mDNS.h\"\n</code></pre>"},{"location":"ltapi/src_2compat_2_f_s_8h/","title":"File FS.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; FS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/FS.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/FS.h</code></p>"},{"location":"ltapi/src_2compat_2_f_s_8h_source/","title":"File FS.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; FS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include &lt;api/FS.h&gt;\n</code></pre>"},{"location":"ltapi/_f_s_impl_8h/","title":"File FSImpl.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; FSImpl.h</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/FSImpl.h</code></p>"},{"location":"ltapi/_f_s_impl_8h_source/","title":"File FSImpl.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; FSImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n// nop\n</code></pre>"},{"location":"ltapi/_wi_fi_a_p_8h/","title":"File WiFiAP.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; WiFiAP.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;WiFi.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/WiFiAP.h</code></p>"},{"location":"ltapi/_wi_fi_a_p_8h_source/","title":"File WiFiAP.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; WiFiAP.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n// ESP32 WiFi examples use WiFiAP.h include\n\n#include &lt;WiFi.h&gt;\n</code></pre>"},{"location":"ltapi/src_2compat_2_m_d5_8h/","title":"File md5.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; md5.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;MD5.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/md5.h</code></p>"},{"location":"ltapi/src_2compat_2_m_d5_8h_source/","title":"File md5.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; md5.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#pragma once\n\n// lowercase \"md5.h\" to allow including actual MD5.h on case-sensitive OSes\n#include &lt;MD5.h&gt;\n</code></pre>"},{"location":"ltapi/pgmspace_8h/","title":"File pgmspace.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; pgmspace.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/deprecated-avr-comp/avr/pgmspace.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/pgmspace.h</code></p>"},{"location":"ltapi/pgmspace_8h_source/","title":"File pgmspace.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; pgmspace.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include &lt;api/deprecated-avr-comp/avr/pgmspace.h&gt;\n</code></pre>"},{"location":"ltapi/vfs__api_8h/","title":"File vfs_api.h","text":"<p>FileList &gt; arduino &gt; src &gt; compat &gt; vfs_api.h</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/compat/vfs_api.h</code></p>"},{"location":"ltapi/vfs__api_8h_source/","title":"File vfs_api.h","text":"<p>File List &gt; arduino &gt; src &gt; compat &gt; vfs_api.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n// nop\n</code></pre>"},{"location":"ltapi/dir_7c3b5015b008a83a07f1017471251f6f/","title":"Dir cores/common/arduino/src/posix","text":"<p>FileList &gt; arduino &gt; src &gt; posix</p>"},{"location":"ltapi/dir_7c3b5015b008a83a07f1017471251f6f/#files","title":"Files","text":"Type Name     file time.c      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/posix/</code></p>"},{"location":"ltapi/time_8c/","title":"File time.c","text":"<p>FileList &gt; arduino &gt; src &gt; posix &gt; time.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> </ul>"},{"location":"ltapi/time_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     uint32_t reset_epoch   = = 0   uint32_t reset_millis   = = 0"},{"location":"ltapi/time_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_gettimeofday (struct timeval * tv, void * tz)    int __wrap_settimeofday (const struct timeval * tv, const struct timezone * tz)    int _gettimeofday (struct timeval * tv, void * tz)    int _settimeofday (const struct timeval * tv, const struct timezone * tz)    int gettimeofday (struct timeval * tv, void * tz)    int settimeofday (const struct timeval * tv, const struct timezone * tz)"},{"location":"ltapi/time_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/time_8c/#variable-reset_epoch","title":"variable reset_epoch","text":"<pre><code>uint32_t reset_epoch;\n</code></pre>"},{"location":"ltapi/time_8c/#variable-reset_millis","title":"variable reset_millis","text":"<pre><code>uint32_t reset_millis;\n</code></pre>"},{"location":"ltapi/time_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/time_8c/#function-__wrap_gettimeofday","title":"function __wrap_gettimeofday","text":"<pre><code>int __wrap_gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-__wrap_settimeofday","title":"function __wrap_settimeofday","text":"<pre><code>int __wrap_settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-_gettimeofday","title":"function _gettimeofday","text":"<pre><code>int _gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-_settimeofday","title":"function _settimeofday","text":"<pre><code>int _settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-gettimeofday","title":"function gettimeofday","text":"<pre><code>int gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-settimeofday","title":"function settimeofday","text":"<pre><code>int settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/posix/time.c</code></p>"},{"location":"ltapi/time_8c_source/","title":"File time.c","text":"<p>File List &gt; arduino &gt; src &gt; posix &gt; time.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-09-03. */\n\n#include &lt;Arduino.h&gt;\n#include &lt;errno.h&gt;\n\nstatic uint32_t reset_epoch  = 0; // epoch corresponding to millis() == 0\nstatic uint32_t reset_millis = 0; // millis() when epoch reset was performed\n\nint __wrap_gettimeofday(struct timeval *tv, void *tz) {\n    if (millis() &lt; reset_millis) {\n        // the clock overflowed\n        reset_epoch += UINT32_MAX / 1000;\n        reset_millis = millis();\n    }\n    if (!tv) {\n        errno = EINVAL;\n        return -1;\n    }\n    unsigned long m = millis();\n    tv-&gt;tv_sec      = reset_epoch + (m / 1000);\n    tv-&gt;tv_usec     = (m % 1000) * 1000;\n    return 0;\n}\n\nint __wrap_settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    if (!tv) {\n        errno = EINVAL;\n        return -1;\n    }\n    unsigned long m = millis();\n    reset_epoch     = tv-&gt;tv_sec - (m / 1000);\n    reset_millis    = m;\n    return 0;\n}\n\nint gettimeofday(struct timeval *tv, void *tz) {\n    return __wrap_gettimeofday(tv, tz);\n}\n\nint settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    return __wrap_settimeofday(tv, tz);\n}\n\nint _gettimeofday(struct timeval *tv, void *tz) {\n    return __wrap_gettimeofday(tv, tz);\n}\n\nint _settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    return __wrap_settimeofday(tv, tz);\n}\n</code></pre>"},{"location":"ltapi/dir_7b42ca4cd5530baa6d3cca740865775d/","title":"Dir cores/common/arduino/src/wiring","text":"<p>FileList &gt; arduino &gt; src &gt; wiring</p>"},{"location":"ltapi/dir_7b42ca4cd5530baa6d3cca740865775d/#files","title":"Files","text":"Type Name     file wiring.c    file wiring_compat.cpp    file wiring_compat.h    file wiring_custom.c    file wiring_custom.h    file wiring_irq.c    file wiring_math.cpp    file wiring_private.c    file wiring_private.h    file wiring_shift.c      <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/</code></p>"},{"location":"ltapi/wiring_8c/","title":"File wiring.c","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/wiring_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring.c</code></p>"},{"location":"ltapi/wiring_8c_source/","title":"File wiring.c","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-05-24. */\n\n#include &lt;Arduino.h&gt;\n\n#if LT_HAS_FREERTOS\n\n__attribute__((weak)) void delay(uint32_t ms) {\n    vTaskDelay(pdMS_TO_TICKS(ms));\n}\n\n__attribute__((weak)) void yield() {\n    runPeriodicTasks();\n    vTaskDelay(1);\n    taskYIELD();\n    lt_wdt_feed();\n}\n\n#else\n\n__attribute__((weak)) void yield() {}\n\n#endif\n</code></pre>"},{"location":"ltapi/wiring__compat_8cpp/","title":"File wiring_compat.cpp","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_compat.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"wiring_compat.h\"</code></li> </ul>"},{"location":"ltapi/wiring__compat_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     const String emptyString"},{"location":"ltapi/wiring__compat_8cpp/#public-functions","title":"Public Functions","text":"Type Name     String ipToString (const IPAddress &amp; ip)"},{"location":"ltapi/wiring__compat_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/wiring__compat_8cpp/#variable-emptystring","title":"variable emptyString","text":"<pre><code>const String emptyString;\n</code></pre>"},{"location":"ltapi/wiring__compat_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__compat_8cpp/#function-iptostring","title":"function ipToString","text":"<pre><code>String ipToString (\n    const IPAddress &amp; ip\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_compat.cpp</code></p>"},{"location":"ltapi/wiring__compat_8cpp_source/","title":"File wiring_compat.cpp","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_compat.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#include \"wiring_compat.h\"\n\nString ipToString(const IPAddress &amp;ip) {\n    char szRet[16];\n    sprintf(szRet, \"%hhu.%hhu.%hhu.%hhu\", ip[0], ip[1], ip[2], ip[3]);\n    return String(szRet);\n}\n\n// global empty string to allow returning const String&amp; with nothing\nconst String emptyString;\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/","title":"File wiring_compat.h","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_compat.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__compat_8h/#public-attributes","title":"Public Attributes","text":"Type Name     const String emptyString"},{"location":"ltapi/wiring__compat_8h/#public-functions","title":"Public Functions","text":"Type Name     String ipToString (const IPAddress &amp; ip)"},{"location":"ltapi/wiring__compat_8h/#macros","title":"Macros","text":"Type Name     define CONFIG_LWIP_MAX_ACTIVE_TCP  16   define ESP_FAIL  -1   define ESP_OK  0   define FPSTR (pstr_pointer) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))   define OUTPUT_OPEN_DRAIN  OUTPUT_OPENDRAIN   define PGM_VOID_P  const void *   define attachInterruptArg  attachInterruptParam   define digitalPinToInterrupt (pin) (pin)   define esp_err_t  int   define voidFuncPtrArg  voidFuncPtrParam   define vsnprintf_P  vsnprintf   define xTaskCreatePinnedToCore  xTaskCreateUniversal   define xTaskCreateUniversal (pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, xCoreID)   xTaskCreate(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)"},{"location":"ltapi/wiring__compat_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/wiring__compat_8h/#variable-emptystring","title":"variable emptyString","text":"<pre><code>const String emptyString;\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__compat_8h/#function-iptostring","title":"function ipToString","text":"<pre><code>String ipToString (\n    const IPAddress &amp; ip\n) \n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/wiring__compat_8h/#define-config_lwip_max_active_tcp","title":"define CONFIG_LWIP_MAX_ACTIVE_TCP","text":"<pre><code>#define CONFIG_LWIP_MAX_ACTIVE_TCP 16\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-esp_fail","title":"define ESP_FAIL","text":"<pre><code>#define ESP_FAIL -1\n</code></pre> <p>Generic esp_err_t code indicating failure </p>"},{"location":"ltapi/wiring__compat_8h/#define-esp_ok","title":"define ESP_OK","text":"<pre><code>#define ESP_OK 0\n</code></pre> <p>esp_err_t value indicating success (no error) </p>"},{"location":"ltapi/wiring__compat_8h/#define-fpstr","title":"define FPSTR","text":"<pre><code>#define FPSTR (\n    pstr_pointer\n) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-output_open_drain","title":"define OUTPUT_OPEN_DRAIN","text":"<pre><code>#define OUTPUT_OPEN_DRAIN OUTPUT_OPENDRAIN\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-pgm_void_p","title":"define PGM_VOID_P","text":"<pre><code>#define PGM_VOID_P const void *\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-attachinterruptarg","title":"define attachInterruptArg","text":"<pre><code>#define attachInterruptArg attachInterruptParam\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-digitalpintointerrupt","title":"define digitalPinToInterrupt","text":"<pre><code>#define digitalPinToInterrupt (\n    pin\n) (pin)\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-esp_err_t","title":"define esp_err_t","text":"<pre><code>#define esp_err_t int\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-voidfuncptrarg","title":"define voidFuncPtrArg","text":"<pre><code>#define voidFuncPtrArg voidFuncPtrParam\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-vsnprintf_p","title":"define vsnprintf_P","text":"<pre><code>#define vsnprintf_P vsnprintf\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-xtaskcreatepinnedtocore","title":"define xTaskCreatePinnedToCore","text":"<pre><code>#define xTaskCreatePinnedToCore xTaskCreateUniversal\n</code></pre>"},{"location":"ltapi/wiring__compat_8h/#define-xtaskcreateuniversal","title":"define xTaskCreateUniversal","text":"<pre><code>#define xTaskCreateUniversal (\n    pxTaskCode,\n    pcName,\n    usStackDepth,\n    pvParameters,\n    uxPriority,\n    pxCreatedTask,\n    xCoreID\n) xTaskCreate(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_compat.h</code></p>"},{"location":"ltapi/wiring__compat_8h_source/","title":"File wiring_compat.h","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_compat.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n// Definitions for error constants.\n#define esp_err_t int\n#define ESP_OK    0  \n#define ESP_FAIL  -1 \n// ArduinoCore-API doesn't define these anymore\n#define FPSTR(pstr_pointer) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))\n#define PGM_VOID_P          const void *\n#define vsnprintf_P         vsnprintf\n#define OUTPUT_OPEN_DRAIN   OUTPUT_OPENDRAIN\n#define attachInterruptArg  attachInterruptParam\n#define voidFuncPtrArg      voidFuncPtrParam\n\n// Additional Arduino compatibility macros\n#ifndef __cplusplus\n#define round(x) ((x) &gt;= 0 ? (long)((x) + 0.5) : (long)((x) - 0.5))\n#endif\n#define digitalPinToInterrupt(pin) (pin)\n\n// FreeRTOS utilities\n#define xTaskCreateUniversal(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, xCoreID) \\\n    xTaskCreate(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask)\n#define xTaskCreatePinnedToCore xTaskCreateUniversal\n\n// Default values from sdkconfig.h\n#define CONFIG_LWIP_MAX_ACTIVE_TCP 16\n\n#ifdef __cplusplus\nString ipToString(const IPAddress &amp;ip);\nextern const String emptyString;\n#endif\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/wiring__custom_8c/","title":"File wiring_custom.c","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_custom.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"wiring_private.h\"</code></li> </ul>"},{"location":"ltapi/wiring__custom_8c/#public-attributes","title":"Public Attributes","text":"Type Name     int _analogReadResolution   = = 10   int _analogWritePeriod   = = 20000   int _analogWriteResolution   = = 8"},{"location":"ltapi/wiring__custom_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     unsigned long periodicTasks   = = {0, 0}"},{"location":"ltapi/wiring__custom_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   PinInfo * pinByGpio (uint32_t gpio) Find PinInfo struct by GPIO number. Returns NULL if not found.   PinInfo * pinByIndex (uint32_t index) Get PinInfo struct for the specified index. Returns NULL if pin index is invalid.   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   uint32_t pinIndex (PinInfo * pin) Get index of PinInfo in the global pin info table.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   void pinModeRemove (pin_size_t pinNumber, uint32_t mask) Disable modes specified by 'mask'.   bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow."},{"location":"ltapi/wiring__custom_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/wiring__custom_8c/#variable-_analogreadresolution","title":"variable _analogReadResolution","text":"<pre><code>int _analogReadResolution;\n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#variable-_analogwriteperiod","title":"variable _analogWritePeriod","text":"<pre><code>int _analogWritePeriod;\n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#variable-_analogwriteresolution","title":"variable _analogWriteResolution","text":"<pre><code>int _analogWriteResolution;\n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/wiring__custom_8c/#variable-periodictasks","title":"variable periodicTasks","text":"<pre><code>unsigned long periodicTasks[];\n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__custom_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-analogread","title":"function analogRead","text":"<pre><code>int analogRead (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-analogreadresolution","title":"function analogReadResolution","text":"<pre><code>void analogReadResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-analogwritefrequency","title":"function analogWriteFrequency","text":"<pre><code>void analogWriteFrequency (\n    int hz\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-analogwriteperiod","title":"function analogWritePeriod","text":"<pre><code>void analogWritePeriod (\n    int us\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-analogwriteresolution","title":"function analogWriteResolution","text":"<pre><code>void analogWriteResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinbygpio","title":"function pinByGpio","text":"<pre><code>PinInfo * pinByGpio (\n    uint32_t gpio\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinbyindex","title":"function pinByIndex","text":"<pre><code>PinInfo * pinByIndex (\n    uint32_t index\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinenabled","title":"function pinEnabled","text":"<pre><code>bool pinEnabled (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinindex","title":"function pinIndex","text":"<pre><code>uint32_t pinIndex (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pininfo","title":"function pinInfo","text":"<pre><code>PinInfo * pinInfo (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinmoderemove","title":"function pinModeRemove","text":"<pre><code>void pinModeRemove (\n    pin_size_t pinNumber,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-pinsupported","title":"function pinSupported","text":"<pre><code>bool pinSupported (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8c/#function-runperiodictasks","title":"function runPeriodicTasks","text":"<p>Run periodic tasks, like printing free heap or checking millis() overflow. <pre><code>void runPeriodicTasks () \n</code></pre></p> <p>This is called during delaying operations, like yield() or delay(). </p>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_custom.c</code></p>"},{"location":"ltapi/wiring__custom_8c_source/","title":"File wiring_custom.c","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_custom.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-20. */\n\n#include \"wiring_private.h\"\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#endif\n\nint _analogReadResolution  = 10;    // 0-1023\nint _analogWriteResolution = 8;     // 0-255\nint _analogWritePeriod     = 20000; // 50 Hz\n\nstatic unsigned long periodicTasks[] = {0, 0};\n\nvoid runPeriodicTasks() {\n#if LT_LOG_HEAP\n    if (millis() - periodicTasks[0] &gt; 1000) {\n        LT_HEAP_I();\n        periodicTasks[0] = millis();\n    }\n#endif\n#if LT_USE_TIME\n    if (millis() - periodicTasks[1] &gt; 10000) {\n        gettimeofday(NULL, NULL);\n        periodicTasks[1] = millis();\n    }\n#endif\n}\n\nvoid pinModeRemove(pin_size_t pinNumber, uint32_t mask) {\n    PinInfo *pin = pinInfo(pinNumber);\n    if (!pin)\n        return;\n    pinRemoveMode(pin, mask);\n    if (pin-&gt;enabled == PIN_NONE &amp;&amp; mask == PIN_MODE_ALL)\n        pinRemoveData(pin);\n}\n\nPinInfo *pinInfo(pin_size_t pinNumber) {\n    if (pinNumber &lt; 0 || pinNumber &gt; PINS_GPIO_MAX)\n        return NULL;\n    return lt_arduino_pin_gpio_map[pinNumber];\n}\n\nPinInfo *pinByIndex(uint32_t index) {\n    if (index &lt; 0 || index &gt;= PINS_COUNT)\n        return NULL;\n    return &amp;(lt_arduino_pin_info_list[index]);\n}\n\nPinInfo *pinByGpio(uint32_t gpio) {\n    for (uint32_t i = 0; i &lt; PINS_COUNT; i++) {\n        if (lt_arduino_pin_info_list[i].gpio == gpio)\n            return &amp;(lt_arduino_pin_info_list[i]);\n    }\n    return NULL;\n}\n\nuint32_t pinIndex(PinInfo *pin) {\n    return pin - lt_arduino_pin_info_list;\n}\n\nbool pinSupported(PinInfo *pin, uint32_t mask) {\n    return (pin-&gt;supported &amp; mask) == mask;\n}\n\nbool pinEnabled(PinInfo *pin, uint32_t mask) {\n    return (pin-&gt;enabled &amp; mask) == mask;\n}\n\nint analogRead(pin_size_t pinNumber) {\n    float voltage    = analogReadVoltage(pinNumber);\n    float maxVoltage = analogReadMaxVoltage(pinNumber);\n    uint16_t ret     = round((1 &lt;&lt; _analogReadResolution) * voltage / maxVoltage);\n    if (ret &gt;= (1 &lt;&lt; _analogReadResolution))\n        ret = (1 &lt;&lt; _analogReadResolution) - 1;\n    return ret;\n}\n\nvoid analogReadResolution(int res) {\n    _analogReadResolution = res;\n}\n\nvoid analogWriteResolution(int res) {\n    _analogWriteResolution = res;\n}\n\nvoid analogWriteFrequency(int hz) {\n    _analogWritePeriod = 1E6 / hz;\n}\n\nvoid analogWritePeriod(int us) {\n    _analogWritePeriod = us;\n}\n\n__attribute__((weak)) void analogReference(uint8_t mode) {}\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/","title":"File wiring_custom.h","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_custom.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__custom_8h/#classes","title":"Classes","text":"Type Name     struct PinInfo"},{"location":"ltapi/wiring__custom_8h/#public-types","title":"Public Types","text":"Type Name     typedef struct PinData_s PinData"},{"location":"ltapi/wiring__custom_8h/#public-attributes","title":"Public Attributes","text":"Type Name     int _analogReadResolution    int _analogWritePeriod    int _analogWriteResolution    PinInfo * lt_arduino_pin_gpio_map    PinInfo lt_arduino_pin_info_list"},{"location":"ltapi/wiring__custom_8h/#public-functions","title":"Public Functions","text":"Type Name     int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   uint16_t analogReadMaxVoltage (pin_size_t pinNumber) Get max reading voltage for the specified pin (millivolts).   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   uint16_t analogReadVoltage (pin_size_t pinNumber) Read voltage from analog input (in millivolts).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly.   PinInfo * pinByGpio (uint32_t gpio) Find PinInfo struct by GPIO number. Returns NULL if not found.   PinInfo * pinByIndex (uint32_t index) Get PinInfo struct for the specified index. Returns NULL if pin index is invalid.   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   uint32_t pinIndex (PinInfo * pin) Get index of PinInfo in the global pin info table.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   void pinModeNone (pin_size_t pinNumber) Deinitialize the pin, by removing all enabled modes.   void pinModeRemove (pin_size_t pinNumber, uint32_t mask) Disable modes specified by 'mask'.   void pinRemoveMode (PinInfo * pin, uint32_t mask)    bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow.   bool startMainTask (void) Run mainTask &amp; start OS kernel (family-defined). Return false if an error occured; else do not return and and keep the OS kernel running."},{"location":"ltapi/wiring__custom_8h/#macros","title":"Macros","text":"Type Name     define PIN_ADC  (1 &lt;&lt; 4)   define PIN_DAC  (1 &lt;&lt; 5)   define PIN_GPIO  (1 &lt;&lt; 1)   define PIN_I2C  (1 &lt;&lt; 6)   define PIN_I2S  (1 &lt;&lt; 7)   define PIN_IRQ  (1 &lt;&lt; 2)   define PIN_JTAG  (1 &lt;&lt; 8)   define PIN_MODE_ALL  0xFFFFFFFF   define PIN_NONE  (1 &lt;&lt; 0)   define PIN_PWM  (1 &lt;&lt; 3)   define PIN_SPI  (1 &lt;&lt; 9)   define PIN_SWD  (1 &lt;&lt; 10)   define PIN_UART  (1 &lt;&lt; 11)"},{"location":"ltapi/wiring__custom_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/wiring__custom_8h/#typedef-pindata","title":"typedef PinData","text":"<pre><code>typedef struct PinData_s PinData;\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/wiring__custom_8h/#variable-_analogreadresolution","title":"variable _analogReadResolution","text":"<pre><code>int _analogReadResolution;\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#variable-_analogwriteperiod","title":"variable _analogWritePeriod","text":"<pre><code>int _analogWritePeriod;\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#variable-_analogwriteresolution","title":"variable _analogWriteResolution","text":"<pre><code>int _analogWriteResolution;\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#variable-lt_arduino_pin_gpio_map","title":"variable lt_arduino_pin_gpio_map","text":"<pre><code>PinInfo* lt_arduino_pin_gpio_map[PINS_GPIO_MAX+1];\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#variable-lt_arduino_pin_info_list","title":"variable lt_arduino_pin_info_list","text":"<pre><code>PinInfo lt_arduino_pin_info_list[PINS_COUNT];\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__custom_8h/#function-analogread","title":"function analogRead","text":"<pre><code>int analogRead (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogreadmaxvoltage","title":"function analogReadMaxVoltage","text":"<pre><code>uint16_t analogReadMaxVoltage (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogreadresolution","title":"function analogReadResolution","text":"<pre><code>void analogReadResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogreadvoltage","title":"function analogReadVoltage","text":"<pre><code>uint16_t analogReadVoltage (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogwritefrequency","title":"function analogWriteFrequency","text":"<pre><code>void analogWriteFrequency (\n    int hz\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogwriteperiod","title":"function analogWritePeriod","text":"<pre><code>void analogWritePeriod (\n    int us\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-analogwriteresolution","title":"function analogWriteResolution","text":"<pre><code>void analogWriteResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-maintask","title":"function mainTask","text":"<pre><code>void mainTask (\n    const void * arg\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinbygpio","title":"function pinByGpio","text":"<pre><code>PinInfo * pinByGpio (\n    uint32_t gpio\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinbyindex","title":"function pinByIndex","text":"<pre><code>PinInfo * pinByIndex (\n    uint32_t index\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinenabled","title":"function pinEnabled","text":"<pre><code>bool pinEnabled (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinindex","title":"function pinIndex","text":"<pre><code>uint32_t pinIndex (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pininfo","title":"function pinInfo","text":"<pre><code>PinInfo * pinInfo (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinmodenone","title":"function pinModeNone","text":"<pre><code>inline void pinModeNone (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinmoderemove","title":"function pinModeRemove","text":"<pre><code>void pinModeRemove (\n    pin_size_t pinNumber,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinremovemode","title":"function pinRemoveMode","text":"<pre><code>void pinRemoveMode (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-pinsupported","title":"function pinSupported","text":"<pre><code>bool pinSupported (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#function-runperiodictasks","title":"function runPeriodicTasks","text":"<p>Run periodic tasks, like printing free heap or checking millis() overflow. <pre><code>void runPeriodicTasks () \n</code></pre></p> <p>This is called during delaying operations, like yield() or delay(). </p>"},{"location":"ltapi/wiring__custom_8h/#function-startmaintask","title":"function startMainTask","text":"<pre><code>bool startMainTask (\n    void\n) \n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/wiring__custom_8h/#define-pin_adc","title":"define PIN_ADC","text":"<pre><code>#define PIN_ADC (1 &lt;&lt; 4)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_dac","title":"define PIN_DAC","text":"<pre><code>#define PIN_DAC (1 &lt;&lt; 5)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_gpio","title":"define PIN_GPIO","text":"<pre><code>#define PIN_GPIO (1 &lt;&lt; 1)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_i2c","title":"define PIN_I2C","text":"<pre><code>#define PIN_I2C (1 &lt;&lt; 6)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_i2s","title":"define PIN_I2S","text":"<pre><code>#define PIN_I2S (1 &lt;&lt; 7)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_irq","title":"define PIN_IRQ","text":"<pre><code>#define PIN_IRQ (1 &lt;&lt; 2)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_jtag","title":"define PIN_JTAG","text":"<pre><code>#define PIN_JTAG (1 &lt;&lt; 8)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_mode_all","title":"define PIN_MODE_ALL","text":"<pre><code>#define PIN_MODE_ALL 0xFFFFFFFF\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_none","title":"define PIN_NONE","text":"<pre><code>#define PIN_NONE (1 &lt;&lt; 0)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_pwm","title":"define PIN_PWM","text":"<pre><code>#define PIN_PWM (1 &lt;&lt; 3)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_spi","title":"define PIN_SPI","text":"<pre><code>#define PIN_SPI (1 &lt;&lt; 9)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_swd","title":"define PIN_SWD","text":"<pre><code>#define PIN_SWD (1 &lt;&lt; 10)\n</code></pre>"},{"location":"ltapi/wiring__custom_8h/#define-pin_uart","title":"define PIN_UART","text":"<pre><code>#define PIN_UART (1 &lt;&lt; 11)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_custom.h</code></p>"},{"location":"ltapi/wiring__custom_8h_source/","title":"File wiring_custom.h","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_custom.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-06. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PIN_NONE (1 &lt;&lt; 0)\n#define PIN_GPIO (1 &lt;&lt; 1)\n#define PIN_IRQ  (1 &lt;&lt; 2)\n#define PIN_PWM  (1 &lt;&lt; 3)\n#define PIN_ADC  (1 &lt;&lt; 4)\n#define PIN_DAC  (1 &lt;&lt; 5)\n#define PIN_I2C  (1 &lt;&lt; 6)\n#define PIN_I2S  (1 &lt;&lt; 7)\n#define PIN_JTAG (1 &lt;&lt; 8)\n#define PIN_SPI  (1 &lt;&lt; 9)\n#define PIN_SWD  (1 &lt;&lt; 10)\n#define PIN_UART (1 &lt;&lt; 11)\n\n#define PIN_MODE_ALL 0xFFFFFFFF\n\ntypedef struct PinData_s PinData;\n\ntypedef struct {\n    uint32_t gpio;\n    uint32_t supported;\n    uint32_t enabled;\n    PinData *data;\n} PinInfo;\n\nextern PinInfo lt_arduino_pin_info_list[PINS_COUNT];\nextern PinInfo *lt_arduino_pin_gpio_map[PINS_GPIO_MAX + 1];\n\n// Custom Wiring methods\n\nbool startMainTask(void);\n\nvoid mainTask(const void *arg); // implemented in main.cpp\nvoid runPeriodicTasks();        // implemented in wiring_custom.c\n\nvoid pinModeRemove(pin_size_t pinNumber, uint32_t mask);\nPinInfo *pinInfo(pin_size_t pinNumber);\nPinInfo *pinByIndex(uint32_t index);\nPinInfo *pinByGpio(uint32_t gpio);\nuint32_t pinIndex(PinInfo *pin);\nbool pinSupported(PinInfo *pin, uint32_t mask);\nbool pinEnabled(PinInfo *pin, uint32_t mask);\nvoid pinRemoveMode(PinInfo *pin, uint32_t mask);\n\ninline void pinModeNone(pin_size_t pinNumber) {\n    pinModeRemove(pinNumber, PIN_MODE_ALL);\n}\n\nint analogRead(pin_size_t pinNumber);\nvoid analogReadResolution(int res);\nvoid analogWriteResolution(int res);\nvoid analogWriteFrequency(int hz);\nvoid analogWritePeriod(int us);\n\nextern int _analogReadResolution;\nextern int _analogWriteResolution;\nextern int _analogWritePeriod;\n\nuint16_t analogReadVoltage(pin_size_t pinNumber);\n\nuint16_t analogReadMaxVoltage(pin_size_t pinNumber);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/wiring__irq_8c/","title":"File wiring_irq.c","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_irq.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__irq_8c/#public-functions","title":"Public Functions","text":"Type Name     void attachInterrupt (pin_size_t interruptNumber, voidFuncPtr callback, PinStatus mode)"},{"location":"ltapi/wiring__irq_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__irq_8c/#function-attachinterrupt","title":"function attachInterrupt","text":"<pre><code>void attachInterrupt (\n    pin_size_t interruptNumber,\n    voidFuncPtr callback,\n    PinStatus mode\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_irq.c</code></p>"},{"location":"ltapi/wiring__irq_8c_source/","title":"File wiring_irq.c","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_irq.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-05-24. */\n\n#include &lt;Arduino.h&gt;\n\nvoid attachInterrupt(pin_size_t interruptNumber, voidFuncPtr callback, PinStatus mode) {\n    attachInterruptParam(interruptNumber, (voidFuncPtrParam)callback, mode, NULL);\n}\n</code></pre>"},{"location":"ltapi/wiring__math_8cpp/","title":"File wiring_math.cpp","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_math.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__math_8cpp/#public-functions","title":"Public Functions","text":"Type Name     long random (long howbig)    long random (long howsmall, long howbig)    void randomSeed (uint32_t dwSeed)"},{"location":"ltapi/wiring__math_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__math_8cpp/#function-random","title":"function random","text":"<pre><code>long random (\n    long howbig\n) \n</code></pre>"},{"location":"ltapi/wiring__math_8cpp/#function-random_1","title":"function random","text":"<pre><code>long random (\n    long howsmall,\n    long howbig\n) \n</code></pre>"},{"location":"ltapi/wiring__math_8cpp/#function-randomseed","title":"function randomSeed","text":"<pre><code>void randomSeed (\n    uint32_t dwSeed\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_math.cpp</code></p>"},{"location":"ltapi/wiring__math_8cpp_source/","title":"File wiring_math.cpp","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_math.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n\nvoid randomSeed(uint32_t dwSeed) {\n    if (dwSeed != 0) {\n        srand(dwSeed);\n    }\n}\n\nlong random(long howbig) {\n    if (howbig == 0) {\n        return 0;\n    }\n\n    return rand() % howbig;\n}\n\nlong random(long howsmall, long howbig) {\n    if (howsmall &gt;= howbig) {\n        return howsmall;\n    }\n\n    long diff = howbig - howsmall;\n\n    return random(diff) + howsmall;\n}\n</code></pre>"},{"location":"ltapi/wiring__private_8c/","title":"File wiring_private.c","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_private.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"wiring_private.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_private.c</code></p>"},{"location":"ltapi/wiring__private_8c_source/","title":"File wiring_private.c","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_private.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-05-24. */\n\n#include \"wiring_private.h\"\n\n#if __has_include(&lt;wiring_data.h&gt;)\nPinData *pinData(PinInfo *pin) {\n    if (pin-&gt;data == NULL) {\n        pin-&gt;data = calloc(1, sizeof(PinData));\n    }\n    return (PinData *)pin-&gt;data;\n}\n\nvoid pinRemoveData(PinInfo *pin) {\n    if (pin-&gt;data != NULL) {\n        free(pin-&gt;data);\n    }\n    pin-&gt;data = NULL;\n}\n#endif\n</code></pre>"},{"location":"ltapi/wiring__private_8h/","title":"File wiring_private.h","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_private.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__private_8h/#public-functions","title":"Public Functions","text":"Type Name     PinData * pinData (PinInfo * pin)    void pinDisable (PinInfo * pin, uint32_t mask)    void pinEnable (PinInfo * pin, uint32_t mask)    void pinRemoveData (PinInfo * pin)"},{"location":"ltapi/wiring__private_8h/#macros","title":"Macros","text":"Type Name     define pinCheckGetData (pinNumber, mask, ret)    define pinCheckGetInfo (pinNumber, mask, ret)    define pinIsInput (pin, data) (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &gt; 4)   define pinIsOutput (pin, data) (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &lt; 5)   define pinSetInputMode (pin, data, pinNumber)    define pinSetOutputPull (pin, data, pinNumber, status)"},{"location":"ltapi/wiring__private_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__private_8h/#function-pindata","title":"function pinData","text":"<pre><code>PinData * pinData (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/wiring__private_8h/#function-pindisable","title":"function pinDisable","text":"<pre><code>inline void pinDisable (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__private_8h/#function-pinenable","title":"function pinEnable","text":"<pre><code>inline void pinEnable (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/wiring__private_8h/#function-pinremovedata","title":"function pinRemoveData","text":"<pre><code>void pinRemoveData (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/wiring__private_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/wiring__private_8h/#define-pincheckgetdata","title":"define pinCheckGetData","text":"<pre><code>#define pinCheckGetData (\n    pinNumber,\n    mask,\n    ret\n) PinInfo *pin = pinInfo(pinNumber);        \\\n    if (!pin)                                 \\\n        return ret;                           \\\n    if (!pinSupported(pin, mask))             \\\n        return ret;                           \\\n    PinData *data = pinData(pin);\n</code></pre>"},{"location":"ltapi/wiring__private_8h/#define-pincheckgetinfo","title":"define pinCheckGetInfo","text":"<pre><code>#define pinCheckGetInfo (\n    pinNumber,\n    mask,\n    ret\n) PinInfo *pin = pinInfo(pinNumber);        \\\n    if (!pin)                                 \\\n        return ret;                           \\\n    if (!pinSupported(pin, mask))             \\\n        return ret;\n</code></pre>"},{"location":"ltapi/wiring__private_8h/#define-pinisinput","title":"define pinIsInput","text":"<pre><code>#define pinIsInput (\n    pin,\n    data\n) (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &gt; 4)\n</code></pre>"},{"location":"ltapi/wiring__private_8h/#define-pinisoutput","title":"define pinIsOutput","text":"<pre><code>#define pinIsOutput (\n    pin,\n    data\n) (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &lt; 5)\n</code></pre>"},{"location":"ltapi/wiring__private_8h/#define-pinsetinputmode","title":"define pinSetInputMode","text":"<pre><code>#define pinSetInputMode (\n    pin,\n    data,\n    pinNumber\n) do {                                      \\\n        if (!pinIsInput(pin, data))           \\\n            pinMode(pinNumber, INPUT);        \\\n    } while (0);\n</code></pre>"},{"location":"ltapi/wiring__private_8h/#define-pinsetoutputpull","title":"define pinSetOutputPull","text":"<pre><code>#define pinSetOutputPull (\n    pin,\n    data,\n    pinNumber,\n    status\n) do {                                                   \\\n        if (!pinIsOutput(pin, data)) {                     \\\n            pinMode(pinNumber, INPUT_PULLDOWN ^ !!status); \\\n            return;                                        \\\n        }                                                  \\\n    } while (0);\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_private.h</code></p>"},{"location":"ltapi/wiring__private_8h_source/","title":"File wiring_private.h","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_private.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-05-24. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#if __has_include(&lt;sdk_private.h&gt;)\n#include &lt;sdk_private.h&gt;\n#endif\n\n#if __has_include(&lt;wiring_data.h&gt;)\n#include &lt;wiring_data.h&gt;\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPinData *pinData(PinInfo *pin);\nvoid pinRemoveData(PinInfo *pin);\n\ninline void pinEnable(PinInfo *pin, uint32_t mask) {\n    pin-&gt;enabled |= mask;\n}\n\ninline void pinDisable(PinInfo *pin, uint32_t mask) {\n    pin-&gt;enabled &amp;= ~mask;\n}\n\n#define pinCheckGetInfo(pinNumber, mask, ret) \\\n    PinInfo *pin = pinInfo(pinNumber);        \\\n    if (!pin)                                 \\\n        return ret;                           \\\n    if (!pinSupported(pin, mask))             \\\n        return ret;\n\n#define pinCheckGetData(pinNumber, mask, ret) \\\n    PinInfo *pin = pinInfo(pinNumber);        \\\n    if (!pin)                                 \\\n        return ret;                           \\\n    if (!pinSupported(pin, mask))             \\\n        return ret;                           \\\n    PinData *data = pinData(pin);\n\n#define pinIsOutput(pin, data) (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &lt; 5)\n#define pinIsInput(pin, data)  (pinEnabled(pin, PIN_GPIO) &amp;&amp; (data-&gt;gpioMode ^ 0b101) &gt; 4)\n\n#define pinSetOutputPull(pin, data, pinNumber, status)     \\\n    do {                                                   \\\n        if (!pinIsOutput(pin, data)) {                     \\\n            pinMode(pinNumber, INPUT_PULLDOWN ^ !!status); \\\n            return;                                        \\\n        }                                                  \\\n    } while (0);\n\n#define pinSetInputMode(pin, data, pinNumber) \\\n    do {                                      \\\n        if (!pinIsInput(pin, data))           \\\n            pinMode(pinNumber, INPUT);        \\\n    } while (0);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/wiring__shift_8c/","title":"File wiring_shift.c","text":"<p>FileList &gt; arduino &gt; src &gt; wiring &gt; wiring_shift.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__shift_8c/#public-functions","title":"Public Functions","text":"Type Name     uint8_t shiftIn (pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder)    void shiftOut (pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder, uint8_t ulVal)"},{"location":"ltapi/wiring__shift_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__shift_8c/#function-shiftin","title":"function shiftIn","text":"<pre><code>uint8_t shiftIn (\n    pin_size_t ulDataPin,\n    pin_size_t ulClockPin,\n    BitOrder ulBitOrder\n) \n</code></pre>"},{"location":"ltapi/wiring__shift_8c/#function-shiftout","title":"function shiftOut","text":"<pre><code>void shiftOut (\n    pin_size_t ulDataPin,\n    pin_size_t ulClockPin,\n    BitOrder ulBitOrder,\n    uint8_t ulVal\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/wiring/wiring_shift.c</code></p>"},{"location":"ltapi/wiring__shift_8c_source/","title":"File wiring_shift.c","text":"<p>File List &gt; arduino &gt; src &gt; wiring &gt; wiring_shift.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n#include &lt;stdint.h&gt;\n\nuint8_t shiftIn(pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder) {\n    uint8_t value = 0;\n    uint8_t i;\n\n    for (i = 0; i &lt; 8; ++i) {\n        digitalWrite(ulClockPin, HIGH);\n\n        if (ulBitOrder == LSBFIRST) {\n            value |= digitalRead(ulDataPin) &lt;&lt; i;\n        } else {\n            value |= digitalRead(ulDataPin) &lt;&lt; (7 - i);\n        }\n\n        digitalWrite(ulClockPin, LOW);\n    }\n\n    return value;\n}\n\nvoid shiftOut(pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder, uint8_t ulVal) {\n    uint8_t i;\n\n    for (i = 0; i &lt; 8; i++) {\n        if (ulBitOrder == LSBFIRST) {\n            digitalWrite(ulDataPin, !!(ulVal &amp; (1 &lt;&lt; i)));\n        } else {\n            digitalWrite(ulDataPin, !!(ulVal &amp; (1 &lt;&lt; (7 - i))));\n        }\n\n        digitalWrite(ulClockPin, HIGH);\n        digitalWrite(ulClockPin, LOW);\n    }\n}\n</code></pre>"},{"location":"ltapi/main_8c/","title":"File main.c","text":"<p>FileList &gt; arduino &gt; src &gt; main.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/main_8c/#public-functions","title":"Public Functions","text":"Type Name     int main ()    void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly."},{"location":"ltapi/main_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/main_8c/#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre>"},{"location":"ltapi/main_8c/#function-maintask","title":"function mainTask","text":"<pre><code>void mainTask (\n    const void * arg\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/arduino/src/main.c</code></p>"},{"location":"ltapi/main_8c_source/","title":"File main.c","text":"<p>File List &gt; arduino &gt; src &gt; main.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-02-27. */\n\n#include &lt;Arduino.h&gt;\n\nint main() {\n    // initialize Arduino framework\n    lt_init_arduino();\n    // start the main task and OS kernel\n    if (!startMainTask()) {\n        LT_F(\"Couldn't start the main task\");\n        return 1;\n    }\n    return 0;\n}\n\nvoid mainTask(const void *arg) {\n    setup();\n\n    for (;;) {\n        loop();\n        yield();\n    }\n}\n</code></pre>"},{"location":"ltapi/dir_715308b29b364e222d2654a6be231c22/","title":"Dir cores/common/base","text":"<p>FileList &gt; base</p>"},{"location":"ltapi/dir_715308b29b364e222d2654a6be231c22/#files","title":"Files","text":"Type Name     file libretiny.h    file lt_api.h    file lt_config.h    file lt_logger.c    file lt_logger.h    file lt_main.c    file lt_pins.h    file lt_posix_api.h    file lt_types.h"},{"location":"ltapi/dir_715308b29b364e222d2654a6be231c22/#directories","title":"Directories","text":"Type Name     dir api    dir compat    dir config    dir fixups    dir posix    dir wraps      <p>The documentation for this class was generated from the following file <code>cores/common/base/</code></p>"},{"location":"ltapi/dir_c7e317b16142bccc961a83c0babf0065/","title":"Dir cores/common/base/api","text":"<p>FileList &gt; api</p>"},{"location":"ltapi/dir_c7e317b16142bccc961a83c0babf0065/#files","title":"Files","text":"Type Name     file lt_cpu.c    file lt_cpu.h    file lt_device.c    file lt_device.h    file lt_flash.c    file lt_flash.h    file lt_init.h    file lt_mem.c    file lt_mem.h    file lt_ota.c    file lt_ota.h    file lt_sleep.c    file lt_sleep.h    file lt_utils.c    file lt_utils.h    file lt_wdt.c    file lt_wdt.h      <p>The documentation for this class was generated from the following file <code>cores/common/base/api/</code></p>"},{"location":"ltapi/lt__cpu_8c/","title":"File lt_cpu.c","text":"<p>FileList &gt; api &gt; lt_cpu.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_cpu.h\"</code></li> </ul>"},{"location":"ltapi/lt__cpu_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    lt_cpu_family_t lt_cpu_get_family () Get CPU family ID (as lt_cpu_family_t enum member).   const char * lt_cpu_get_family_name () Get CPU family name as string.   uint32_t lt_cpu_get_freq_mhz () Get CPU frequency in MHz.   const char * lt_cpu_get_model_code () Get CPU model name as string (lowercase).   const char * lt_cpu_get_model_name () Get CPU model name as string (uppercase)."},{"location":"ltapi/lt__cpu_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__cpu_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/lt__cpu_8c/#function-lt_cpu_get_family","title":"function lt_cpu_get_family","text":"<pre><code>lt_cpu_family_t lt_cpu_get_family () \n</code></pre>"},{"location":"ltapi/lt__cpu_8c/#function-lt_cpu_get_family_name","title":"function lt_cpu_get_family_name","text":"<pre><code>const char * lt_cpu_get_family_name () \n</code></pre>"},{"location":"ltapi/lt__cpu_8c/#function-lt_cpu_get_freq_mhz","title":"function lt_cpu_get_freq_mhz","text":"<pre><code>uint32_t lt_cpu_get_freq_mhz () \n</code></pre>"},{"location":"ltapi/lt__cpu_8c/#function-lt_cpu_get_model_code","title":"function lt_cpu_get_model_code","text":"<pre><code>const char * lt_cpu_get_model_code () \n</code></pre>"},{"location":"ltapi/lt__cpu_8c/#function-lt_cpu_get_model_name","title":"function lt_cpu_get_model_name","text":"<pre><code>const char * lt_cpu_get_model_name () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_cpu.c</code></p>"},{"location":"ltapi/lt__cpu_8c_source/","title":"File lt_cpu.c","text":"<p>File List &gt; api &gt; lt_cpu.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_cpu.h\"\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n#endif\n\nlt_cpu_family_t lt_cpu_get_family() {\n    return FAMILY;\n}\n\nconst char *lt_cpu_get_family_name() {\n    return STRINGIFY_MACRO(FAMILY) + 2;\n}\n\n__attribute__((weak)) lt_cpu_model_t lt_cpu_get_model() {\n    return MCU;\n}\n\nconst char *lt_cpu_get_model_name() {\n    return STRINGIFY_MACRO(MCU);\n}\n\nconst char *lt_cpu_get_model_code() {\n    return STRINGIFY_MACRO(MCULC);\n}\n\n__attribute__((weak)) uint32_t lt_cpu_get_unique_id() {\n    return lt_cpu_get_mac_id();\n}\n\n__attribute__((weak)) uint32_t lt_cpu_get_mac_id() {\n    uint8_t mac[6];\n    lt_get_device_mac(mac);\n    return (mac[3] &lt;&lt; 0) | (mac[4] &lt;&lt; 8) | (mac[5] &lt;&lt; 16);\n}\n\n__attribute__((weak)) uint8_t lt_cpu_get_core_count() {\n    return 1;\n}\n\n#if LT_HAS_FREERTOS\n__attribute__((weak)) uint32_t lt_cpu_get_freq() {\n    return configCPU_CLOCK_HZ;\n}\n#endif\n\nuint32_t lt_cpu_get_freq_mhz() {\n    return lt_cpu_get_freq() / 1000000;\n}\n\n#if LT_HAS_FREERTOS\n__attribute__((weak)) uint32_t lt_cpu_get_cycle_count() {\n    return xTaskGetTickCount() * (configCPU_CLOCK_HZ / configTICK_RATE_HZ);\n}\n#endif\n</code></pre>"},{"location":"ltapi/lt__cpu_8h/","title":"File lt_cpu.h","text":"<p>FileList &gt; api &gt; lt_cpu.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__cpu_8h/#public-functions","title":"Public Functions","text":"Type Name     uint8_t lt_cpu_get_core_count () Get CPU core count.   const char * lt_cpu_get_core_type () Get CPU core type name as string.   uint32_t lt_cpu_get_cycle_count () Get CPU cycle count.   lt_cpu_family_t lt_cpu_get_family () Get CPU family ID (as lt_cpu_family_t enum member).   const char * lt_cpu_get_family_name () Get CPU family name as string.   uint32_t lt_cpu_get_freq () Get CPU frequency in Hz.   uint32_t lt_cpu_get_freq_mhz () Get CPU frequency in MHz.   uint32_t lt_cpu_get_mac_id () Get CPU ID based on the last three octets of MAC address. Note: the number is 24-bit (with the MSB being zero). The 3rd-to-last octet is least-significant, the last octet is most-significant.   lt_cpu_model_t lt_cpu_get_model () Get CPU model ID (as lt_cpu_model_t enum member).   const char * lt_cpu_get_model_code () Get CPU model name as string (lowercase).   const char * lt_cpu_get_model_name () Get CPU model name as string (uppercase).   uint32_t lt_cpu_get_unique_id () Get CPU unique ID. This may be based on MAC, eFuse, etc. (family-specific). Note: the number is 24-bit (with the MSB being zero)."},{"location":"ltapi/lt__cpu_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_core_count","title":"function lt_cpu_get_core_count","text":"<pre><code>uint8_t lt_cpu_get_core_count () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_core_type","title":"function lt_cpu_get_core_type","text":"<pre><code>const char * lt_cpu_get_core_type () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_cycle_count","title":"function lt_cpu_get_cycle_count","text":"<pre><code>uint32_t lt_cpu_get_cycle_count () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_family","title":"function lt_cpu_get_family","text":"<pre><code>lt_cpu_family_t lt_cpu_get_family () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_family_name","title":"function lt_cpu_get_family_name","text":"<pre><code>const char * lt_cpu_get_family_name () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_freq","title":"function lt_cpu_get_freq","text":"<pre><code>uint32_t lt_cpu_get_freq () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_freq_mhz","title":"function lt_cpu_get_freq_mhz","text":"<pre><code>uint32_t lt_cpu_get_freq_mhz () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_mac_id","title":"function lt_cpu_get_mac_id","text":"<pre><code>uint32_t lt_cpu_get_mac_id () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_model","title":"function lt_cpu_get_model","text":"<pre><code>lt_cpu_model_t lt_cpu_get_model () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_model_code","title":"function lt_cpu_get_model_code","text":"<pre><code>const char * lt_cpu_get_model_code () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_model_name","title":"function lt_cpu_get_model_name","text":"<pre><code>const char * lt_cpu_get_model_name () \n</code></pre>"},{"location":"ltapi/lt__cpu_8h/#function-lt_cpu_get_unique_id","title":"function lt_cpu_get_unique_id","text":"<pre><code>uint32_t lt_cpu_get_unique_id () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_cpu.h</code></p>"},{"location":"ltapi/lt__cpu_8h_source/","title":"File lt_cpu.h","text":"<p>File List &gt; api &gt; lt_cpu.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\nlt_cpu_family_t lt_cpu_get_family();\n\nconst char *lt_cpu_get_family_name();\n\nlt_cpu_model_t lt_cpu_get_model();\n\nconst char *lt_cpu_get_model_name();\n\nconst char *lt_cpu_get_model_code();\n\nuint32_t lt_cpu_get_unique_id();\n\nuint32_t lt_cpu_get_mac_id();\n\nuint8_t lt_cpu_get_core_count();\n\nconst char *lt_cpu_get_core_type();\n\nuint32_t lt_cpu_get_freq();\n\nuint32_t lt_cpu_get_freq_mhz();\n\nuint32_t lt_cpu_get_cycle_count();\n</code></pre>"},{"location":"ltapi/lt__device_8c/","title":"File lt_device.c","text":"<p>FileList &gt; api &gt; lt_device.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_device.h\"</code></li> </ul>"},{"location":"ltapi/lt__device_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     char * device_name   = = NULL"},{"location":"ltapi/lt__device_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    const char * lt_get_board_code () Get board code.   const char * lt_get_device_name () Get device friendly name in format \"LT-&lt;chip model&gt;-&lt;MAC ID&gt;\". Can be used as hostname.   const char * lt_get_reboot_reason_name (lt_reboot_reason_t reason) Get a textual representation of a reboot reason.   const char * lt_get_version () Get LibreTiny version string."},{"location":"ltapi/lt__device_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/lt__device_8c/#variable-device_name","title":"variable device_name","text":"<pre><code>char* device_name;\n</code></pre>"},{"location":"ltapi/lt__device_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__device_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/lt__device_8c/#function-lt_get_board_code","title":"function lt_get_board_code","text":"<pre><code>const char * lt_get_board_code () \n</code></pre>"},{"location":"ltapi/lt__device_8c/#function-lt_get_device_name","title":"function lt_get_device_name","text":"<pre><code>const char * lt_get_device_name () \n</code></pre>"},{"location":"ltapi/lt__device_8c/#function-lt_get_reboot_reason_name","title":"function lt_get_reboot_reason_name","text":"<p>Get a textual representation of a reboot reason. <pre><code>const char * lt_get_reboot_reason_name (\n    lt_reboot_reason_t reason\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, pass 0 to read from lt_reboot_get_reason() </li> </ul>"},{"location":"ltapi/lt__device_8c/#function-lt_get_version","title":"function lt_get_version","text":"<pre><code>const char * lt_get_version () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_device.c</code></p>"},{"location":"ltapi/lt__device_8c_source/","title":"File lt_device.c","text":"<p>File List &gt; api &gt; lt_device.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_device.h\"\n\nstatic char *device_name = NULL;\n\nconst char *lt_get_version() {\n    return LT_VERSION_STR;\n}\n\nconst char *lt_get_board_code() {\n    return LT_BOARD_STR;\n}\n\nconst char *lt_get_device_name() {\n    if (device_name)\n        return device_name;\n    uint32_t chip_id = lt_cpu_get_mac_id();\n    uint8_t *id      = (uint8_t *)&amp;chip_id;\n\n    const char *model = lt_cpu_get_model_code();\n    uint8_t model_len = strlen(model);\n    device_name       = (char *)malloc(3 + model_len + 1 + 6 + 1);\n\n    sprintf(device_name, \"LT-%s-%02x%02x%02x\", model, id[0], id[1], id[2]);\n    return device_name;\n}\n\n__attribute__((weak)) void lt_reboot() {\n    // The Watchdog Way\n    lt_wdt_enable(1L);\n    while (1) {}\n}\n\n__attribute__((weak)) bool lt_reboot_wdt() {\n    if (!lt_wdt_enable(1L))\n        return false;\n    while (1) {}\n}\n\n__attribute__((weak)) bool lt_reboot_download_mode() {\n    return false;\n}\n\n__attribute__((weak)) lt_reboot_reason_t lt_get_reboot_reason() {\n    return REBOOT_REASON_UNKNOWN;\n}\n\nconst char *lt_get_reboot_reason_name(lt_reboot_reason_t reason) {\n    if (!reason)\n        reason = lt_get_reboot_reason();\n    switch (reason) {\n        case REBOOT_REASON_POWER:\n            return \"Power-On\";\n        case REBOOT_REASON_BROWNOUT:\n            return \"Brownout\";\n        case REBOOT_REASON_HARDWARE:\n            return \"HW Reboot\";\n        case REBOOT_REASON_SOFTWARE:\n            return \"SW Reboot\";\n        case REBOOT_REASON_WATCHDOG:\n            return \"WDT Reset\";\n        case REBOOT_REASON_CRASH:\n            return \"Crash\";\n        case REBOOT_REASON_SLEEP_GPIO:\n            return \"Sleep Wakeup (GPIO)\";\n        case REBOOT_REASON_SLEEP_RTC:\n            return \"Sleep Wakeup (RTC)\";\n        case REBOOT_REASON_SLEEP_USB:\n            return \"Sleep Wakeup (USB)\";\n        case REBOOT_REASON_DEBUGGER:\n            return \"Debugger\";\n        default:\n            return \"Unknown\";\n    }\n}\n\n__attribute__((weak)) bool lt_set_debug_mode(lt_debug_mode_t mode) {\n    return false;\n}\n\n__attribute__((weak)) void lt_gpio_recover() {\n    lt_set_debug_mode(DEBUG_MODE_OFF);\n}\n</code></pre>"},{"location":"ltapi/lt__device_8h/","title":"File lt_device.h","text":"<p>FileList &gt; api &gt; lt_device.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__device_8h/#public-types","title":"Public Types","text":"Type Name     enum lt_debug_mode_t Debugging mode enumeration.   enum lt_reboot_reason_t Reset reason enumeration."},{"location":"ltapi/lt__device_8h/#public-functions","title":"Public Functions","text":"Type Name     const char * lt_get_board_code () Get board code.   void lt_get_device_mac (uint8_t * mac) Read device's default MAC address into 'mac' array. This can be used even without Wi-Fi enabled, and will ignore user-changed Wi-Fi MAC (if changing is possible).   const char * lt_get_device_name () Get device friendly name in format \"LT-&lt;chip model&gt;-&lt;MAC ID&gt;\". Can be used as hostname.   lt_reboot_reason_t lt_get_reboot_reason () Get the reason of last chip reboot.   const char * lt_get_reboot_reason_name (lt_reboot_reason_t reason) Get a textual representation of a reboot reason.   const char * lt_get_version () Get LibreTiny version string.   void lt_gpio_recover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   void lt_reboot () Reboot the CPU.   bool lt_reboot_download_mode () Reboot the CPU and stay in download mode (if possible).   bool lt_reboot_wdt () Reboot the CPU with a watchdog timeout (if possible).   bool lt_set_debug_mode (lt_debug_mode_t mode) Set debugger mode (JTAG, SWD or OFF)."},{"location":"ltapi/lt__device_8h/#macros","title":"Macros","text":"Type Name     define REBOOT_REASON_SLEEP  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_BROWNOUT  REBOOT_REASON_BROWNOUT   define RESET_REASON_CRASH  REBOOT_REASON_CRASH   define RESET_REASON_HARDWARE  REBOOT_REASON_HARDWARE   define RESET_REASON_MAX  REBOOT_REASON_MAX   define RESET_REASON_POWER  REBOOT_REASON_POWER   define RESET_REASON_SLEEP  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_SLEEP_GPIO  REBOOT_REASON_SLEEP_GPIO   define RESET_REASON_SLEEP_RTC  REBOOT_REASON_SLEEP_RTC   define RESET_REASON_SLEEP_USB  REBOOT_REASON_SLEEP_USB   define RESET_REASON_SOFTWARE  REBOOT_REASON_SOFTWARE   define RESET_REASON_UNKNOWN  REBOOT_REASON_UNKNOWN   define RESET_REASON_WATCHDOG  REBOOT_REASON_WATCHDOG"},{"location":"ltapi/lt__device_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/lt__device_8h/#enum-lt_debug_mode_t","title":"enum lt_debug_mode_t","text":"<pre><code>enum lt_debug_mode_t {\n    DEBUG_MODE_OFF = 0,\n    DEBUG_MODE_JTAG = 1,\n    DEBUG_MODE_SWD = 2\n};\n</code></pre>"},{"location":"ltapi/lt__device_8h/#enum-lt_reboot_reason_t","title":"enum lt_reboot_reason_t","text":"<pre><code>enum lt_reboot_reason_t {\n    REBOOT_REASON_UNKNOWN = 1,\n    REBOOT_REASON_POWER = 2,\n    REBOOT_REASON_BROWNOUT = 3,\n    REBOOT_REASON_HARDWARE = 4,\n    REBOOT_REASON_SOFTWARE = 5,\n    REBOOT_REASON_WATCHDOG = 6,\n    REBOOT_REASON_CRASH = 7,\n    REBOOT_REASON_SLEEP_GPIO = 8,\n    REBOOT_REASON_SLEEP_RTC = 9,\n    REBOOT_REASON_SLEEP_USB = 10,\n    REBOOT_REASON_DEBUGGER = 11,\n    REBOOT_REASON_MAX = 12\n};\n</code></pre>"},{"location":"ltapi/lt__device_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__device_8h/#function-lt_get_board_code","title":"function lt_get_board_code","text":"<pre><code>const char * lt_get_board_code () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_get_device_mac","title":"function lt_get_device_mac","text":"<pre><code>void lt_get_device_mac (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_get_device_name","title":"function lt_get_device_name","text":"<pre><code>const char * lt_get_device_name () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_get_reboot_reason","title":"function lt_get_reboot_reason","text":"<pre><code>lt_reboot_reason_t lt_get_reboot_reason () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_get_reboot_reason_name","title":"function lt_get_reboot_reason_name","text":"<p>Get a textual representation of a reboot reason. <pre><code>const char * lt_get_reboot_reason_name (\n    lt_reboot_reason_t reason\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, pass 0 to read from lt_reboot_get_reason() </li> </ul>"},{"location":"ltapi/lt__device_8h/#function-lt_get_version","title":"function lt_get_version","text":"<pre><code>const char * lt_get_version () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_gpio_recover","title":"function lt_gpio_recover","text":"<pre><code>void lt_gpio_recover () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_reboot","title":"function lt_reboot","text":"<pre><code>void lt_reboot () \n</code></pre>"},{"location":"ltapi/lt__device_8h/#function-lt_reboot_download_mode","title":"function lt_reboot_download_mode","text":"<p>Reboot the CPU and stay in download mode (if possible). <pre><code>bool lt_reboot_download_mode () \n</code></pre></p> <p>Returns:</p> <p>whether download-mode reboot is possible </p>"},{"location":"ltapi/lt__device_8h/#function-lt_reboot_wdt","title":"function lt_reboot_wdt","text":"<p>Reboot the CPU with a watchdog timeout (if possible). <pre><code>bool lt_reboot_wdt () \n</code></pre></p> <p>Returns:</p> <p>whether WDT reboot is possible </p>"},{"location":"ltapi/lt__device_8h/#function-lt_set_debug_mode","title":"function lt_set_debug_mode","text":"<p>Set debugger mode (JTAG, SWD or OFF). <pre><code>bool lt_set_debug_mode (\n    lt_debug_mode_t mode\n) \n</code></pre></p> <p>Returns:</p> <p>whether the mode is supported, and setting it was successful </p>"},{"location":"ltapi/lt__device_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__device_8h/#define-reboot_reason_sleep","title":"define REBOOT_REASON_SLEEP","text":"<pre><code>#define REBOOT_REASON_SLEEP REBOOT_REASON_SLEEP_GPIO\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_brownout","title":"define RESET_REASON_BROWNOUT","text":"<pre><code>#define RESET_REASON_BROWNOUT REBOOT_REASON_BROWNOUT\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_crash","title":"define RESET_REASON_CRASH","text":"<pre><code>#define RESET_REASON_CRASH REBOOT_REASON_CRASH\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_hardware","title":"define RESET_REASON_HARDWARE","text":"<pre><code>#define RESET_REASON_HARDWARE REBOOT_REASON_HARDWARE\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_max","title":"define RESET_REASON_MAX","text":"<pre><code>#define RESET_REASON_MAX REBOOT_REASON_MAX\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_power","title":"define RESET_REASON_POWER","text":"<pre><code>#define RESET_REASON_POWER REBOOT_REASON_POWER\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_sleep","title":"define RESET_REASON_SLEEP","text":"<pre><code>#define RESET_REASON_SLEEP REBOOT_REASON_SLEEP_GPIO\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_sleep_gpio","title":"define RESET_REASON_SLEEP_GPIO","text":"<pre><code>#define RESET_REASON_SLEEP_GPIO REBOOT_REASON_SLEEP_GPIO\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_sleep_rtc","title":"define RESET_REASON_SLEEP_RTC","text":"<pre><code>#define RESET_REASON_SLEEP_RTC REBOOT_REASON_SLEEP_RTC\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_sleep_usb","title":"define RESET_REASON_SLEEP_USB","text":"<pre><code>#define RESET_REASON_SLEEP_USB REBOOT_REASON_SLEEP_USB\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_software","title":"define RESET_REASON_SOFTWARE","text":"<pre><code>#define RESET_REASON_SOFTWARE REBOOT_REASON_SOFTWARE\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_unknown","title":"define RESET_REASON_UNKNOWN","text":"<pre><code>#define RESET_REASON_UNKNOWN REBOOT_REASON_UNKNOWN\n</code></pre>"},{"location":"ltapi/lt__device_8h/#define-reset_reason_watchdog","title":"define RESET_REASON_WATCHDOG","text":"<pre><code>#define RESET_REASON_WATCHDOG REBOOT_REASON_WATCHDOG\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_device.h</code></p>"},{"location":"ltapi/lt__device_8h_source/","title":"File lt_device.h","text":"<p>File List &gt; api &gt; lt_device.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\n#define RESET_REASON_UNKNOWN    REBOOT_REASON_UNKNOWN\n#define RESET_REASON_POWER      REBOOT_REASON_POWER\n#define RESET_REASON_BROWNOUT   REBOOT_REASON_BROWNOUT\n#define RESET_REASON_HARDWARE   REBOOT_REASON_HARDWARE\n#define RESET_REASON_SOFTWARE   REBOOT_REASON_SOFTWARE\n#define RESET_REASON_WATCHDOG   REBOOT_REASON_WATCHDOG\n#define RESET_REASON_CRASH      REBOOT_REASON_CRASH\n#define RESET_REASON_SLEEP_GPIO REBOOT_REASON_SLEEP_GPIO\n#define RESET_REASON_SLEEP_RTC  REBOOT_REASON_SLEEP_RTC\n#define RESET_REASON_SLEEP_USB  REBOOT_REASON_SLEEP_USB\n#define RESET_REASON_MAX        REBOOT_REASON_MAX\n\ntypedef enum {\n    REBOOT_REASON_UNKNOWN    = 1,\n    REBOOT_REASON_POWER      = 2,\n    REBOOT_REASON_BROWNOUT   = 3,\n    REBOOT_REASON_HARDWARE   = 4,\n    REBOOT_REASON_SOFTWARE   = 5,\n    REBOOT_REASON_WATCHDOG   = 6,\n    REBOOT_REASON_CRASH      = 7,\n    REBOOT_REASON_SLEEP_GPIO = 8,\n    REBOOT_REASON_SLEEP_RTC  = 9,\n    REBOOT_REASON_SLEEP_USB  = 10,\n    REBOOT_REASON_DEBUGGER   = 11,\n    REBOOT_REASON_MAX        = 12,\n} lt_reboot_reason_t;\n\n// RESET_REASON_SLEEP deprecated, kept for compatibility\n#define RESET_REASON_SLEEP  REBOOT_REASON_SLEEP_GPIO\n#define REBOOT_REASON_SLEEP REBOOT_REASON_SLEEP_GPIO\n\ntypedef enum {\n    DEBUG_MODE_OFF  = 0,\n    DEBUG_MODE_JTAG = 1,\n    DEBUG_MODE_SWD  = 2,\n} lt_debug_mode_t;\n\nconst char *lt_get_version();\n\nconst char *lt_get_board_code();\n\nconst char *lt_get_device_name();\n\nvoid lt_get_device_mac(uint8_t *mac);\n\nvoid lt_reboot();\n\nbool lt_reboot_wdt();\n\nbool lt_reboot_download_mode();\n\nlt_reboot_reason_t lt_get_reboot_reason();\n\nconst char *lt_get_reboot_reason_name(lt_reboot_reason_t reason);\n\nbool lt_set_debug_mode(lt_debug_mode_t mode);\n\nvoid lt_gpio_recover();\n</code></pre>"},{"location":"ltapi/lt__flash_8c/","title":"File lt_flash.c","text":"<p>FileList &gt; api &gt; lt_flash.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_flash.h\"</code></li> <li><code>#include &lt;fal.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__flash_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    bool lt_flash_erase (uint32_t offset, size_t length) Erase flash area. Flash can only be erased in blocks (usually 4 KiB).   bool lt_flash_erase_block (uint32_t offset) Erase a single block of flash (usually 4 KiB).   uint32_t lt_flash_read (uint32_t offset, uint8_t * data, size_t length) Read data from the flash.   uint32_t lt_flash_write (uint32_t offset, const uint8_t * data, size_t length) Write data to the flash."},{"location":"ltapi/lt__flash_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__flash_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/lt__flash_8c/#function-lt_flash_erase","title":"function lt_flash_erase","text":"<p>Erase flash area. Flash can only be erased in blocks (usually 4 KiB). <pre><code>bool lt_flash_erase (\n    uint32_t offset,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset to erase (in bytes); must be multiple of the flash chip's block size </li> <li><code>length</code> length of data to erase (in bytes); will be rounded up to block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful </p>"},{"location":"ltapi/lt__flash_8c/#function-lt_flash_erase_block","title":"function lt_flash_erase_block","text":"<p>Erase a single block of flash (usually 4 KiB). <pre><code>bool lt_flash_erase_block (\n    uint32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> offset of the block (in bytes); must be multiple of the flash chip's block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful </p>"},{"location":"ltapi/lt__flash_8c/#function-lt_flash_read","title":"function lt_flash_read","text":"<p>Read data from the flash. <pre><code>uint32_t lt_flash_read (\n    uint32_t offset,\n    uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to where to store the data </li> <li><code>length</code> length of data to read </li> </ul> <p>Returns:</p> <p>length of data successfully read (should equal 'length') </p>"},{"location":"ltapi/lt__flash_8c/#function-lt_flash_write","title":"function lt_flash_write","text":"<p>Write data to the flash. <pre><code>uint32_t lt_flash_write (\n    uint32_t offset,\n    const uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to data to write </li> <li><code>length</code> length of data to write </li> </ul> <p>Returns:</p> <p>length of data successfully written (should equal 'length') </p>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_flash.c</code></p>"},{"location":"ltapi/lt__flash_8c_source/","title":"File lt_flash.c","text":"<p>File List &gt; api &gt; lt_flash.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_flash.h\"\n\n#include &lt;fal.h&gt;\n\n__attribute__((weak)) uint32_t lt_flash_get_size() {\n    lt_flash_id_t id = lt_flash_get_id();\n    if (id.chip_size_id &gt;= 0x14 &amp;&amp; id.chip_size_id &lt;= 0x19) {\n        return (1 &lt;&lt; id.chip_size_id);\n    }\n#ifdef FLASH_LENGTH\n    return FLASH_LENGTH;\n#else\n    return 0;\n#endif\n}\n\nbool lt_flash_erase(uint32_t offset, size_t length) {\n    return fal_partition_erase(fal_root_part, offset, length) &gt;= 0;\n}\n\nbool lt_flash_erase_block(uint32_t offset) {\n    return fal_partition_erase(fal_root_part, offset, 1) &gt;= 0;\n}\n\nuint32_t lt_flash_read(uint32_t offset, uint8_t *data, size_t length) {\n    int ret = fal_partition_read(fal_root_part, offset, data, length);\n    if (ret == -1)\n        return 0;\n    return ret;\n}\n\nuint32_t lt_flash_write(uint32_t offset, const uint8_t *data, size_t length) {\n    int ret = fal_partition_write(fal_root_part, offset, data, length);\n    if (ret == -1)\n        return 0;\n    return ret;\n}\n</code></pre>"},{"location":"ltapi/lt__flash_8h/","title":"File lt_flash.h","text":"<p>FileList &gt; api &gt; lt_flash.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__flash_8h/#classes","title":"Classes","text":"Type Name     struct lt_flash_id_t Flash chip ID structure."},{"location":"ltapi/lt__flash_8h/#public-functions","title":"Public Functions","text":"Type Name     bool lt_flash_erase (uint32_t offset, size_t length) Erase flash area. Flash can only be erased in blocks (usually 4 KiB).   bool lt_flash_erase_block (uint32_t offset) Erase a single block of flash (usually 4 KiB).   lt_flash_id_t lt_flash_get_id () Read flash chip ID and return a lt_flash_id_t struct.   uint32_t lt_flash_get_size () Get flash chip total size.   uint32_t lt_flash_read (uint32_t offset, uint8_t * data, size_t length) Read data from the flash.   uint32_t lt_flash_write (uint32_t offset, const uint8_t * data, size_t length) Write data to the flash."},{"location":"ltapi/lt__flash_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__flash_8h/#function-lt_flash_erase","title":"function lt_flash_erase","text":"<p>Erase flash area. Flash can only be erased in blocks (usually 4 KiB). <pre><code>bool lt_flash_erase (\n    uint32_t offset,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset to erase (in bytes); must be multiple of the flash chip's block size </li> <li><code>length</code> length of data to erase (in bytes); will be rounded up to block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful </p>"},{"location":"ltapi/lt__flash_8h/#function-lt_flash_erase_block","title":"function lt_flash_erase_block","text":"<p>Erase a single block of flash (usually 4 KiB). <pre><code>bool lt_flash_erase_block (\n    uint32_t offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> offset of the block (in bytes); must be multiple of the flash chip's block size </li> </ul> <p>Returns:</p> <p>whether erasing was successful </p>"},{"location":"ltapi/lt__flash_8h/#function-lt_flash_get_id","title":"function lt_flash_get_id","text":"<pre><code>lt_flash_id_t lt_flash_get_id () \n</code></pre>"},{"location":"ltapi/lt__flash_8h/#function-lt_flash_get_size","title":"function lt_flash_get_size","text":"<p>Get flash chip total size. <pre><code>uint32_t lt_flash_get_size () \n</code></pre></p> <p>The default implementation uses the least significant byte of the chip ID to determine the size. </p>"},{"location":"ltapi/lt__flash_8h/#function-lt_flash_read","title":"function lt_flash_read","text":"<p>Read data from the flash. <pre><code>uint32_t lt_flash_read (\n    uint32_t offset,\n    uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to where to store the data </li> <li><code>length</code> length of data to read </li> </ul> <p>Returns:</p> <p>length of data successfully read (should equal 'length') </p>"},{"location":"ltapi/lt__flash_8h/#function-lt_flash_write","title":"function lt_flash_write","text":"<p>Write data to the flash. <pre><code>uint32_t lt_flash_write (\n    uint32_t offset,\n    const uint8_t * data,\n    size_t length\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> starting offset (in bytes) </li> <li><code>data</code> pointer to data to write </li> <li><code>length</code> length of data to write </li> </ul> <p>Returns:</p> <p>length of data successfully written (should equal 'length') </p>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_flash.h</code></p>"},{"location":"ltapi/lt__flash_8h_source/","title":"File lt_flash.h","text":"<p>File List &gt; api &gt; lt_flash.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\ntypedef struct {\n    uint8_t manufacturer_id;\n    uint8_t chip_id;\n    uint8_t chip_size_id;\n} lt_flash_id_t;\n\nlt_flash_id_t lt_flash_get_id();\n\nuint32_t lt_flash_get_size();\n\nbool lt_flash_erase(uint32_t offset, size_t length);\n\nbool lt_flash_erase_block(uint32_t offset);\n\nuint32_t lt_flash_read(uint32_t offset, uint8_t *data, size_t length);\n\nuint32_t lt_flash_write(uint32_t offset, const uint8_t *data, size_t length);\n</code></pre>"},{"location":"ltapi/lt__init_8h/","title":"File lt_init.h","text":"<p>FileList &gt; api &gt; lt_init.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__init_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_init_arduino () Initialize the family's Arduino core (optional). This method is family-specific; the family core can do whatever it wants to. This method is empty if not implemented, and shouldn't be called manually.   void lt_init_family () Initialize the family core (optional). This method is family-specific; the family core can do whatever it wants to. This method is empty if not implemented, and shouldn't be called manually.   void lt_init_variant () Initialize the board (variant). This method is empty if not implemented (which is usually the case), and shouldn't be called manually."},{"location":"ltapi/lt__init_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__init_8h/#function-lt_init_arduino","title":"function lt_init_arduino","text":"<pre><code>void lt_init_arduino () \n</code></pre>"},{"location":"ltapi/lt__init_8h/#function-lt_init_family","title":"function lt_init_family","text":"<pre><code>void lt_init_family () \n</code></pre>"},{"location":"ltapi/lt__init_8h/#function-lt_init_variant","title":"function lt_init_variant","text":"<pre><code>void lt_init_variant () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_init.h</code></p>"},{"location":"ltapi/lt__init_8h_source/","title":"File lt_init.h","text":"<p>File List &gt; api &gt; lt_init.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-02-27. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\nvoid lt_init_family() __attribute__((weak));\n\nvoid lt_init_variant() __attribute__((weak));\n\nvoid lt_init_arduino() __attribute__((weak));\n</code></pre>"},{"location":"ltapi/lt__mem_8c/","title":"File lt_mem.c","text":"<p>FileList &gt; api &gt; lt_mem.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_mem.h\"</code></li> </ul>"},{"location":"ltapi/lt__mem_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/lt__mem_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__mem_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_mem.c</code></p>"},{"location":"ltapi/lt__mem_8c_source/","title":"File lt_mem.c","text":"<p>File List &gt; api &gt; lt_mem.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_mem.h\"\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n#endif\n\n#if LT_HAS_FREERTOS\n__attribute__((weak)) uint32_t lt_heap_get_size() {\n    return configTOTAL_HEAP_SIZE;\n}\n\n__attribute__((weak)) uint32_t lt_heap_get_free() {\n    return xPortGetFreeHeapSize();\n}\n\n__attribute__((weak)) uint32_t lt_heap_get_min_free() {\n    return xPortGetMinimumEverFreeHeapSize();\n}\n#endif\n\n__attribute__((weak)) uint32_t lt_heap_get_max_alloc() {\n    return 0;\n}\n</code></pre>"},{"location":"ltapi/lt__mem_8h/","title":"File lt_mem.h","text":"<p>FileList &gt; api &gt; lt_mem.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__mem_8h/#public-functions","title":"Public Functions","text":"Type Name     uint32_t lt_heap_get_free () Get free heap size.   uint32_t lt_heap_get_max_alloc () Get largest block of heap that can be allocated at once.   uint32_t lt_heap_get_min_free () Get lowest level of free heap memory.   uint32_t lt_heap_get_size () Get total heap size.   uint32_t lt_ram_get_size () Get total RAM size."},{"location":"ltapi/lt__mem_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__mem_8h/#function-lt_heap_get_free","title":"function lt_heap_get_free","text":"<pre><code>uint32_t lt_heap_get_free () \n</code></pre>"},{"location":"ltapi/lt__mem_8h/#function-lt_heap_get_max_alloc","title":"function lt_heap_get_max_alloc","text":"<pre><code>uint32_t lt_heap_get_max_alloc () \n</code></pre>"},{"location":"ltapi/lt__mem_8h/#function-lt_heap_get_min_free","title":"function lt_heap_get_min_free","text":"<pre><code>uint32_t lt_heap_get_min_free () \n</code></pre>"},{"location":"ltapi/lt__mem_8h/#function-lt_heap_get_size","title":"function lt_heap_get_size","text":"<pre><code>uint32_t lt_heap_get_size () \n</code></pre>"},{"location":"ltapi/lt__mem_8h/#function-lt_ram_get_size","title":"function lt_ram_get_size","text":"<pre><code>uint32_t lt_ram_get_size () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_mem.h</code></p>"},{"location":"ltapi/lt__mem_8h_source/","title":"File lt_mem.h","text":"<p>File List &gt; api &gt; lt_mem.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\nuint32_t lt_ram_get_size();\n\nuint32_t lt_heap_get_size();\n\nuint32_t lt_heap_get_free();\n\nuint32_t lt_heap_get_min_free();\n\nuint32_t lt_heap_get_max_alloc();\n</code></pre>"},{"location":"ltapi/lt__ota_8c/","title":"File lt_ota.c","text":"<p>FileList &gt; api &gt; lt_ota.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_ota.h\"</code></li> <li><code>#include &lt;uf2ota/uf2ota.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__ota_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    void lt_ota_begin (lt_ota_ctx_t * ctx, size_t size) Initialize the update context to begin OTA process.   bool lt_ota_can_rollback () Check if OTA rollback is possible (switching the stored index to another partition).   bool lt_ota_end (lt_ota_ctx_t * ctx) Finish the update process. If the update has been written completely, try to activate the target image. Free allocated internal structures, regardless of the activation result.   uf2_ota_scheme_t lt_ota_get_uf2_scheme () Check which UF2 OTA scheme should be used for applying firmware updates.   size_t lt_ota_write (lt_ota_ctx_t * ctx, const uint8_t * data, size_t len) Process a chunk of data.   bool lt_ota_write_block (lt_ota_ctx_t * ctx, uf2_block_t * block) Try to write the block. In case of UF2 errors, error code is set in the context. Note: use lt_ota_write() instead. This is for internal usage only."},{"location":"ltapi/lt__ota_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name     size_t lt_ota_buf_left (lt_ota_ctx_t * ctx)    size_t lt_ota_buf_size (lt_ota_ctx_t * ctx)"},{"location":"ltapi/lt__ota_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__ota_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_begin","title":"function lt_ota_begin","text":"<p>Initialize the update context to begin OTA process. <pre><code>void lt_ota_begin (\n    lt_ota_ctx_t * ctx,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> <li><code>size</code> length of the update file; 0 if unknown </li> </ul>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_can_rollback","title":"function lt_ota_can_rollback","text":"<p>Check if OTA rollback is possible (switching the stored index to another partition). <pre><code>bool lt_ota_can_rollback () \n</code></pre></p> <p>Note that this is not the same as \"switching\" OTA with revert=true.</p> <p>Returns:</p> <p>true if 2nd image is valid and the chip is dual-OTA; false otherwise </p>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_end","title":"function lt_ota_end","text":"<p>Finish the update process. If the update has been written completely, try to activate the target image. Free allocated internal structures, regardless of the activation result. <pre><code>bool lt_ota_end (\n    lt_ota_ctx_t * ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> </ul> <p>Returns:</p> <p>false if activation was attempted and not successful; true otherwise </p>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_get_uf2_scheme","title":"function lt_ota_get_uf2_scheme","text":"<p>Check which UF2 OTA scheme should be used for applying firmware updates. <pre><code>uf2_ota_scheme_t lt_ota_get_uf2_scheme () \n</code></pre></p> <p>Returns:</p> <p>OTA scheme of the target partition </p>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_write","title":"function lt_ota_write","text":"<p>Process a chunk of data. <pre><code>size_t lt_ota_write (\n    lt_ota_ctx_t * ctx,\n    const uint8_t * data,\n    size_t len\n) \n</code></pre></p> <p>Data is written to the buffer, unless a full UF2 block is already available, in which case it's also processed by UF2OTA and written to flash.</p> <p>It's advised to write in 512-byte chunks (or its multiples).</p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> <li><code>data</code> chunk of bytes to process </li> <li><code>len</code> size of the chunk </li> </ul> <p>Returns:</p> <p>number of bytes correctly processed; should equal 'len' in case of no errors </p>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_write_block","title":"function lt_ota_write_block","text":"<p>Try to write the block. In case of UF2 errors, error code is set in the context. Note: use lt_ota_write() instead. This is for internal usage only. <pre><code>bool lt_ota_write_block (\n    lt_ota_ctx_t * ctx,\n    uf2_block_t * block\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block</code> UF2 block to check and write; cannot be NULL </li> </ul> <p>Returns:</p> <p>whether no error has occurred </p>"},{"location":"ltapi/lt__ota_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/lt__ota_8c/#function-lt_ota_buf_left","title":"function lt_ota_buf_left","text":"<pre><code>static inline size_t lt_ota_buf_left (\n    lt_ota_ctx_t * ctx\n) \n</code></pre>"},{"location":"ltapi/lt__ota_8c/#function-lt_ota_buf_size","title":"function lt_ota_buf_size","text":"<pre><code>static inline size_t lt_ota_buf_size (\n    lt_ota_ctx_t * ctx\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_ota.c</code></p>"},{"location":"ltapi/lt__ota_8c_source/","title":"File lt_ota.c","text":"<p>File List &gt; api &gt; lt_ota.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_ota.h\"\n\n#include &lt;uf2ota/uf2ota.h&gt;\n\nstatic inline size_t lt_ota_buf_left(lt_ota_ctx_t *ctx) {\n    return ctx-&gt;buf + UF2_BLOCK_SIZE - ctx-&gt;buf_pos;\n}\n\nstatic inline size_t lt_ota_buf_size(lt_ota_ctx_t *ctx) {\n    return ctx-&gt;buf_pos - ctx-&gt;buf;\n}\n\nvoid lt_ota_begin(lt_ota_ctx_t *ctx, size_t size) {\n    if (!ctx)\n        return;\n\n    memset(ctx, 0, sizeof(lt_ota_ctx_t));\n    uf2_ctx_init(&amp;ctx-&gt;uf2, lt_ota_get_uf2_scheme(), lt_cpu_get_family());\n    uf2_info_init(&amp;ctx-&gt;info);\n    ctx-&gt;buf_pos     = ctx-&gt;buf;\n    ctx-&gt;bytes_total = size;\n    ctx-&gt;running     = true;\n\n    lt_ota_set_write_protect(&amp;ctx-&gt;uf2);\n\n    LT_DM(OTA, \"begin(%u, ...) / OTA curr: %u, scheme: %u\", size, lt_ota_dual_get_current(), lt_ota_get_uf2_scheme());\n}\n\nbool lt_ota_end(lt_ota_ctx_t *ctx) {\n    if (!ctx || !ctx-&gt;running)\n        return true;\n\n    uf2_ctx_free(&amp;ctx-&gt;uf2);\n    uf2_info_free(&amp;ctx-&gt;info);\n    ctx-&gt;running = false;\n\n    if (ctx-&gt;bytes_written &amp;&amp; ctx-&gt;bytes_written == ctx-&gt;bytes_total) {\n        // try to activate the 2nd image\n        return lt_ota_switch(/* revert= */ false);\n    }\n\n    // activation not attempted (update aborted)\n    return true;\n}\n\n__attribute__((weak)) void lt_ota_set_write_protect(uf2_ota_t *uf2) {}\n\nsize_t lt_ota_write(lt_ota_ctx_t *ctx, const uint8_t *data, size_t len) {\n    if (!ctx || !ctx-&gt;running)\n        return 0;\n\n    // write until buffer space is available\n    size_t written = 0;\n    uint16_t to_write; // 1..512\n    while (len &amp;&amp; (to_write = MIN((uint16_t)len, lt_ota_buf_left(ctx)))) {\n        LT_VM(OTA, \"Writing %u to buffer (%u/512)\", len, lt_ota_buf_size(ctx));\n\n        uf2_block_t *block = NULL;\n        if (to_write == UF2_BLOCK_SIZE) {\n            // data has a complete block; don't use the buffer\n            block = (uf2_block_t *)data;\n        } else {\n            // data has a part of a block; append it to the buffer\n            memcpy(ctx-&gt;buf_pos, data, to_write);\n            ctx-&gt;buf_pos += to_write;\n            if (lt_ota_buf_size(ctx) == UF2_BLOCK_SIZE) {\n                // the block is complete now\n                block = (uf2_block_t *)ctx-&gt;buf;\n            }\n        }\n\n        // write if a block is ready\n        if (block &amp;&amp; lt_ota_write_block(ctx, block) == false)\n            // return on errors\n            return written;\n        data += to_write;\n        len -= to_write;\n        written += to_write;\n    }\n    return written;\n}\n\nbool lt_ota_write_block(lt_ota_ctx_t *ctx, uf2_block_t *block) {\n    ctx-&gt;error = uf2_check_block(&amp;ctx-&gt;uf2, block);\n    if (ctx-&gt;error &gt; UF2_ERR_IGNORE)\n        // block is invalid\n        return false;\n\n    if (!ctx-&gt;bytes_written) {\n        // parse header block to allow retrieving firmware info\n        ctx-&gt;error = uf2_parse_header(&amp;ctx-&gt;uf2, block, &amp;ctx-&gt;info);\n        if (ctx-&gt;error != UF2_ERR_OK)\n            return false;\n\n        LT_IM(\n            OTA,\n            \"%s v%s - LT v%s @ %s\",\n            ctx-&gt;info.fw_name,\n            ctx-&gt;info.fw_version,\n            ctx-&gt;info.lt_version,\n            ctx-&gt;info.board\n        );\n\n        if (ctx-&gt;bytes_total == 0) {\n            // set total update size from block count info\n            ctx-&gt;bytes_total = block-&gt;block_count * UF2_BLOCK_SIZE;\n        } else if (ctx-&gt;bytes_total != block-&gt;block_count * UF2_BLOCK_SIZE) {\n            // given update size does not match the block count\n            LT_EM(\n                OTA,\n                \"Image size wrong; got %u, calculated %llu\",\n                ctx-&gt;bytes_total,\n                block-&gt;block_count * UF2_BLOCK_SIZE\n            );\n            return false;\n        }\n    } else if (ctx-&gt;error == UF2_ERR_OK) {\n        // write data blocks normally\n        ctx-&gt;error = uf2_write(&amp;ctx-&gt;uf2, block);\n        if (ctx-&gt;error &gt; UF2_ERR_IGNORE)\n            // block writing failed\n            return false;\n    }\n\n    // increment total writing progress\n    ctx-&gt;bytes_written += UF2_BLOCK_SIZE;\n    // call progress callback\n    if (ctx-&gt;callback)\n        ctx-&gt;callback(ctx-&gt;callback_param);\n    // reset the buffer as it's used already\n    if (lt_ota_buf_size(ctx) == UF2_BLOCK_SIZE)\n        ctx-&gt;buf_pos = ctx-&gt;buf;\n\n    return true;\n}\n\nbool lt_ota_can_rollback() {\n    if (lt_ota_get_type() != OTA_TYPE_DUAL)\n        return false;\n    uint8_t current = lt_ota_dual_get_current();\n    if (current == 0)\n        return false;\n    return lt_ota_is_valid(current ^ 0b11);\n}\n\nuf2_ota_scheme_t lt_ota_get_uf2_scheme() {\n    if (lt_ota_get_type() == OTA_TYPE_SINGLE)\n        return UF2_SCHEME_DEVICE_SINGLE;\n    uint8_t current = lt_ota_dual_get_current();\n    if (current == 0)\n        return UF2_SCHEME_DEVICE_DUAL_1;\n    // UF2_SCHEME_DEVICE_DUAL_1 or UF2_SCHEME_DEVICE_DUAL_2\n    return (uf2_ota_scheme_t)(current ^ 0b11);\n}\n</code></pre>"},{"location":"ltapi/lt__ota_8h/","title":"File lt_ota.h","text":"<p>FileList &gt; api &gt; lt_ota.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> <li><code>#include &lt;uf2ota/uf2types.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__ota_8h/#classes","title":"Classes","text":"Type Name     struct lt_ota_ctx_t OTA update process context."},{"location":"ltapi/lt__ota_8h/#public-types","title":"Public Types","text":"Type Name     enum lt_ota_type_t Chip's OTA type enumeration."},{"location":"ltapi/lt__ota_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_ota_begin (lt_ota_ctx_t * ctx, size_t size) Initialize the update context to begin OTA process.   bool lt_ota_can_rollback () Check if OTA rollback is possible (switching the stored index to another partition).   uint8_t lt_ota_dual_get_current () Get the currently running firmware's OTA index.   uint8_t lt_ota_dual_get_stored () Read the currently active OTA index, i.e. the one that will boot upon restart.   bool lt_ota_end (lt_ota_ctx_t * ctx) Finish the update process. If the update has been written completely, try to activate the target image. Free allocated internal structures, regardless of the activation result.   lt_ota_type_t lt_ota_get_type () Get OTA type of the device's chip.   uf2_ota_scheme_t lt_ota_get_uf2_scheme () Check which UF2 OTA scheme should be used for applying firmware updates.   bool lt_ota_is_valid (uint8_t index) Check if the specified OTA image is valid.   void lt_ota_set_write_protect (uf2_ota_t * uf2) Set family-specific, write-protected flash areas in the OTA update context. This shouldn't be called manually, as it's done by lt_ota_begin().   bool lt_ota_switch (bool revert) Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid.   size_t lt_ota_write (lt_ota_ctx_t * ctx, const uint8_t * data, size_t len) Process a chunk of data.   bool lt_ota_write_block (lt_ota_ctx_t * ctx, uf2_block_t * block) Try to write the block. In case of UF2 errors, error code is set in the context. Note: use lt_ota_write() instead. This is for internal usage only."},{"location":"ltapi/lt__ota_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/lt__ota_8h/#enum-lt_ota_type_t","title":"enum lt_ota_type_t","text":"<pre><code>enum lt_ota_type_t {\n    OTA_TYPE_SINGLE = 0,\n    OTA_TYPE_DUAL = 1,\n    OTA_TYPE_FILE = 2\n};\n</code></pre>"},{"location":"ltapi/lt__ota_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__ota_8h/#function-lt_ota_begin","title":"function lt_ota_begin","text":"<p>Initialize the update context to begin OTA process. <pre><code>void lt_ota_begin (\n    lt_ota_ctx_t * ctx,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> <li><code>size</code> length of the update file; 0 if unknown </li> </ul>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_can_rollback","title":"function lt_ota_can_rollback","text":"<p>Check if OTA rollback is possible (switching the stored index to another partition). <pre><code>bool lt_ota_can_rollback () \n</code></pre></p> <p>Note that this is not the same as \"switching\" OTA with revert=true.</p> <p>Returns:</p> <p>true if 2nd image is valid and the chip is dual-OTA; false otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_dual_get_current","title":"function lt_ota_dual_get_current","text":"<p>Get the currently running firmware's OTA index. <pre><code>uint8_t lt_ota_dual_get_current () \n</code></pre></p> <p>Returns:</p> <p>OTA index if dual-OTA is supported, 0 otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_dual_get_stored","title":"function lt_ota_dual_get_stored","text":"<p>Read the currently active OTA index, i.e. the one that will boot upon restart. <pre><code>uint8_t lt_ota_dual_get_stored () \n</code></pre></p> <p>Returns:</p> <p>OTA index if dual-OTA is supported, 0 otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_end","title":"function lt_ota_end","text":"<p>Finish the update process. If the update has been written completely, try to activate the target image. Free allocated internal structures, regardless of the activation result. <pre><code>bool lt_ota_end (\n    lt_ota_ctx_t * ctx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> </ul> <p>Returns:</p> <p>false if activation was attempted and not successful; true otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_get_type","title":"function lt_ota_get_type","text":"<pre><code>lt_ota_type_t lt_ota_get_type () \n</code></pre>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_get_uf2_scheme","title":"function lt_ota_get_uf2_scheme","text":"<p>Check which UF2 OTA scheme should be used for applying firmware updates. <pre><code>uf2_ota_scheme_t lt_ota_get_uf2_scheme () \n</code></pre></p> <p>Returns:</p> <p>OTA scheme of the target partition </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_is_valid","title":"function lt_ota_is_valid","text":"<p>Check if the specified OTA image is valid. <pre><code>bool lt_ota_is_valid (\n    uint8_t index\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>index</code> OTA index to check; 0 for single-OTA chips, 1 or 2 for dual-OTA chips </li> </ul> <p>Returns:</p> <p>true if index is valid for the chip's OTA type, and there is a valid image; false otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_set_write_protect","title":"function lt_ota_set_write_protect","text":"<p>Set family-specific, write-protected flash areas in the OTA update context. This shouldn't be called manually, as it's done by lt_ota_begin(). <pre><code>void lt_ota_set_write_protect (\n    uf2_ota_t * uf2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>uf2</code> uf2ota context </li> </ul>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_switch","title":"function lt_ota_switch","text":"<p>Try to switch OTA index to the other image. For single-OTA chips, only check if the upgrade image is valid. <pre><code>bool lt_ota_switch (\n    bool revert\n) \n</code></pre></p> <p>This can be used to \"activate\" the upgrade after flashing.</p> <p>Parameters:</p> <ul> <li><code>revert</code> switch if (and only if) the other image is already marked as active (i.e. switch back to the running image) </li> </ul> <p>Returns:</p> <p>false if the second image (or upgrade image) is not valid; false if writing failed; true otherwise </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_write","title":"function lt_ota_write","text":"<p>Process a chunk of data. <pre><code>size_t lt_ota_write (\n    lt_ota_ctx_t * ctx,\n    const uint8_t * data,\n    size_t len\n) \n</code></pre></p> <p>Data is written to the buffer, unless a full UF2 block is already available, in which case it's also processed by UF2OTA and written to flash.</p> <p>It's advised to write in 512-byte chunks (or its multiples).</p> <p>Parameters:</p> <ul> <li><code>ctx</code> OTA context </li> <li><code>data</code> chunk of bytes to process </li> <li><code>len</code> size of the chunk </li> </ul> <p>Returns:</p> <p>number of bytes correctly processed; should equal 'len' in case of no errors </p>"},{"location":"ltapi/lt__ota_8h/#function-lt_ota_write_block","title":"function lt_ota_write_block","text":"<p>Try to write the block. In case of UF2 errors, error code is set in the context. Note: use lt_ota_write() instead. This is for internal usage only. <pre><code>bool lt_ota_write_block (\n    lt_ota_ctx_t * ctx,\n    uf2_block_t * block\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block</code> UF2 block to check and write; cannot be NULL </li> </ul> <p>Returns:</p> <p>whether no error has occurred </p>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_ota.h</code></p>"},{"location":"ltapi/lt__ota_8h_source/","title":"File lt_ota.h","text":"<p>File List &gt; api &gt; lt_ota.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n#include &lt;uf2ota/uf2types.h&gt;\n\ntypedef enum {\n    OTA_TYPE_SINGLE = 0,\n    OTA_TYPE_DUAL   = 1,\n    OTA_TYPE_FILE   = 2,\n} lt_ota_type_t;\n\ntypedef struct {\n    uf2_ota_t uf2;\n    uf2_info_t info;\n    uint8_t buf[UF2_BLOCK_SIZE];   // block data buffer\n    uint8_t *buf_pos;              // buffer writing position\n    uint32_t bytes_written;        // update progress\n    uint32_t bytes_total;          // total update size\n    uf2_err_t error;               // LT OTA/uf2ota error code\n    bool running;                  // whether update has begun\n    void (*callback)(void *param); // progress callback\n    void *callback_param;          // callback argument\n} lt_ota_ctx_t;\n\nvoid lt_ota_begin(lt_ota_ctx_t *ctx, size_t size);\n\nbool lt_ota_end(lt_ota_ctx_t *ctx);\n\nvoid lt_ota_set_write_protect(uf2_ota_t *uf2);\n\nsize_t lt_ota_write(lt_ota_ctx_t *ctx, const uint8_t *data, size_t len);\n\nbool lt_ota_write_block(lt_ota_ctx_t *ctx, uf2_block_t *block);\n\nlt_ota_type_t lt_ota_get_type();\n\nbool lt_ota_is_valid(uint8_t index);\n\nbool lt_ota_can_rollback();\n\nuint8_t lt_ota_dual_get_current();\n\nuint8_t lt_ota_dual_get_stored();\n\nuf2_ota_scheme_t lt_ota_get_uf2_scheme();\n\nbool lt_ota_switch(bool revert);\n</code></pre>"},{"location":"ltapi/lt__sleep_8c/","title":"File lt_sleep.c","text":"<p>FileList &gt; api &gt; lt_sleep.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_sleep.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_sleep.c</code></p>"},{"location":"ltapi/lt__sleep_8c_source/","title":"File lt_sleep.c","text":"<p>File List &gt; api &gt; lt_sleep.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Peter Sarkozi 2023-06-17. */\n\n#include \"lt_sleep.h\"\n\n__attribute__((weak)) void lt_deep_sleep_config_gpio(uint32_t gpio_index_map, bool on_high);\n\n__attribute__((weak)) void lt_deep_sleep_unset_gpio(uint32_t gpio_index_map);\n\n__attribute__((weak)) void lt_deep_sleep_keep_floating_gpio(uint32_t gpio_index_map, bool on_high);\n\n__attribute__((weak)) void lt_deep_sleep_config_timer(uint32_t sleep_duration);\n\n__attribute__((weak)) void lt_deep_sleep_enter();\n</code></pre>"},{"location":"ltapi/lt__sleep_8h/","title":"File lt_sleep.h","text":"<p>FileList &gt; api &gt; lt_sleep.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__sleep_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_deep_sleep_config_gpio (uint32_t gpio_index_map, bool on_high) Enable GPIO Wakeup from Deep Sleep.   void lt_deep_sleep_config_timer (uint32_t sleep_duration) Set a sleep timer to wake up the device.   void lt_deep_sleep_enter () Start deep sleep.   void lt_deep_sleep_keep_floating_gpio (uint32_t gpio_index_map, bool enabled) Configure GPIO pins to be kept floating.   void lt_deep_sleep_unset_gpio (uint32_t gpio_index_map) Disable GPIO Wakeup on given pins."},{"location":"ltapi/lt__sleep_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__sleep_8h/#function-lt_deep_sleep_config_gpio","title":"function lt_deep_sleep_config_gpio","text":"<p>Enable GPIO Wakeup from Deep Sleep. <pre><code>void lt_deep_sleep_config_gpio (\n    uint32_t gpio_index_map,\n    bool on_high\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>gpio_index_map</code> bitMap of the pins we should wake up on </li> <li><code>on_high</code> whether to wake up on High or Low state </li> </ul>"},{"location":"ltapi/lt__sleep_8h/#function-lt_deep_sleep_config_timer","title":"function lt_deep_sleep_config_timer","text":"<p>Set a sleep timer to wake up the device. <pre><code>void lt_deep_sleep_config_timer (\n    uint32_t sleep_duration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sleep_duration</code> the time in milliseconds to sleep </li> </ul>"},{"location":"ltapi/lt__sleep_8h/#function-lt_deep_sleep_enter","title":"function lt_deep_sleep_enter","text":"<pre><code>void lt_deep_sleep_enter () \n</code></pre>"},{"location":"ltapi/lt__sleep_8h/#function-lt_deep_sleep_keep_floating_gpio","title":"function lt_deep_sleep_keep_floating_gpio","text":"<p>Configure GPIO pins to be kept floating. <pre><code>void lt_deep_sleep_keep_floating_gpio (\n    uint32_t gpio_index_map,\n    bool enabled\n) \n</code></pre></p> <p>This prevents pins from being configured as pullup/pulldown, based on the configured wake-up mode (low/high), upon entering deep sleep. This is important, as some-low power devices may be unable to ever overcome the internal pull strength and change the level. One example of such device is a magnetic door sensor that must be able to wake on level change in both directions.</p> <p>Parameters:</p> <ul> <li><code>gpio_index_map</code> bitMap of the pins to set/unset as floating </li> <li><code>enabled</code> whether to set pins to floating or roll back to default mode </li> </ul>"},{"location":"ltapi/lt__sleep_8h/#function-lt_deep_sleep_unset_gpio","title":"function lt_deep_sleep_unset_gpio","text":"<p>Disable GPIO Wakeup on given pins. <pre><code>void lt_deep_sleep_unset_gpio (\n    uint32_t gpio_index_map\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>gpio_index_map</code> bitMap of the pins we should disable wake up on </li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_sleep.h</code></p>"},{"location":"ltapi/lt__sleep_8h_source/","title":"File lt_sleep.h","text":"<p>File List &gt; api &gt; lt_sleep.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Peter Sarkozi 2023-06-17. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\nvoid lt_deep_sleep_config_gpio(uint32_t gpio_index_map, bool on_high);\n\nvoid lt_deep_sleep_unset_gpio(uint32_t gpio_index_map);\n\nvoid lt_deep_sleep_keep_floating_gpio(uint32_t gpio_index_map, bool enabled);\n\nvoid lt_deep_sleep_config_timer(uint32_t sleep_duration);\n\nvoid lt_deep_sleep_enter();\n</code></pre>"},{"location":"ltapi/lt__utils_8c/","title":"File lt_utils.c","text":"<p>FileList &gt; api &gt; lt_utils.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_utils.h\"</code></li> </ul>"},{"location":"ltapi/lt__utils_8c/#public-functions","title":"Public Functions","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset=0, uint8_t width=16) Print data pointed to by buf in hexdump-like format (hex+ASCII).   char * lt_btox (const uint8_t * src, int len, char * dest) Convert a byte array to hexadecimal string.   void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand().   uint8_t * lt_xtob (const char * src, int len, uint8_t * dest) Convert a hexadecimal string to byte array."},{"location":"ltapi/lt__utils_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__utils_8c/#function-hexdump","title":"function hexdump","text":"<p>Print data pointed to by buf in hexdump-like format (hex+ASCII). <pre><code>void hexdump (\n    const uint8_t * buf,\n    size_t len,\n    uint32_t offset=0,\n    uint8_t width=16\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> source pointer </li> <li><code>len</code> how many bytes to print </li> <li><code>offset</code> increment printed offset by this value </li> <li><code>width</code> how many bytes on a line </li> </ul>"},{"location":"ltapi/lt__utils_8c/#function-lt_btox","title":"function lt_btox","text":"<p>Convert a byte array to hexadecimal string. <pre><code>char * lt_btox (\n    const uint8_t * src,\n    int len,\n    char * dest\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source byte array </li> <li><code>len</code> source length (bytes) </li> <li><code>dest</code> destination string </li> </ul> <p>Returns:</p> <p>destination string </p>"},{"location":"ltapi/lt__utils_8c/#function-lt_rand_bytes","title":"function lt_rand_bytes","text":"<p>Generate random bytes using rand(). <pre><code>void lt_rand_bytes (\n    uint8_t * buf,\n    size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate </li> </ul>"},{"location":"ltapi/lt__utils_8c/#function-lt_xtob","title":"function lt_xtob","text":"<p>Convert a hexadecimal string to byte array. <pre><code>uint8_t * lt_xtob (\n    const char * src,\n    int len,\n    uint8_t * dest\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source string </li> <li><code>len</code> source length (chars) </li> <li><code>dest</code> destination byte array </li> </ul> <p>Returns:</p> <p>destination byte array </p>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_utils.c</code></p>"},{"location":"ltapi/lt__utils_8c_source/","title":"File lt_utils.c","text":"<p>File List &gt; api &gt; lt_utils.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_utils.h\"\n\nvoid lt_rand_bytes(uint8_t *buf, size_t len) {\n    int *data = (int *)buf;\n    size_t i;\n    for (i = 0; len &gt;= sizeof(int); len -= sizeof(int)) {\n        data[i++] = rand();\n    }\n    if (len) {\n        int rem             = rand();\n        unsigned char *pRem = (unsigned char *)&amp;rem;\n        memcpy(buf + i * sizeof(int), pRem, len);\n    }\n}\n\nvoid hexdump(const uint8_t *buf, size_t len, uint32_t offset, uint8_t width) {\n    uint16_t pos = 0;\n    while (pos &lt; len) {\n        // print hex offset\n        printf(\"%06lx \", offset + pos);\n        // calculate current line width\n        uint8_t lineWidth = MIN(width, len - pos);\n        // print hexadecimal representation\n        for (uint8_t i = 0; i &lt; lineWidth; i++) {\n            if (i % 8 == 0) {\n                printf(\" \");\n            }\n            printf(\"%02x \", buf[pos + i]);\n        }\n        // print ascii representation\n        printf(\" |\");\n        for (uint8_t i = 0; i &lt; lineWidth; i++) {\n            char c = buf[pos + i];\n            putchar((c &gt;= 0x20 &amp;&amp; c &lt;= 0x7f) ? c : '.');\n        }\n        puts(\"|\\r\");\n        pos += lineWidth;\n    }\n}\n\nchar *lt_btox(const uint8_t *src, int len, char *dest) {\n    // https://stackoverflow.com/a/53966346\n    const char hex[] = \"0123456789abcdef\";\n    len *= 2;\n    dest[len] = '\\0';\n    while (--len &gt;= 0)\n        dest[len] = hex[(src[len &gt;&gt; 1] &gt;&gt; ((1 - (len &amp; 1)) &lt;&lt; 2)) &amp; 0xF];\n    return dest;\n}\n\nuint8_t *lt_xtob(const char *src, int len, uint8_t *dest) {\n    // https://gist.github.com/vi/dd3b5569af8a26b97c8e20ae06e804cb\n\n    // mapping of ASCII characters to hex values\n    // (16-byte swapped to reduce XOR 0x10 operation)\n    const uint8_t mapping[] = {\n        0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567\n        0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;&lt;=&gt;?\n    };\n\n    int j = 0;\n    uint8_t idx0;\n    uint8_t idx1;\n    for (int i = 0; i &lt; len; i += 2) {\n        idx0      = ((uint8_t)src[i + 0] &amp; 0x1F);\n        idx1      = ((uint8_t)src[i + 1] &amp; 0x1F);\n        dest[j++] = (mapping[idx0] &lt;&lt; 4) | (mapping[idx1] &lt;&lt; 0);\n    }\n    return dest;\n}\n</code></pre>"},{"location":"ltapi/lt__utils_8h/","title":"File lt_utils.h","text":"<p>FileList &gt; api &gt; lt_utils.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__utils_8h/#public-functions","title":"Public Functions","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset=0, uint8_t width=16) Print data pointed to by buf in hexdump-like format (hex+ASCII).   char * lt_btox (const uint8_t * src, int len, char * dest) Convert a byte array to hexadecimal string.   void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand().   uint8_t * lt_xtob (const char * src, int len, uint8_t * dest) Convert a hexadecimal string to byte array."},{"location":"ltapi/lt__utils_8h/#macros","title":"Macros","text":"Type Name     define MAX (a, b)    define MIN (a, b)"},{"location":"ltapi/lt__utils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__utils_8h/#function-hexdump","title":"function hexdump","text":"<p>Print data pointed to by buf in hexdump-like format (hex+ASCII). <pre><code>void hexdump (\n    const uint8_t * buf,\n    size_t len,\n    uint32_t offset=0,\n    uint8_t width=16\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> source pointer </li> <li><code>len</code> how many bytes to print </li> <li><code>offset</code> increment printed offset by this value </li> <li><code>width</code> how many bytes on a line </li> </ul>"},{"location":"ltapi/lt__utils_8h/#function-lt_btox","title":"function lt_btox","text":"<p>Convert a byte array to hexadecimal string. <pre><code>char * lt_btox (\n    const uint8_t * src,\n    int len,\n    char * dest\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source byte array </li> <li><code>len</code> source length (bytes) </li> <li><code>dest</code> destination string </li> </ul> <p>Returns:</p> <p>destination string </p>"},{"location":"ltapi/lt__utils_8h/#function-lt_rand_bytes","title":"function lt_rand_bytes","text":"<p>Generate random bytes using rand(). <pre><code>void lt_rand_bytes (\n    uint8_t * buf,\n    size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate </li> </ul>"},{"location":"ltapi/lt__utils_8h/#function-lt_xtob","title":"function lt_xtob","text":"<p>Convert a hexadecimal string to byte array. <pre><code>uint8_t * lt_xtob (\n    const char * src,\n    int len,\n    uint8_t * dest\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> source string </li> <li><code>len</code> source length (chars) </li> <li><code>dest</code> destination byte array </li> </ul> <p>Returns:</p> <p>destination byte array </p>"},{"location":"ltapi/lt__utils_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__utils_8h/#define-max","title":"define MAX","text":"<pre><code>#define MAX (\n    a,\n    b\n) ({                          \\\n        __typeof__(a) _a = (a); \\\n        __typeof__(b) _b = (b); \\\n        _a &gt; _b ? _a : _b;      \\\n    })\n</code></pre>"},{"location":"ltapi/lt__utils_8h/#define-min","title":"define MIN","text":"<pre><code>#define MIN (\n    a,\n    b\n) ({                          \\\n        __typeof__(a) _a = (a); \\\n        __typeof__(b) _b = (b); \\\n        _a &lt; _b ? _a : _b;      \\\n    })\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_utils.h</code></p>"},{"location":"ltapi/lt__utils_8h_source/","title":"File lt_utils.h","text":"<p>File List &gt; api &gt; lt_utils.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-02-27. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\n// https://stackoverflow.com/a/3437484\n#define MAX(a, b)               \\\n    ({                          \\\n        __typeof__(a) _a = (a); \\\n        __typeof__(b) _b = (b); \\\n        _a &gt; _b ? _a : _b;      \\\n    })\n#define MIN(a, b)               \\\n    ({                          \\\n        __typeof__(a) _a = (a); \\\n        __typeof__(b) _b = (b); \\\n        _a &lt; _b ? _a : _b;      \\\n    })\n\nvoid lt_rand_bytes(uint8_t *buf, size_t len);\n\nvoid hexdump(\n    const uint8_t *buf,\n    size_t len,\n#ifdef __cplusplus\n    uint32_t offset = 0,\n    uint8_t width   = 16\n#else\n    uint32_t offset,\n    uint8_t width\n#endif\n);\n\nchar *lt_btox(const uint8_t *src, int len, char *dest);\n\nuint8_t *lt_xtob(const char *src, int len, uint8_t *dest);\n</code></pre>"},{"location":"ltapi/lt__wdt_8c/","title":"File lt_wdt.c","text":"<p>FileList &gt; api &gt; lt_wdt.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_wdt.h\"</code></li> </ul>"},{"location":"ltapi/lt__wdt_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/lt__wdt_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__wdt_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_wdt.c</code></p>"},{"location":"ltapi/lt__wdt_8c_source/","title":"File lt_wdt.c","text":"<p>File List &gt; api &gt; lt_wdt.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"lt_wdt.h\"\n\n__attribute__((weak)) bool lt_wdt_enable(uint32_t timeout) {\n    return false;\n}\n\n__attribute__((weak)) void lt_wdt_disable() {}\n\n__attribute__((weak)) void lt_wdt_feed() {}\n</code></pre>"},{"location":"ltapi/lt__wdt_8h/","title":"File lt_wdt.h","text":"<p>FileList &gt; api &gt; lt_wdt.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__wdt_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_wdt_disable () Disable the hardware watchdog.   bool lt_wdt_enable (uint32_t timeout) Enable the hardware watchdog.   void lt_wdt_feed () Feed/reset the hardware watchdog timer."},{"location":"ltapi/lt__wdt_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__wdt_8h/#function-lt_wdt_disable","title":"function lt_wdt_disable","text":"<pre><code>void lt_wdt_disable () \n</code></pre>"},{"location":"ltapi/lt__wdt_8h/#function-lt_wdt_enable","title":"function lt_wdt_enable","text":"<p>Enable the hardware watchdog. <pre><code>bool lt_wdt_enable (\n    uint32_t timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> watchdog timeout, milliseconds </li> </ul> <p>Returns:</p> <p>whether the chip has a hardware watchdog </p>"},{"location":"ltapi/lt__wdt_8h/#function-lt_wdt_feed","title":"function lt_wdt_feed","text":"<pre><code>void lt_wdt_feed () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/api/lt_wdt.h</code></p>"},{"location":"ltapi/lt__wdt_8h_source/","title":"File lt_wdt.h","text":"<p>File List &gt; api &gt; lt_wdt.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\nbool lt_wdt_enable(uint32_t timeout);\n\nvoid lt_wdt_disable();\n\nvoid lt_wdt_feed();\n</code></pre>"},{"location":"ltapi/dir_df2c4eb2fc0858b25d84c91a81f7ab75/","title":"Dir cores/common/base/compat","text":"<p>FileList &gt; base &gt; compat</p>"},{"location":"ltapi/dir_df2c4eb2fc0858b25d84c91a81f7ab75/#files","title":"Files","text":"Type Name     file certs.h    file err.h    file netdb.h    file netif.h    file sockets.h    file sys.h    file tcpip.h    file udp.h"},{"location":"ltapi/dir_df2c4eb2fc0858b25d84c91a81f7ab75/#directories","title":"Directories","text":"Type Name     dir lwip      <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/</code></p>"},{"location":"ltapi/certs_8h/","title":"File certs.h","text":"<p>FileList &gt; base &gt; compat &gt; certs.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;mbedtls/certs.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/certs.h</code></p>"},{"location":"ltapi/certs_8h_source/","title":"File certs.h","text":"<p>File List &gt; base &gt; compat &gt; certs.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-13. */\n\n#pragma once\n\n#include &lt;mbedtls/certs.h&gt;\n</code></pre>"},{"location":"ltapi/dir_8dc93de83995bf7a7f7c574b7e694258/","title":"Dir cores/common/base/compat/lwip","text":"<p>FileList &gt; base &gt; compat &gt; lwip</p>"},{"location":"ltapi/dir_8dc93de83995bf7a7f7c574b7e694258/#files","title":"Files","text":"Type Name     file lwip_timers.h      <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/lwip/</code></p>"},{"location":"ltapi/lwip__timers_8h/","title":"File lwip_timers.h","text":"<p>FileList &gt; base &gt; compat &gt; lwip &gt; lwip_timers.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/timeouts.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/lwip/lwip_timers.h</code></p>"},{"location":"ltapi/lwip__timers_8h_source/","title":"File lwip_timers.h","text":"<p>File List &gt; base &gt; compat &gt; lwip &gt; lwip_timers.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-22. */\n\n#pragma once\n\n#include &lt;lwip/timeouts.h&gt;\n</code></pre>"},{"location":"ltapi/err_8h/","title":"File err.h","text":"<p>FileList &gt; base &gt; compat &gt; err.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/err.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/err.h</code></p>"},{"location":"ltapi/err_8h_source/","title":"File err.h","text":"<p>File List &gt; base &gt; compat &gt; err.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-22. */\n\n#pragma once\n\n#include &lt;lwip/err.h&gt;\n</code></pre>"},{"location":"ltapi/netdb_8h/","title":"File netdb.h","text":"<p>FileList &gt; base &gt; compat &gt; netdb.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/netdb.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/netdb.h</code></p>"},{"location":"ltapi/netdb_8h_source/","title":"File netdb.h","text":"<p>File List &gt; base &gt; compat &gt; netdb.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-13. */\n\n#pragma once\n\n#include &lt;lwip/netdb.h&gt;\n</code></pre>"},{"location":"ltapi/netif_8h/","title":"File netif.h","text":"<p>FileList &gt; base &gt; compat &gt; netif.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/netif.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/netif.h</code></p>"},{"location":"ltapi/netif_8h_source/","title":"File netif.h","text":"<p>File List &gt; base &gt; compat &gt; netif.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-20. */\n\n#pragma once\n\n#include &lt;lwip/netif.h&gt;\n</code></pre>"},{"location":"ltapi/sockets_8h/","title":"File sockets.h","text":"<p>FileList &gt; base &gt; compat &gt; sockets.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/sockets.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/sockets.h</code></p>"},{"location":"ltapi/sockets_8h_source/","title":"File sockets.h","text":"<p>File List &gt; base &gt; compat &gt; sockets.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#pragma once\n\n#include &lt;lwip/sockets.h&gt;\n</code></pre>"},{"location":"ltapi/sys_8h/","title":"File sys.h","text":"<p>FileList &gt; base &gt; compat &gt; sys.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/sys.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/sys.h</code></p>"},{"location":"ltapi/sys_8h_source/","title":"File sys.h","text":"<p>File List &gt; base &gt; compat &gt; sys.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-22. */\n\n#pragma once\n\n#include &lt;lwip/sys.h&gt;\n</code></pre>"},{"location":"ltapi/tcpip_8h/","title":"File tcpip.h","text":"<p>FileList &gt; base &gt; compat &gt; tcpip.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/tcpip.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/tcpip.h</code></p>"},{"location":"ltapi/tcpip_8h_source/","title":"File tcpip.h","text":"<p>File List &gt; base &gt; compat &gt; tcpip.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-22. */\n\n#pragma once\n\n#include &lt;lwip/tcpip.h&gt;\n</code></pre>"},{"location":"ltapi/udp_8h/","title":"File udp.h","text":"<p>FileList &gt; base &gt; compat &gt; udp.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lwip/udp.h&gt;</code></li> </ul>"},{"location":"ltapi/udp_8h/#macros","title":"Macros","text":"Type Name     define lwip_ntohl  lwip_htonl"},{"location":"ltapi/udp_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/udp_8h/#define-lwip_ntohl","title":"define lwip_ntohl","text":"<pre><code>#define lwip_ntohl lwip_htonl\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/compat/udp.h</code></p>"},{"location":"ltapi/udp_8h_source/","title":"File udp.h","text":"<p>File List &gt; base &gt; compat &gt; udp.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#pragma once\n\n#include &lt;lwip/udp.h&gt;\n\n// this is included only by wifi_simple_config.c\n// which uses lwip_ntohl without parentheses\n// so the #define from lwip/def.h doesn't work\n#undef lwip_ntohl\n#define lwip_ntohl lwip_htonl\n</code></pre>"},{"location":"ltapi/dir_117c171b5277df11652dc53a144cb684/","title":"Dir cores/common/base/config","text":"<p>FileList &gt; base &gt; config</p>"},{"location":"ltapi/dir_117c171b5277df11652dc53a144cb684/#files","title":"Files","text":"Type Name     file fal_cfg.h    file fdb_cfg.h    file lwipopts.h    file printf_config.h      <p>The documentation for this class was generated from the following file <code>cores/common/base/config/</code></p>"},{"location":"ltapi/fal__cfg_8h/","title":"File fal_cfg.h","text":"<p>FileList &gt; base &gt; config &gt; fal_cfg.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fal_def.h&gt;</code></li> </ul>"},{"location":"ltapi/fal__cfg_8h/#public-attributes","title":"Public Attributes","text":"Type Name     fal_partition_t fal_root_part \"Root\" partition entry, representing the entire flash. Declared and initialized in lt_main.c.   const struct fal_flash_dev flash0"},{"location":"ltapi/fal__cfg_8h/#public-functions","title":"Public Functions","text":"Type Name     void printf_nop (const char * fmt, ...)"},{"location":"ltapi/fal__cfg_8h/#macros","title":"Macros","text":"Type Name     define FAL_DEBUG  0   define FAL_DEV_NAME_MAX  16   define FAL_FLASH_DEV_NAME  \"flash0\"   define FAL_FLASH_DEV_TABLE    define FAL_PART_HAS_TABLE_CFG    define FAL_PART_TABLE_ITEM (part_lower, part_upper)    define FAL_PRINTF  printf_nop"},{"location":"ltapi/fal__cfg_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#variable-fal_root_part","title":"variable fal_root_part","text":"<pre><code>fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#variable-flash0","title":"variable flash0","text":"<pre><code>const struct fal_flash_dev flash0;\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#function-printf_nop","title":"function printf_nop","text":"<pre><code>inline void printf_nop (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#define-fal_debug","title":"define FAL_DEBUG","text":"<pre><code>#define FAL_DEBUG 0\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_dev_name_max","title":"define FAL_DEV_NAME_MAX","text":"<pre><code>#define FAL_DEV_NAME_MAX 16\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_flash_dev_name","title":"define FAL_FLASH_DEV_NAME","text":"<pre><code>#define FAL_FLASH_DEV_NAME \"flash0\"\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_flash_dev_table","title":"define FAL_FLASH_DEV_TABLE","text":"<pre><code>#define FAL_FLASH_DEV_TABLE {                       \\\n        &amp;flash0,            \\\n    }\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_part_has_table_cfg","title":"define FAL_PART_HAS_TABLE_CFG","text":"<pre><code>#define FAL_PART_HAS_TABLE_CFG \n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_part_table_item","title":"define FAL_PART_TABLE_ITEM","text":"<pre><code>#define FAL_PART_TABLE_ITEM (\n    part_lower,\n    part_upper\n) {                                                                                               \\\n        .magic_word = FAL_PART_MAGIC_WORD,         /* magic word */                                 \\\n        .name       = #part_lower,                 /* lowercase name as string */                   \\\n        .flash_name = FAL_FLASH_DEV_NAME,          /* flash device name */                          \\\n        .offset     = FLASH_##part_upper##_OFFSET, /* partition offset macro as uppercase string */ \\\n        .len        = FLASH_##part_upper##_LENGTH, /* partition length macro as uppercase string */ \\\n    },\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_printf","title":"define FAL_PRINTF","text":"<pre><code>#define FAL_PRINTF printf_nop\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/config/fal_cfg.h</code></p>"},{"location":"ltapi/fal__cfg_8h_source/","title":"File fal_cfg.h","text":"<p>File List &gt; base &gt; config &gt; fal_cfg.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-24. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\ninline void printf_nop(const char *fmt, ...) {}\n\n#define FAL_PRINTF printf_nop\n#define FAL_DEBUG  0\n\n// Flash device configuration\nextern const struct fal_flash_dev flash0;\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#define FAL_FLASH_DEV_NAME \"flash0\"\n\n#define FAL_FLASH_DEV_TABLE \\\n    {                       \\\n        &amp;flash0,            \\\n    }\n\n#define FAL_DEV_NAME_MAX 16 // no need for 24 chars (default)\n\n// Partition table\n#define FAL_PART_HAS_TABLE_CFG\n\n#define FAL_PART_TABLE_ITEM(part_lower, part_upper)                                                 \\\n    {                                                                                               \\\n        .magic_word = FAL_PART_MAGIC_WORD,         /* magic word */                                 \\\n        .name       = #part_lower,                 /* lowercase name as string */                   \\\n        .flash_name = FAL_FLASH_DEV_NAME,          /* flash device name */                          \\\n        .offset     = FLASH_##part_upper##_OFFSET, /* partition offset macro as uppercase string */ \\\n        .len        = FLASH_##part_upper##_LENGTH, /* partition length macro as uppercase string */ \\\n    },\n\n// for fal_partition_t\n#include &lt;fal_def.h&gt;\n\nextern fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/","title":"File fdb_cfg.h","text":"<p>FileList &gt; base &gt; config &gt; fdb_cfg.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/fdb__cfg_8h/#macros","title":"Macros","text":"Type Name     define FDB_PRINT (...)    define FDB_USING_FAL_MODE    define FDB_USING_KVDB    define FDB_WRITE_GRAN  8"},{"location":"ltapi/fdb__cfg_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/fdb__cfg_8h/#define-fdb_print","title":"define FDB_PRINT","text":"<pre><code>#define FDB_PRINT (\n    ...\n) \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_using_fal_mode","title":"define FDB_USING_FAL_MODE","text":"<pre><code>#define FDB_USING_FAL_MODE \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_using_kvdb","title":"define FDB_USING_KVDB","text":"<pre><code>#define FDB_USING_KVDB \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_write_gran","title":"define FDB_WRITE_GRAN","text":"<pre><code>#define FDB_WRITE_GRAN 8\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/config/fdb_cfg.h</code></p>"},{"location":"ltapi/fdb__cfg_8h_source/","title":"File fdb_cfg.h","text":"<p>File List &gt; base &gt; config &gt; fdb_cfg.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * Copyright (c) 2020, Armink, &lt;armink.ztl@gmail.com&gt;\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef _FDB_CFG_H_\n#define _FDB_CFG_H_\n\n/* using KVDB feature */\n#define FDB_USING_KVDB\n\n#ifdef FDB_USING_KVDB\n/* Auto update KV to latest default when current KVDB version number is changed. @see fdb_kvdb.ver_num */\n// #define FDB_KV_AUTO_UPDATE\n#endif\n\n/* using TSDB (Time series database) feature */\n// #define FDB_USING_TSDB\n\n/* Using FAL storage mode */\n#define FDB_USING_FAL_MODE\n\n#ifdef FDB_USING_FAL_MODE\n/* the flash write granularity, unit: bit\n * only support 1(nor flash)/ 8(stm32f2/f4)/ 32(stm32f1) */\n#define FDB_WRITE_GRAN 8\n#endif\n\n/* Using file storage mode by LIBC file API, like fopen/fread/fwrte/fclose */\n// #define FDB_USING_FILE_LIBC_MODE\n\n/* Using file storage mode by POSIX file API, like open/read/write/close */\n// #define FDB_USING_FILE_POSIX_MODE\n\n/* MCU Endian Configuration, default is Little Endian Order. */\n// #define FDB_BIG_ENDIAN\n\n#if LT_DEBUG_FDB\n#include &lt;libretiny.h&gt;\n#include &lt;printf/printf.h&gt;\n#define FDB_PRINT(...) __wrap_printf(__VA_ARGS__)\n#define FDB_DEBUG_ENABLE\n#else\n#define FDB_PRINT(...)\n#endif\n\n#endif /* _FDB_CFG_H_ */\n</code></pre>"},{"location":"ltapi/lwipopts_8h/","title":"File lwipopts.h","text":"<p>FileList &gt; base &gt; config &gt; lwipopts.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;sys/time.h&gt;</code></li> </ul>"},{"location":"ltapi/lwipopts_8h/#macros","title":"Macros","text":"Type Name     define LWIP_MDNS_RESPONDER  1   define LWIP_NETIF_HOSTNAME  1   define LWIP_SO_RCVBUF  1   define LWIP_TIMEVAL_PRIVATE  0   define LWIP_VERSION_SIMPLE  (LWIP_VERSION_MAJOR * 10000 + LWIP_VERSION_MINOR * 100 + LWIP_VERSION_REVISION)   define MDNS_MAX_SERVICES  10   define SNTP_GET_SYSTEM_TIME (sec, us)    define SNTP_SERVER_DNS  1   define SNTP_SET_SYSTEM_TIME_US (sec, us)"},{"location":"ltapi/lwipopts_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lwipopts_8h/#define-lwip_mdns_responder","title":"define LWIP_MDNS_RESPONDER","text":"<pre><code>#define LWIP_MDNS_RESPONDER 1\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-lwip_netif_hostname","title":"define LWIP_NETIF_HOSTNAME","text":"<pre><code>#define LWIP_NETIF_HOSTNAME 1\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-lwip_so_rcvbuf","title":"define LWIP_SO_RCVBUF","text":"<pre><code>#define LWIP_SO_RCVBUF 1\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-lwip_timeval_private","title":"define LWIP_TIMEVAL_PRIVATE","text":"<pre><code>#define LWIP_TIMEVAL_PRIVATE 0\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-lwip_version_simple","title":"define LWIP_VERSION_SIMPLE","text":"<pre><code>#define LWIP_VERSION_SIMPLE (LWIP_VERSION_MAJOR * 10000 + LWIP_VERSION_MINOR * 100 + LWIP_VERSION_REVISION)\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-mdns_max_services","title":"define MDNS_MAX_SERVICES","text":"<pre><code>#define MDNS_MAX_SERVICES 10\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-sntp_get_system_time","title":"define SNTP_GET_SYSTEM_TIME","text":"<pre><code>#define SNTP_GET_SYSTEM_TIME (\n    sec,\n    us\n) do {                                                 \\\n        struct timeval tv = {.tv_sec = 0, .tv_usec = 0}; \\\n        gettimeofday(&amp;tv, NULL);                         \\\n        (sec) = tv.tv_sec;                               \\\n        (us)  = tv.tv_usec;                              \\\n    } while (0);\n</code></pre>"},{"location":"ltapi/lwipopts_8h/#define-sntp_server_dns","title":"define SNTP_SERVER_DNS","text":"<pre><code>#define SNTP_SERVER_DNS 1\n</code></pre> <p>Set this to 1 to support DNS names (or IP address strings) to set sntp servers One server address/name can be defined as default if SNTP_SERVER_DNS == 1: #define SNTP_SERVER_ADDRESS \"pool.ntp.org\" </p>"},{"location":"ltapi/lwipopts_8h/#define-sntp_set_system_time_us","title":"define SNTP_SET_SYSTEM_TIME_US","text":"<pre><code>#define SNTP_SET_SYSTEM_TIME_US (\n    sec,\n    us\n) do {                                                    \\\n        struct timeval tv = {.tv_sec = sec, .tv_usec = us}; \\\n        settimeofday(&amp;tv, NULL);                            \\\n    } while (0);\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/config/lwipopts.h</code></p>"},{"location":"ltapi/lwipopts_8h_source/","title":"File lwipopts.h","text":"<p>File List &gt; base &gt; config &gt; lwipopts.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-08-26. */\n\n#pragma once\n\n#define LWIP_TIMEVAL_PRIVATE 0\n#define LWIP_NETIF_HOSTNAME  1 // to support hostname changing\n#define LWIP_SO_RCVBUF       1 // for ioctl(FIONREAD)\n\n#define LWIP_MDNS_RESPONDER 1\n#define MDNS_MAX_SERVICES   10\n\n#include_next \"lwipopts.h\"\n\n#include &lt;sys/time.h&gt;\n\n// set lwIP debugging options according to LT config\n#if LT_DEBUG_LWIP\n// enable main debugging switch\n#undef LWIP_DEBUG\n#define LWIP_DEBUG 1\n// enable all messages\n#undef LWIP_DBG_MIN_LEVEL\n#define LWIP_DBG_MIN_LEVEL 0\n// enable all debugging types\n#undef LWIP_DBG_TYPES_ON\n#define LWIP_DBG_TYPES_ON 0xF8\n// make lwIP use printf() library\n#include &lt;stdio.h&gt;\n#undef LWIP_PLATFORM_DIAG\n// clang-format off\n#define LWIP_PLATFORM_DIAG(x) do { printf x; } while (0)\n// clang-format on\n#endif\n\n#if LT_DEBUG_LWIP_ASSERT\n#undef LWIP_NOASSERT\n#undef LWIP_PLATFORM_ASSERT\n// clang-format off\n#define LWIP_PLATFORM_ASSERT(x) do { printf(\"ASSERT \\\"%s\\\" - %s:%d\\n\", x, __FILE__, __LINE__); while (1) {}; } while (0)\n// clang-format on\n#endif\n\n// lwIP version as a decimal number, with 2 digits for each part (major, minor, patch)\n#define LWIP_VERSION_SIMPLE (LWIP_VERSION_MAJOR * 10000 + LWIP_VERSION_MINOR * 100 + LWIP_VERSION_REVISION)\n\n// remove family-defined debugging options (use lwIP defaults, or user-defined)\n#undef ETHARP_DEBUG\n#undef NETIF_DEBUG\n#undef PBUF_DEBUG\n#undef API_LIB_DEBUG\n#undef API_MSG_DEBUG\n#undef SOCKETS_DEBUG\n#undef ICMP_DEBUG\n#undef IGMP_DEBUG\n#undef INET_DEBUG\n#undef IP_DEBUG\n#undef IP_REASS_DEBUG\n#undef RAW_DEBUG\n#undef MEM_DEBUG\n#undef MEMP_DEBUG\n#undef SYS_DEBUG\n#undef TIMERS_DEBUG\n#undef TCP_DEBUG\n#undef TCP_INPUT_DEBUG\n#undef TCP_FR_DEBUG\n#undef TCP_RTO_DEBUG\n#undef TCP_CWND_DEBUG\n#undef TCP_WND_DEBUG\n#undef TCP_OUTPUT_DEBUG\n#undef TCP_RST_DEBUG\n#undef TCP_QLEN_DEBUG\n#undef UDP_DEBUG\n#undef TCPIP_DEBUG\n#undef SLIP_DEBUG\n#undef DHCP_DEBUG\n#undef AUTOIP_DEBUG\n#undef DNS_DEBUG\n#undef IP6_DEBUG\n#undef MDNS_DEBUG\n\n#undef LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS\n#undef LWIP_PROVIDE_ERRNO\n\n#define SNTP_SERVER_DNS 1\n\n#define SNTP_SET_SYSTEM_TIME_US(sec, us)                    \\\n    do {                                                    \\\n        struct timeval tv = {.tv_sec = sec, .tv_usec = us}; \\\n        settimeofday(&amp;tv, NULL);                            \\\n    } while (0);\n\n#define SNTP_GET_SYSTEM_TIME(sec, us)                    \\\n    do {                                                 \\\n        struct timeval tv = {.tv_sec = 0, .tv_usec = 0}; \\\n        gettimeofday(&amp;tv, NULL);                         \\\n        (sec) = tv.tv_sec;                               \\\n        (us)  = tv.tv_usec;                              \\\n    } while (0);\n</code></pre>"},{"location":"ltapi/printf__config_8h/","title":"File printf_config.h","text":"<p>FileList &gt; base &gt; config &gt; printf_config.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;lt_config.h&gt;</code></li> </ul>"},{"location":"ltapi/printf__config_8h/#public-functions","title":"Public Functions","text":"Type Name     void putchar_p (char c, unsigned long port)"},{"location":"ltapi/printf__config_8h/#macros","title":"Macros","text":"Type Name     define PRINTF_HAS_DISABLE  1   define WRAP_DISABLE_CHECK (name)    define WRAP_DISABLE_DECL (name)    define WRAP_DISABLE_DEF (name)    define WRAP_PRINTF (name)    define WRAP_SNPRINTF (name)    define WRAP_SPRINTF (name)    define WRAP_VPRINTF (name)    define WRAP_VSNPRINTF (name)    define WRAP_VSPRINTF (name)    define printf_  __wrap_printf   define snprintf_  __wrap_snprintf   define sprintf_  __wrap_sprintf   define vprintf_  __wrap_vprintf   define vsnprintf_  __wrap_vsnprintf   define vsprintf_  __wrap_vsprintf"},{"location":"ltapi/printf__config_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/printf__config_8h/#function-putchar_p","title":"function putchar_p","text":"<pre><code>void putchar_p (\n    char c,\n    unsigned long port\n) \n</code></pre>"},{"location":"ltapi/printf__config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/printf__config_8h/#define-printf_has_disable","title":"define PRINTF_HAS_DISABLE","text":"<pre><code>#define PRINTF_HAS_DISABLE 1\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_check","title":"define WRAP_DISABLE_CHECK","text":"<pre><code>#define WRAP_DISABLE_CHECK (\n    name\n) {                            \\\n        if (LT_UART_SILENT_ALL)  \\\n            return 0;            \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_decl","title":"define WRAP_DISABLE_DECL","text":"<pre><code>#define WRAP_DISABLE_DECL (\n    name\n) void __wrap_##name##_disable() {}                   \\\n    void __wrap_##name##_enable() {}                    \\\n    void __wrap_##name##_set(unsigned char disabled) {} \\\n    unsigned char __wrap_##name##_get() {               \\\n        return LT_UART_SILENT_ALL;                      \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_def","title":"define WRAP_DISABLE_DEF","text":"<pre><code>#define WRAP_DISABLE_DEF (\n    name\n) extern void __wrap_##name##_disable();                   \\\n    extern void __wrap_##name##_enable();                    \\\n    extern void __wrap_##name##_set(unsigned char disabled); \\\n    extern unsigned char __wrap_##name##_get();\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_printf","title":"define WRAP_PRINTF","text":"<pre><code>#define WRAP_PRINTF (\n    name\n) WRAP_DISABLE_DECL(name)                      \\\n    int __wrap_##name(const char *format, ...) { \\\n        va_list va;                              \\\n        va_start(va, format);                    \\\n        const int ret = vprintf(format, va);     \\\n        va_end(va);                              \\\n        return ret;                              \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_snprintf","title":"define WRAP_SNPRINTF","text":"<pre><code>#define WRAP_SNPRINTF (\n    name\n) int __wrap_##name(char *s, size_t count, const char *format, ...) { \\\n        va_list va;                                                     \\\n        va_start(va, format);                                           \\\n        const int ret = vsnprintf(s, count, format, va);                \\\n        va_end(va);                                                     \\\n        return ret;                                                     \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_sprintf","title":"define WRAP_SPRINTF","text":"<pre><code>#define WRAP_SPRINTF (\n    name\n) int __wrap_##name(char *s, const char *format, ...) { \\\n        va_list va;                                       \\\n        va_start(va, format);                             \\\n        const int ret = vsprintf(s, format, va);          \\\n        va_end(va);                                       \\\n        return ret;                                       \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vprintf","title":"define WRAP_VPRINTF","text":"<pre><code>#define WRAP_VPRINTF (\n    name\n) WRAP_DISABLE_DECL(name)                              \\\n    int __wrap_##name(const char *format, va_list arg) { \\\n        return vprintf(format, arg);                     \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vsnprintf","title":"define WRAP_VSNPRINTF","text":"<pre><code>#define WRAP_VSNPRINTF (\n    name\n) int __wrap_##name(char *s, size_t count, const char *format, va_list arg) { \\\n        return vsnprintf(s, count, format, arg);                                \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vsprintf","title":"define WRAP_VSPRINTF","text":"<pre><code>#define WRAP_VSPRINTF (\n    name\n) int __wrap_##name(char *s, const char *format, va_list arg) { \\\n        return vsprintf(s, format, arg);                          \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-printf_","title":"define printf_","text":"<pre><code>#define printf_ __wrap_printf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-snprintf_","title":"define snprintf_","text":"<pre><code>#define snprintf_ __wrap_snprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-sprintf_","title":"define sprintf_","text":"<pre><code>#define sprintf_ __wrap_sprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vprintf_","title":"define vprintf_","text":"<pre><code>#define vprintf_ __wrap_vprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vsnprintf_","title":"define vsnprintf_","text":"<pre><code>#define vsnprintf_ __wrap_vsnprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vsprintf_","title":"define vsprintf_","text":"<pre><code>#define vsprintf_ __wrap_vsprintf\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/config/printf_config.h</code></p>"},{"location":"ltapi/printf__config_8h_source/","title":"File printf_config.h","text":"<p>File List &gt; base &gt; config &gt; printf_config.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#pragma once\n\n#include &lt;lt_config.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#define PRINTF_HAS_DISABLE 1\n\n// make printf.c define wrapper functions\n#define printf_    __wrap_printf\n#define sprintf_   __wrap_sprintf\n#define vsprintf_  __wrap_vsprintf\n#define snprintf_  __wrap_snprintf\n#define vsnprintf_ __wrap_vsnprintf\n#define vprintf_   __wrap_vprintf\n\n// declare putchar() method with custom output port\nvoid putchar_p(char c, unsigned long port);\n\n#define WRAP_DISABLE_DEF(name)                               \\\n    extern void __wrap_##name##_disable();                   \\\n    extern void __wrap_##name##_enable();                    \\\n    extern void __wrap_##name##_set(unsigned char disabled); \\\n    extern unsigned char __wrap_##name##_get();\n\n#if !LT_UART_SILENT_ENABLED || LT_UART_SILENT_ALL\n\n#define WRAP_DISABLE_DECL(name)                         \\\n    void __wrap_##name##_disable() {}                   \\\n    void __wrap_##name##_enable() {}                    \\\n    void __wrap_##name##_set(unsigned char disabled) {} \\\n    unsigned char __wrap_##name##_get() {               \\\n        return LT_UART_SILENT_ALL;                      \\\n    }\n\n#define WRAP_DISABLE_CHECK(name) \\\n    {                            \\\n        if (LT_UART_SILENT_ALL)  \\\n            return 0;            \\\n    }\n\n#else // LT_UART_SILENT_ENABLED &amp;&amp; !LT_UART_SILENT_ALL\n\n#define WRAP_DISABLE_DECL(name)                        \\\n    static unsigned char __wrap_##name##_disabled = 0; \\\n    void __wrap_##name##_disable() {                   \\\n        __wrap_##name##_disabled = 1;                  \\\n    }                                                  \\\n    void __wrap_##name##_enable() {                    \\\n        __wrap_##name##_disabled = 0;                  \\\n    }                                                  \\\n    void __wrap_##name##_set(unsigned char disabled) { \\\n        __wrap_##name##_disabled = disabled;           \\\n    }                                                  \\\n    unsigned char __wrap_##name##_get() {              \\\n        return __wrap_##name##_disabled;               \\\n    }\n\n#define WRAP_DISABLE_CHECK(name)      \\\n    {                                 \\\n        if (__wrap_##name##_disabled) \\\n            return 0;                 \\\n    }\n\n#endif // LT_UART_SILENT_ENABLED &amp;&amp; !LT_UART_SILENT_ALL\n\n#if !LT_UART_SILENT_ENABLED\n\n#define WRAP_PRINTF(name)                        \\\n    WRAP_DISABLE_DECL(name)                      \\\n    int __wrap_##name(const char *format, ...) { \\\n        va_list va;                              \\\n        va_start(va, format);                    \\\n        const int ret = vprintf(format, va);     \\\n        va_end(va);                              \\\n        return ret;                              \\\n    }\n\n#define WRAP_VPRINTF(name)                               \\\n    WRAP_DISABLE_DECL(name)                              \\\n    int __wrap_##name(const char *format, va_list arg) { \\\n        return vprintf(format, arg);                     \\\n    }\n\n#elif LT_UART_SILENT_ALL\n\n#define WRAP_PRINTF(name)                        \\\n    WRAP_DISABLE_DECL(name)                      \\\n    int __wrap_##name(const char *format, ...) { \\\n        return 0;                                \\\n    }\n\n#define WRAP_VPRINTF(name)                               \\\n    WRAP_DISABLE_DECL(name)                              \\\n    int __wrap_##name(const char *format, va_list arg) { \\\n        return 0;                                        \\\n    }\n\n#else // !LT_UART_SILENT_ENABLED || !LT_UART_SILENT_ALL\n\n#define WRAP_PRINTF(name)                        \\\n    WRAP_DISABLE_DECL(name)                      \\\n    int __wrap_##name(const char *format, ...) { \\\n        WRAP_DISABLE_CHECK(name);                \\\n        va_list va;                              \\\n        va_start(va, format);                    \\\n        const int ret = vprintf(format, va);     \\\n        va_end(va);                              \\\n        return ret;                              \\\n    }\n\n#define WRAP_VPRINTF(name)                               \\\n    WRAP_DISABLE_DECL(name)                              \\\n    int __wrap_##name(const char *format, va_list arg) { \\\n        WRAP_DISABLE_CHECK(name);                        \\\n        return vprintf(format, arg);                     \\\n    }\n\n#endif // !LT_UART_SILENT_ENABLED || !LT_UART_SILENT_ALL\n\n#define WRAP_SPRINTF(name)                                \\\n    int __wrap_##name(char *s, const char *format, ...) { \\\n        va_list va;                                       \\\n        va_start(va, format);                             \\\n        const int ret = vsprintf(s, format, va);          \\\n        va_end(va);                                       \\\n        return ret;                                       \\\n    }\n\n#define WRAP_SNPRINTF(name)                                             \\\n    int __wrap_##name(char *s, size_t count, const char *format, ...) { \\\n        va_list va;                                                     \\\n        va_start(va, format);                                           \\\n        const int ret = vsnprintf(s, count, format, va);                \\\n        va_end(va);                                                     \\\n        return ret;                                                     \\\n    }\n\n#define WRAP_VSPRINTF(name)                                       \\\n    int __wrap_##name(char *s, const char *format, va_list arg) { \\\n        return vsprintf(s, format, arg);                          \\\n    }\n\n#define WRAP_VSNPRINTF(name)                                                    \\\n    int __wrap_##name(char *s, size_t count, const char *format, va_list arg) { \\\n        return vsnprintf(s, count, format, arg);                                \\\n    }\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_17709fc88a4f25e302be8aa6231cd94b/","title":"Dir cores/common/base/fixups","text":"<p>FileList &gt; base &gt; fixups</p>"},{"location":"ltapi/dir_17709fc88a4f25e302be8aa6231cd94b/#files","title":"Files","text":"Type Name     file errno.h    file malloc.c"},{"location":"ltapi/dir_17709fc88a4f25e302be8aa6231cd94b/#directories","title":"Directories","text":"Type Name     dir lwip      <p>The documentation for this class was generated from the following file <code>cores/common/base/fixups/</code></p>"},{"location":"ltapi/dir_07703e3b72c625f10ef9850082fac0e3/","title":"Dir cores/common/base/fixups/lwip","text":"<p>FileList &gt; base &gt; fixups &gt; lwip</p>"},{"location":"ltapi/dir_07703e3b72c625f10ef9850082fac0e3/#files","title":"Files","text":"Type Name     file errno.h      <p>The documentation for this class was generated from the following file <code>cores/common/base/fixups/lwip/</code></p>"},{"location":"ltapi/lwip_2errno_8h/","title":"File errno.h","text":"<p>FileList &gt; base &gt; fixups &gt; lwip &gt; errno.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"../errno.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/fixups/lwip/errno.h</code></p>"},{"location":"ltapi/lwip_2errno_8h_source/","title":"File errno.h","text":"<p>File List &gt; base &gt; fixups &gt; lwip &gt; errno.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-13. */\n\n#pragma once\n\n#include \"../errno.h\"\n</code></pre>"},{"location":"ltapi/errno_8h/","title":"File errno.h","text":"<p>FileList &gt; base &gt; fixups &gt; errno.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;sys/errno.h&gt;</code></li> </ul>"},{"location":"ltapi/errno_8h/#public-attributes","title":"Public Attributes","text":"Type Name     int errno"},{"location":"ltapi/errno_8h/#macros","title":"Macros","text":"Type Name     define errno  errno"},{"location":"ltapi/errno_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/errno_8h/#variable-errno","title":"variable errno","text":"<pre><code>int errno;\n</code></pre>"},{"location":"ltapi/errno_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/errno_8h/#define-errno","title":"define errno","text":"<pre><code>#define errno errno\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/fixups/errno.h</code></p>"},{"location":"ltapi/errno_8h_source/","title":"File errno.h","text":"<p>File List &gt; base &gt; fixups &gt; errno.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-13. */\n\n#pragma once\n\n// This is an attempt to bring at least some order to &lt;errno.h&gt;, as\n// it's generally a source of problems everywhere.\n// The idea is that all units will try to import this errno.h first,\n// which means it won't use lwIP's error codes.\n// The code below was moved from realtek-ambz/fixups during\n// porting of BK72XX SDK, when the errno stroke again.\n\n// There are two different errno's:\n// - first is just an int\n// - second is a macro that calls __errno()\n// Here the first option is ensured in the entire project.\n#include &lt;sys/errno.h&gt; // use system __errno() &amp; error codes\n#undef errno           // undefine __errno() macro\nextern int errno;      // use a global errno variable\n#define errno errno    // for #ifdef errno in lwIP\n\n// make sure lwIP never defines its own error codes\n#undef LWIP_PROVIDE_ERRNO\n</code></pre>"},{"location":"ltapi/malloc_8c/","title":"File malloc.c","text":"<p>FileList &gt; base &gt; fixups &gt; malloc.c</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/malloc_8c/#public-functions","title":"Public Functions","text":"Type Name     void * __wrap_zalloc (size_t size)"},{"location":"ltapi/malloc_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/malloc_8c/#function-__wrap_zalloc","title":"function __wrap_zalloc","text":"<pre><code>void * __wrap_zalloc (\n    size_t size\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/fixups/malloc.c</code></p>"},{"location":"ltapi/malloc_8c_source/","title":"File malloc.c","text":"<p>File List &gt; base &gt; fixups &gt; malloc.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-03. */\n\n// Generic implementation of malloc() family wrappers for FreeRTOS\n\n#if LT_HAS_FREERTOS\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;FreeRTOS.h&gt;\n\n// no such thing in FreeRTOS, but present on most vendor SDKs\nextern void *LT_REALLOC_FUNC(void *pv, size_t xWantedSize);\n\nvoid *__wrap_malloc(size_t size) {\n    return pvPortMalloc(size);\n}\n\nvoid *__wrap_calloc(size_t num, size_t size) {\n    void *ptr;\n    if (num == 0 || size == 0)\n        num = size = 1;\n    ptr = pvPortMalloc(num * size);\n    if (ptr)\n        memset(ptr, 0, num * size);\n    return ptr;\n}\n\nvoid *__wrap_realloc(void *ptr, size_t new_size) {\n#if LT_REMALLOC\n    void *nptr = pvPortMalloc(new_size);\n    if (nptr) {\n        memcpy(nptr, ptr, new_size);\n        vPortFree(ptr);\n    }\n    return nptr;\n#else\n    return LT_REALLOC_FUNC(ptr, new_size);\n#endif\n}\n\nvoid __wrap_free(void *ptr) {\n    vPortFree(ptr);\n}\n\n// Mind the 'reent' parameter - do NOT define these as linker aliases!\n\nvoid *__wrap__malloc_r(void *reent, size_t size) {\n    return pvPortMalloc(size);\n}\n\nvoid *__wrap__calloc_r(void *reent, size_t num, size_t size) {\n    void *ptr;\n    if (num == 0 || size == 0)\n        num = size = 1;\n    ptr = pvPortMalloc(num * size);\n    if (ptr)\n        memset(ptr, 0, num * size);\n    return ptr;\n}\n\nvoid *__wrap__realloc_r(void *reent, void *ptr, size_t new_size) {\n#if LT_REMALLOC\n    void *nptr = pvPortMalloc(new_size);\n    if (nptr) {\n        memcpy(nptr, ptr, new_size);\n        vPortFree(ptr);\n    }\n    return nptr;\n#else\n    return LT_REALLOC_FUNC(ptr, new_size);\n#endif\n}\n\nvoid __wrap__free_r(void *reent, void *ptr) {\n    vPortFree(ptr);\n}\n\n#endif\n\n// Additionally, define zalloc() as a shorthand to calloc() - some implementation use it\n\nvoid *__wrap_zalloc(size_t size) {\n    return __wrap_calloc(1, size);\n}\n\n__attribute__((alias(\"__wrap_zalloc\"), weak)) void *zalloc(size_t size);\n</code></pre>"},{"location":"ltapi/dir_846e8f2c00731a5babdd912d0551347c/","title":"Dir cores/common/base/posix","text":"<p>FileList &gt; base &gt; posix</p>"},{"location":"ltapi/dir_846e8f2c00731a5babdd912d0551347c/#files","title":"Files","text":"Type Name     file itoa.c    file strcasecmp.c    file strdup.c    file strptime.c      <p>The documentation for this class was generated from the following file <code>cores/common/base/posix/</code></p>"},{"location":"ltapi/itoa_8c/","title":"File itoa.c","text":"<p>FileList &gt; base &gt; posix &gt; itoa.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/itoa_8c/#public-functions","title":"Public Functions","text":"Type Name     char * itoa (int value, char * string, int radix)    char * ltoa (long value, char * string, int radix)    char * ultoa (unsigned long value, char * string, int radix)    char * utoa (unsigned int value, char * string, int radix)"},{"location":"ltapi/itoa_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/itoa_8c/#function-itoa","title":"function itoa","text":"<pre><code>char * itoa (\n    int value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-ltoa","title":"function ltoa","text":"<pre><code>char * ltoa (\n    long value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-ultoa","title":"function ultoa","text":"<pre><code>char * ultoa (\n    unsigned long value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-utoa","title":"function utoa","text":"<pre><code>char * utoa (\n    unsigned int value,\n    char * string,\n    int radix\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/posix/itoa.c</code></p>"},{"location":"ltapi/itoa_8c_source/","title":"File itoa.c","text":"<p>File List &gt; base &gt; posix &gt; itoa.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;string.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nchar *ltoa(long value, char *string, int radix) {\n    char tmp[33];\n    char *tp = tmp;\n    long i;\n    unsigned long v;\n    int sign;\n    char *sp;\n\n    if (string == NULL) {\n        return 0;\n    }\n\n    if (radix &gt; 36 || radix &lt;= 1) {\n        return 0;\n    }\n\n    sign = (radix == 10 &amp;&amp; value &lt; 0);\n    if (sign) {\n        v = -value;\n    } else {\n        v = (unsigned long)value;\n    }\n\n    while (v || tp == tmp) {\n        i = v % radix;\n        v = v / radix;\n        if (i &lt; 10)\n            *tp++ = i + '0';\n        else\n            *tp++ = i + 'a' - 10;\n    }\n\n    sp = string;\n\n    if (sign)\n        *sp++ = '-';\n    while (tp &gt; tmp)\n        *sp++ = *--tp;\n    *sp = 0;\n\n    return string;\n}\n\nchar *ultoa(unsigned long value, char *string, int radix) {\n    char tmp[33];\n    char *tp = tmp;\n    long i;\n    unsigned long v = value;\n    char *sp;\n\n    if (string == NULL) {\n        return 0;\n    }\n\n    if (radix &gt; 36 || radix &lt;= 1) {\n        return 0;\n    }\n\n    while (v || tp == tmp) {\n        i = v % radix;\n        v = v / radix;\n        if (i &lt; 10)\n            *tp++ = i + '0';\n        else\n            *tp++ = i + 'a' - 10;\n    }\n\n    sp = string;\n\n    while (tp &gt; tmp)\n        *sp++ = *--tp;\n    *sp = 0;\n\n    return string;\n}\n\nchar *itoa(int value, char *string, int radix) {\n    return ltoa(value, string, radix);\n}\n\nchar *utoa(unsigned int value, char *string, int radix) {\n    return ultoa(value, string, radix);\n}\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/","title":"File strcasecmp.c","text":"<p>FileList &gt; base &gt; posix &gt; strcasecmp.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/strcasecmp_8c/#public-types","title":"Public Types","text":"Type Name     typedef unsigned char u_char"},{"location":"ltapi/strcasecmp_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const u_char charmap"},{"location":"ltapi/strcasecmp_8c/#public-functions","title":"Public Functions","text":"Type Name     int strcasecmp (const char * s1, const char * s2)    int strncasecmp (const char * s1, const char * s2, size_t n)"},{"location":"ltapi/strcasecmp_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#typedef-u_char","title":"typedef u_char","text":"<pre><code>typedef unsigned char u_char;\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#variable-charmap","title":"variable charmap","text":"<pre><code>const u_char charmap[];\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#function-strcasecmp","title":"function strcasecmp","text":"<pre><code>int strcasecmp (\n    const char * s1,\n    const char * s2\n) \n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#function-strncasecmp","title":"function strncasecmp","text":"<pre><code>int strncasecmp (\n    const char * s1,\n    const char * s2,\n    size_t n\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/posix/strcasecmp.c</code></p>"},{"location":"ltapi/strcasecmp_8c_source/","title":"File strcasecmp.c","text":"<p>File List &gt; base &gt; posix &gt; strcasecmp.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*  $OpenBSD: strcasecmp.c,v 1.6 2005/08/08 08:05:37 espie Exp $    */\n/*\n * Copyright (c) 1987, 1993\n *  The Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include &lt;string.h&gt;\ntypedef unsigned char u_char;\n/*\n * This array is designed for mapping upper and lower case letter\n * together for a case independent comparison.  The mappings are\n * based upon ascii character sequences.\n */\nstatic const u_char charmap[] = {\n    '\\000', '\\001', '\\002', '\\003', '\\004', '\\005', '\\006', '\\007',\n    '\\010', '\\011', '\\012', '\\013', '\\014', '\\015', '\\016', '\\017',\n    '\\020', '\\021', '\\022', '\\023', '\\024', '\\025', '\\026', '\\027',\n    '\\030', '\\031', '\\032', '\\033', '\\034', '\\035', '\\036', '\\037',\n    '\\040', '\\041', '\\042', '\\043', '\\044', '\\045', '\\046', '\\047',\n    '\\050', '\\051', '\\052', '\\053', '\\054', '\\055', '\\056', '\\057',\n    '\\060', '\\061', '\\062', '\\063', '\\064', '\\065', '\\066', '\\067',\n    '\\070', '\\071', '\\072', '\\073', '\\074', '\\075', '\\076', '\\077',\n    '\\100', '\\141', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n    '\\150', '\\151', '\\152', '\\153', '\\154', '\\155', '\\156', '\\157',\n    '\\160', '\\161', '\\162', '\\163', '\\164', '\\165', '\\166', '\\167',\n    '\\170', '\\171', '\\172', '\\133', '\\134', '\\135', '\\136', '\\137',\n    '\\140', '\\141', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n    '\\150', '\\151', '\\152', '\\153', '\\154', '\\155', '\\156', '\\157',\n    '\\160', '\\161', '\\162', '\\163', '\\164', '\\165', '\\166', '\\167',\n    '\\170', '\\171', '\\172', '\\173', '\\174', '\\175', '\\176', '\\177',\n    '\\200', '\\201', '\\202', '\\203', '\\204', '\\205', '\\206', '\\207',\n    '\\210', '\\211', '\\212', '\\213', '\\214', '\\215', '\\216', '\\217',\n    '\\220', '\\221', '\\222', '\\223', '\\224', '\\225', '\\226', '\\227',\n    '\\230', '\\231', '\\232', '\\233', '\\234', '\\235', '\\236', '\\237',\n    '\\240', '\\241', '\\242', '\\243', '\\244', '\\245', '\\246', '\\247',\n    '\\250', '\\251', '\\252', '\\253', '\\254', '\\255', '\\256', '\\257',\n    '\\260', '\\261', '\\262', '\\263', '\\264', '\\265', '\\266', '\\267',\n    '\\270', '\\271', '\\272', '\\273', '\\274', '\\275', '\\276', '\\277',\n    '\\300', '\\301', '\\302', '\\303', '\\304', '\\305', '\\306', '\\307',\n    '\\310', '\\311', '\\312', '\\313', '\\314', '\\315', '\\316', '\\317',\n    '\\320', '\\321', '\\322', '\\323', '\\324', '\\325', '\\326', '\\327',\n    '\\330', '\\331', '\\332', '\\333', '\\334', '\\335', '\\336', '\\337',\n    '\\340', '\\341', '\\342', '\\343', '\\344', '\\345', '\\346', '\\347',\n    '\\350', '\\351', '\\352', '\\353', '\\354', '\\355', '\\356', '\\357',\n    '\\360', '\\361', '\\362', '\\363', '\\364', '\\365', '\\366', '\\367',\n    '\\370', '\\371', '\\372', '\\373', '\\374', '\\375', '\\376', '\\377',\n};\nint\nstrcasecmp(const char *s1, const char *s2)\n{\n    const u_char *cm = charmap;\n    const u_char *us1 = (const u_char *)s1;\n    const u_char *us2 = (const u_char *)s2;\n    while (cm[*us1] == cm[*us2++])\n        if (*us1++ == '\\0')\n            return (0);\n    return (cm[*us1] - cm[*--us2]);\n}\nint\nstrncasecmp(const char *s1, const char *s2, size_t n)\n{\n    if (n != 0) {\n        const u_char *cm = charmap;\n        const u_char *us1 = (const u_char *)s1;\n        const u_char *us2 = (const u_char *)s2;\n        do {\n            if (cm[*us1] != cm[*us2++])\n                return (cm[*us1] - cm[*--us2]);\n            if (*us1++ == '\\0')\n                break;\n        } while (--n != 0);\n    }\n    return (0);\n}\n</code></pre>"},{"location":"ltapi/strdup_8c/","title":"File strdup.c","text":"<p>FileList &gt; base &gt; posix &gt; strdup.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/strdup_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/strdup_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strdup_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/posix/strdup.c</code></p>"},{"location":"ltapi/strdup_8c_source/","title":"File strdup.c","text":"<p>File List &gt; base &gt; posix &gt; strdup.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-16. */\n\n#include &lt;stddef.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n__attribute__((weak)) char *strdup(const char *s) {\n    size_t len = strlen(s) + 1;\n    void *newp = malloc(len);\n    if (newp == NULL)\n        return NULL;\n    return (char *)memcpy(newp, s, len);\n}\n</code></pre>"},{"location":"ltapi/strptime_8c/","title":"File strptime.c","text":"<p>FileList &gt; base &gt; posix &gt; strptime.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;langinfo.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> <li><code>#include &lt;ctype.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;strings.h&gt;</code></li> </ul>"},{"location":"ltapi/strptime_8c/#public-functions","title":"Public Functions","text":"Type Name     char * strptime (const char *restrict s, const char *restrict f, struct tm *restrict tm)"},{"location":"ltapi/strptime_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strptime_8c/#function-strptime","title":"function strptime","text":"<pre><code>char * strptime (\n    const char *restrict s,\n    const char *restrict f,\n    struct tm *restrict tm\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/posix/strptime.c</code></p>"},{"location":"ltapi/strptime_8c_source/","title":"File strptime.c","text":"<p>File List &gt; base &gt; posix &gt; strptime.c</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;langinfo.h&gt;\n#include &lt;time.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;string.h&gt;\n#include &lt;strings.h&gt;\n\nchar *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)\n{\n    int i, w, neg, adj, min, range, *dest, dummy;\n    const char *ex;\n    size_t len;\n    int want_century = 0, century = 0;\n    while (*f) {\n        if (*f != '%') {\n            if (isspace(*f)) for (; *s &amp;&amp; isspace(*s); s++);\n            else if (*s != *f) return 0;\n            else s++;\n            f++;\n            continue;\n        }\n        f++;\n        if (*f == '+') f++;\n        if (isdigit(*f)) w=strtoul(f, (void *)&amp;f, 10);\n        else w=-1;\n        adj=0;\n        switch (*f++) {\n        case 'a': case 'A':\n            dest = &amp;tm-&gt;tm_wday;\n            min = ABDAY_1;\n            range = 7;\n            goto symbolic_range;\n        case 'b': case 'B': case 'h':\n            dest = &amp;tm-&gt;tm_mon;\n            min = ABMON_1;\n            range = 12;\n            goto symbolic_range;\n        case 'c':\n            s = strptime(s, nl_langinfo(D_T_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'C':\n            dest = &amp;century;\n            if (w&lt;0) w=2;\n            want_century |= 2;\n            goto numeric_digits;\n        case 'd': case 'e':\n            dest = &amp;tm-&gt;tm_mday;\n            min = 1;\n            range = 31;\n            goto numeric_range;\n        case 'D':\n            s = strptime(s, \"%m/%d/%y\", tm);\n            if (!s) return 0;\n            break;\n        case 'H':\n            dest = &amp;tm-&gt;tm_hour;\n            min = 0;\n            range = 24;\n            goto numeric_range;\n        case 'I':\n            dest = &amp;tm-&gt;tm_hour;\n            min = 1;\n            range = 12;\n            goto numeric_range;\n        case 'j':\n            dest = &amp;tm-&gt;tm_yday;\n            min = 1;\n            range = 366;\n            goto numeric_range;\n        case 'm':\n            dest = &amp;tm-&gt;tm_mon;\n            min = 1;\n            range = 12;\n            adj = 1;\n            goto numeric_range;\n        case 'M':\n            dest = &amp;tm-&gt;tm_min;\n            min = 0;\n            range = 60;\n            goto numeric_range;\n        case 'n': case 't':\n            for (; *s &amp;&amp; isspace(*s); s++);\n            break;\n        case 'p':\n            ex = nl_langinfo(AM_STR);\n            len = strlen(ex);\n            if (!strncasecmp(s, ex, len)) {\n                tm-&gt;tm_hour %= 12;\n                break;\n            }\n            ex = nl_langinfo(PM_STR);\n            len = strlen(ex);\n            if (!strncasecmp(s, ex, len)) {\n                tm-&gt;tm_hour %= 12;\n                tm-&gt;tm_hour += 12;\n                break;\n            }\n            return 0;\n        case 'r':\n            s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);\n            if (!s) return 0;\n            break;\n        case 'R':\n            s = strptime(s, \"%H:%M\", tm);\n            if (!s) return 0;\n            break;\n        case 'S':\n            dest = &amp;tm-&gt;tm_sec;\n            min = 0;\n            range = 61;\n            goto numeric_range;\n        case 'T':\n            s = strptime(s, \"%H:%M:%S\", tm);\n            if (!s) return 0;\n            break;\n        case 'U':\n        case 'W':\n            /* Throw away result, for now. (FIXME?) */\n            dest = &amp;dummy;\n            min = 0;\n            range = 54;\n            goto numeric_range;\n        case 'w':\n            dest = &amp;tm-&gt;tm_wday;\n            min = 0;\n            range = 7;\n            goto numeric_range;\n        case 'x':\n            s = strptime(s, nl_langinfo(D_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'X':\n            s = strptime(s, nl_langinfo(T_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'y':\n            dest = &amp;tm-&gt;tm_year;\n            w = 2;\n            want_century |= 1;\n            goto numeric_digits;\n        case 'Y':\n            dest = &amp;tm-&gt;tm_year;\n            if (w&lt;0) w=4;\n            adj = 1900;\n            want_century = 0;\n            goto numeric_digits;\n        case '%':\n            if (*s++ != '%') return 0;\n            break;\n        default:\n            return 0;\n        numeric_range:\n            if (!isdigit(*s)) return 0;\n            *dest = 0;\n            for (i=1; i&lt;=min+range &amp;&amp; isdigit(*s); i*=10)\n                *dest = *dest * 10 + *s++ - '0';\n            if (*dest - min &gt;= (unsigned)range) return 0;\n            *dest -= adj;\n            switch((char *)dest - (char *)tm) {\n            case offsetof(struct tm, tm_yday):\n                ;\n            }\n            goto update;\n        numeric_digits:\n            neg = 0;\n            if (*s == '+') s++;\n            else if (*s == '-') neg=1, s++;\n            if (!isdigit(*s)) return 0;\n            for (*dest=i=0; i&lt;w &amp;&amp; isdigit(*s); i++)\n                *dest = *dest * 10 + *s++ - '0';\n            if (neg) *dest = -*dest;\n            *dest -= adj;\n            goto update;\n        symbolic_range:\n            for (i=2*range-1; i&gt;=0; i--) {\n                ex = nl_langinfo(min+i);\n                len = strlen(ex);\n                if (strncasecmp(s, ex, len)) continue;\n                s += len;\n                *dest = i % range;\n                break;\n            }\n            if (i&lt;0) return 0;\n            goto update;\n        update:\n            //FIXME\n            ;\n        }\n    }\n    if (want_century) {\n        if (want_century &amp; 2) tm-&gt;tm_year += century * 100 - 1900;\n        else if (tm-&gt;tm_year &lt;= 68) tm-&gt;tm_year += 100;\n    }\n    return (char *)s;\n}\n</code></pre>"},{"location":"ltapi/dir_b483440aeb16b525e6183721aad24145/","title":"Dir cores/common/base/wraps","text":"<p>FileList &gt; base &gt; wraps</p>"},{"location":"ltapi/dir_b483440aeb16b525e6183721aad24145/#files","title":"Files","text":"Type Name     file putchar.c    file puts.c      <p>The documentation for this class was generated from the following file <code>cores/common/base/wraps/</code></p>"},{"location":"ltapi/putchar_8c/","title":"File putchar.c","text":"<p>FileList &gt; base &gt; wraps &gt; putchar.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;printf/printf.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"ltapi/putchar_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_putchar (int c)"},{"location":"ltapi/putchar_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/putchar_8c/#function-__wrap_putchar","title":"function __wrap_putchar","text":"<pre><code>int __wrap_putchar (\n    int c\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/wraps/putchar.c</code></p>"},{"location":"ltapi/putchar_8c_source/","title":"File putchar.c","text":"<p>File List &gt; base &gt; wraps &gt; putchar.c</p> <p>Go to the documentation of this file. </p> <pre><code>// https://github.com/embeddedartistry/libc/blob/master/src/stdio/putchar.c\n\n#include &lt;printf/printf.h&gt;\n#include &lt;stdio.h&gt;\n\nint __wrap_putchar(int c) {\n    putchar_((char)c);\n    return c;\n}\n</code></pre>"},{"location":"ltapi/puts_8c/","title":"File puts.c","text":"<p>FileList &gt; base &gt; wraps &gt; puts.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;printf/printf.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"ltapi/puts_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_puts (const char * str)"},{"location":"ltapi/puts_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/puts_8c/#function-__wrap_puts","title":"function __wrap_puts","text":"<pre><code>int __wrap_puts (\n    const char * str\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/wraps/puts.c</code></p>"},{"location":"ltapi/puts_8c_source/","title":"File puts.c","text":"<p>File List &gt; base &gt; wraps &gt; puts.c</p> <p>Go to the documentation of this file. </p> <pre><code>// https://github.com/embeddedartistry/libc/blob/master/src/stdio/puts.c\n\n#include &lt;printf/printf.h&gt;\n#include &lt;stdio.h&gt;\n\nint __wrap_puts(const char *str) {\n    int r = 0;\n\n    for (const char *c = str; *c != 0; c++) {\n        putchar_((int)*c);\n        r++;\n    }\n\n    // puts adds a newline\n    if (r) {\n        putchar_('\\n');\n        r++;\n    }\n\n    return r ? r : EOF;\n}\n</code></pre>"},{"location":"ltapi/libretiny_8h/","title":"File libretiny.h","text":"<p>FileList &gt; base &gt; libretiny.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;inttypes.h&gt;</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;stdarg.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include \"lt_config.h\"</code></li> <li><code>#include \"lt_types.h\"</code></li> <li><code>#include &lt;lt_family.h&gt;</code></li> <li><code>#include \"lt_api.h\"</code></li> <li><code>#include \"lt_logger.h\"</code></li> <li><code>#include \"lt_pins.h\"</code></li> <li><code>#include \"lt_posix_api.h\"</code></li> <li><code>#include &lt;printf_port.h&gt;</code></li> </ul>"},{"location":"ltapi/libretiny_8h/#macros","title":"Macros","text":"Type Name     define GCC_VERSION_STR     STRINGIFY_MACRO(__GNUC__) \".\" STRINGIFY_MACRO(__GNUC_MINOR__) \".\" STRINGIFY_MACRO(__GNUC_PATCHLEVEL__)   define LT_BANNER () LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, LT_BANNER_STR)   define LT_BANNER_STR    define LT_BOARD  unknown   define LT_BOARD_STR  STRINGIFY_MACRO(LT_BOARD)   define LT_VERSION  1.0.0   define LT_VERSION_STR  STRINGIFY_MACRO(LT_VERSION)   define STRINGIFY (x) #x   define STRINGIFY_MACRO (x) STRINGIFY(x)"},{"location":"ltapi/libretiny_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/libretiny_8h/#define-gcc_version_str","title":"define GCC_VERSION_STR","text":"<pre><code>#define GCC_VERSION_STR STRINGIFY_MACRO(__GNUC__) \".\" STRINGIFY_MACRO(__GNUC_MINOR__) \".\" STRINGIFY_MACRO(__GNUC_PATCHLEVEL__)\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_banner","title":"define LT_BANNER","text":"<pre><code>#define LT_BANNER (\n\n) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, LT_BANNER_STR)\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_banner_str","title":"define LT_BANNER_STR","text":"<pre><code>#define LT_BANNER_STR \"LibreTiny v\" LT_VERSION_STR \" on \" LT_BOARD_STR \", compiled at \" __DATE__ \" \" __TIME__ \", GCC \" GCC_VERSION_STR \\\n    \" (-O\" STRINGIFY_MACRO(__OPTIMIZE_LEVEL__) \")\"\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_board","title":"define LT_BOARD","text":"<pre><code>#define LT_BOARD unknown\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_board_str","title":"define LT_BOARD_STR","text":"<pre><code>#define LT_BOARD_STR STRINGIFY_MACRO(LT_BOARD)\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_version","title":"define LT_VERSION","text":"<pre><code>#define LT_VERSION 1.0.0\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-lt_version_str","title":"define LT_VERSION_STR","text":"<pre><code>#define LT_VERSION_STR STRINGIFY_MACRO(LT_VERSION)\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-stringify","title":"define STRINGIFY","text":"<pre><code>#define STRINGIFY (\n    x\n) #x\n</code></pre>"},{"location":"ltapi/libretiny_8h/#define-stringify_macro","title":"define STRINGIFY_MACRO","text":"<pre><code>#define STRINGIFY_MACRO (\n    x\n) STRINGIFY(x)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/libretiny.h</code></p>"},{"location":"ltapi/libretiny_8h_source/","title":"File libretiny.h","text":"<p>File List &gt; base &gt; libretiny.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n// C standard libraries\n#include &lt;errno.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// LibreTiny version macros\n#ifndef LT_VERSION\n#define LT_VERSION 1.0.0\n#endif\n#ifndef LT_BOARD\n#define LT_BOARD unknown\n#endif\n#define STRINGIFY(x)       #x\n#define STRINGIFY_MACRO(x) STRINGIFY(x)\n#define LT_VERSION_STR     STRINGIFY_MACRO(LT_VERSION)\n#define LT_BOARD_STR       STRINGIFY_MACRO(LT_BOARD)\n#define GCC_VERSION_STR \\\n    STRINGIFY_MACRO(__GNUC__) \".\" STRINGIFY_MACRO(__GNUC_MINOR__) \".\" STRINGIFY_MACRO(__GNUC_PATCHLEVEL__)\n#define LT_BANNER_STR                                                                                                \\\n    \"LibreTiny v\" LT_VERSION_STR \" on \" LT_BOARD_STR \", compiled at \" __DATE__ \" \" __TIME__ \", GCC \" GCC_VERSION_STR \\\n    \" (-O\" STRINGIFY_MACRO(__OPTIMIZE_LEVEL__) \")\"\n\n// Functional macros\n#define LT_BANNER() LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, LT_BANNER_STR)\n\n// Types &amp; macros\n#include \"lt_config.h\" // platform configuration options\n#include \"lt_types.h\"  // types &amp; enums\n// Family-specific macros\n#include &lt;lt_family.h&gt;\n// Board variant (pin definitions)\n#include LT_VARIANT_H\n// APIs\n#include \"lt_api.h\"       // main API function definitions\n#include \"lt_logger.h\"    // UART logger utility\n#include \"lt_pins.h\"      // additional pin macros\n#include \"lt_posix_api.h\" // POSIX compat functions\n// printf silencing methods\n#include &lt;printf_port.h&gt;\n</code></pre>"},{"location":"ltapi/lt__api_8h/","title":"File lt_api.h","text":"<p>FileList &gt; base &gt; lt_api.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"api/lt_cpu.h\"</code></li> <li><code>#include \"api/lt_device.h\"</code></li> <li><code>#include \"api/lt_flash.h\"</code></li> <li><code>#include \"api/lt_init.h\"</code></li> <li><code>#include \"api/lt_mem.h\"</code></li> <li><code>#include \"api/lt_ota.h\"</code></li> <li><code>#include \"api/lt_sleep.h\"</code></li> <li><code>#include \"api/lt_utils.h\"</code></li> <li><code>#include \"api/lt_wdt.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_api.h</code></p>"},{"location":"ltapi/lt__api_8h_source/","title":"File lt_api.h","text":"<p>File List &gt; base &gt; lt_api.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-03-09. */\n\n#pragma once\n\n// This file collects all LibreTiny C API includes.\n// The functions are implemented in api/*.c units, which are located\n// in the common core, and in the family cores.\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#include \"api/lt_cpu.h\"\n#include \"api/lt_device.h\"\n#include \"api/lt_flash.h\"\n#include \"api/lt_init.h\"\n#include \"api/lt_mem.h\"\n#include \"api/lt_ota.h\"\n#include \"api/lt_sleep.h\"\n#include \"api/lt_utils.h\"\n#include \"api/lt_wdt.h\"\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/lt__config_8h/","title":"File lt_config.h","text":"<p>FileList &gt; base &gt; lt_config.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/lt__config_8h/#macros","title":"Macros","text":"Type Name     define LT_AUTO_DOWNLOAD_REBOOT  1   define LT_DEBUG_ALL  0   define LT_DEBUG_CLIENT  LT_DEBUG_ALL   define LT_DEBUG_FDB  0   define LT_DEBUG_LWIP  0   define LT_DEBUG_LWIP_ASSERT  0   define LT_DEBUG_MDNS  LT_DEBUG_ALL   define LT_DEBUG_OTA  1   define LT_DEBUG_SERVER  LT_DEBUG_ALL   define LT_DEBUG_SSL  LT_DEBUG_ALL   define LT_DEBUG_WIFI  1   define LT_LEVEL_DEBUG  1   define LT_LEVEL_ERROR  4   define LT_LEVEL_FATAL  5   define LT_LEVEL_INFO  2   define LT_LEVEL_NONE  6   define LT_LEVEL_TRACE  0   define LT_LEVEL_VERBOSE  LT_LEVEL_TRACE   define LT_LEVEL_WARN  3   define LT_LOGGER  1   define LT_LOGGER_CALLER  0   define LT_LOGGER_COLOR  0   define LT_LOGGER_TASK  0   define LT_LOGGER_TIMESTAMP  1   define LT_LOGLEVEL  LT_LEVEL_INFO   define LT_LOG_ERRNO  0   define LT_LOG_HEAP  0   define LT_MICROS_HIGH_RES  1   define LT_PRINTF_BROKEN  0   define LT_SERIAL_BUFFER_SIZE  256   define LT_UART_DEFAULT_LOGGER  LT_UART_DEFAULT_PORT   define LT_UART_DEFAULT_SERIAL  LT_UART_DEFAULT_PORT   define LT_UART_SILENT_ALL  0   define LT_UART_SILENT_ENABLED  1   define LT_USE_TIME  0"},{"location":"ltapi/lt__config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__config_8h/#define-lt_auto_download_reboot","title":"define LT_AUTO_DOWNLOAD_REBOOT","text":"<pre><code>#define LT_AUTO_DOWNLOAD_REBOOT 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_all","title":"define LT_DEBUG_ALL","text":"<pre><code>#define LT_DEBUG_ALL 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_client","title":"define LT_DEBUG_CLIENT","text":"<pre><code>#define LT_DEBUG_CLIENT LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_fdb","title":"define LT_DEBUG_FDB","text":"<pre><code>#define LT_DEBUG_FDB 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_lwip","title":"define LT_DEBUG_LWIP","text":"<pre><code>#define LT_DEBUG_LWIP 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_lwip_assert","title":"define LT_DEBUG_LWIP_ASSERT","text":"<pre><code>#define LT_DEBUG_LWIP_ASSERT 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_mdns","title":"define LT_DEBUG_MDNS","text":"<pre><code>#define LT_DEBUG_MDNS LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_ota","title":"define LT_DEBUG_OTA","text":"<pre><code>#define LT_DEBUG_OTA 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_server","title":"define LT_DEBUG_SERVER","text":"<pre><code>#define LT_DEBUG_SERVER LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_ssl","title":"define LT_DEBUG_SSL","text":"<pre><code>#define LT_DEBUG_SSL LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_debug_wifi","title":"define LT_DEBUG_WIFI","text":"<pre><code>#define LT_DEBUG_WIFI 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_debug","title":"define LT_LEVEL_DEBUG","text":"<pre><code>#define LT_LEVEL_DEBUG 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_error","title":"define LT_LEVEL_ERROR","text":"<pre><code>#define LT_LEVEL_ERROR 4\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_fatal","title":"define LT_LEVEL_FATAL","text":"<pre><code>#define LT_LEVEL_FATAL 5\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_info","title":"define LT_LEVEL_INFO","text":"<pre><code>#define LT_LEVEL_INFO 2\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_none","title":"define LT_LEVEL_NONE","text":"<pre><code>#define LT_LEVEL_NONE 6\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_trace","title":"define LT_LEVEL_TRACE","text":"<pre><code>#define LT_LEVEL_TRACE 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_verbose","title":"define LT_LEVEL_VERBOSE","text":"<pre><code>#define LT_LEVEL_VERBOSE LT_LEVEL_TRACE\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_level_warn","title":"define LT_LEVEL_WARN","text":"<pre><code>#define LT_LEVEL_WARN 3\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_logger","title":"define LT_LOGGER","text":"<pre><code>#define LT_LOGGER 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_logger_caller","title":"define LT_LOGGER_CALLER","text":"<pre><code>#define LT_LOGGER_CALLER 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_logger_color","title":"define LT_LOGGER_COLOR","text":"<pre><code>#define LT_LOGGER_COLOR 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_logger_task","title":"define LT_LOGGER_TASK","text":"<pre><code>#define LT_LOGGER_TASK 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_logger_timestamp","title":"define LT_LOGGER_TIMESTAMP","text":"<pre><code>#define LT_LOGGER_TIMESTAMP 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_loglevel","title":"define LT_LOGLEVEL","text":"<pre><code>#define LT_LOGLEVEL LT_LEVEL_INFO\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_log_errno","title":"define LT_LOG_ERRNO","text":"<pre><code>#define LT_LOG_ERRNO 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_log_heap","title":"define LT_LOG_HEAP","text":"<pre><code>#define LT_LOG_HEAP 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_micros_high_res","title":"define LT_MICROS_HIGH_RES","text":"<pre><code>#define LT_MICROS_HIGH_RES 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_printf_broken","title":"define LT_PRINTF_BROKEN","text":"<pre><code>#define LT_PRINTF_BROKEN 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_serial_buffer_size","title":"define LT_SERIAL_BUFFER_SIZE","text":"<pre><code>#define LT_SERIAL_BUFFER_SIZE 256\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_uart_default_logger","title":"define LT_UART_DEFAULT_LOGGER","text":"<pre><code>#define LT_UART_DEFAULT_LOGGER LT_UART_DEFAULT_PORT\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_uart_default_serial","title":"define LT_UART_DEFAULT_SERIAL","text":"<pre><code>#define LT_UART_DEFAULT_SERIAL LT_UART_DEFAULT_PORT\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_uart_silent_all","title":"define LT_UART_SILENT_ALL","text":"<pre><code>#define LT_UART_SILENT_ALL 0\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_uart_silent_enabled","title":"define LT_UART_SILENT_ENABLED","text":"<pre><code>#define LT_UART_SILENT_ENABLED 1\n</code></pre>"},{"location":"ltapi/lt__config_8h/#define-lt_use_time","title":"define LT_USE_TIME","text":"<pre><code>#define LT_USE_TIME 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_config.h</code></p>"},{"location":"ltapi/lt__config_8h_source/","title":"File lt_config.h","text":"<p>File List &gt; base &gt; lt_config.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n// see docs/API Configuration\n\n// Loglevels\n#define LT_LEVEL_VERBOSE LT_LEVEL_TRACE\n#define LT_LEVEL_TRACE   0\n#define LT_LEVEL_DEBUG   1\n#define LT_LEVEL_INFO    2\n#define LT_LEVEL_WARN    3\n#define LT_LEVEL_ERROR   4\n#define LT_LEVEL_FATAL   5\n#define LT_LEVEL_NONE    6\n\n// Logger enabled/disabled\n#ifndef LT_LOGGER\n#define LT_LOGGER 1\n#endif\n\n// Logger format options\n#ifndef LT_LOGGER_TIMESTAMP\n#define LT_LOGGER_TIMESTAMP 1\n#endif\n\n#ifndef LT_LOGGER_CALLER\n#define LT_LOGGER_CALLER 0\n#endif\n\n#ifndef LT_LOGGER_TASK\n#define LT_LOGGER_TASK 0\n#endif\n\n#ifndef LT_LOGGER_COLOR\n#define LT_LOGGER_COLOR 0\n#endif\n\n#ifndef LT_PRINTF_BROKEN\n#define LT_PRINTF_BROKEN 0\n#endif\n\n// Global loglevel\n#ifndef LT_LOGLEVEL\n#define LT_LOGLEVEL LT_LEVEL_INFO\n#endif\n\n#if !LT_LOGGER\n#undef LT_LOGLEVEL\n#define LT_LOGLEVEL LT_LEVEL_NONE\n#endif\n\n// Free heap size debugging\n#ifndef LT_LOG_HEAP\n#define LT_LOG_HEAP 0\n#endif\n\n// Debug errno values using LT_ERRNO()\n#ifndef LT_LOG_ERRNO\n#define LT_LOG_ERRNO 0\n#endif\n\n// Serial output options\n#ifndef LT_UART_SILENT_ENABLED\n#define LT_UART_SILENT_ENABLED 1\n#endif\n\n#ifndef LT_UART_SILENT_ALL\n#define LT_UART_SILENT_ALL 0\n#endif\n\n#ifndef LT_UART_DEFAULT_LOGGER\n#define LT_UART_DEFAULT_LOGGER LT_UART_DEFAULT_PORT\n#endif\n\n#ifndef LT_UART_DEFAULT_SERIAL\n#define LT_UART_DEFAULT_SERIAL LT_UART_DEFAULT_PORT\n#endif\n\n#ifndef LT_SERIAL_BUFFER_SIZE\n#define LT_SERIAL_BUFFER_SIZE 256\n#endif\n\n// Misc options\n#ifndef LT_USE_TIME\n#define LT_USE_TIME 0\n#endif\n\n#ifndef LT_MICROS_HIGH_RES // NOTE: this is also defined in fixups/clock_rtos.c\n#define LT_MICROS_HIGH_RES 1\n#endif\n\n#ifndef LT_AUTO_DOWNLOAD_REBOOT\n#define LT_AUTO_DOWNLOAD_REBOOT 1\n#endif\n\n// Per-module logging output - applies to all loglevels\n#ifndef LT_DEBUG_ALL\n#define LT_DEBUG_ALL 0\n#endif\n\n#ifndef LT_DEBUG_WIFI\n#define LT_DEBUG_WIFI 1\n#endif\n\n#ifndef LT_DEBUG_CLIENT\n#define LT_DEBUG_CLIENT LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_SERVER\n#define LT_DEBUG_SERVER LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_SSL\n#define LT_DEBUG_SSL LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_OTA\n#define LT_DEBUG_OTA 1\n#endif\n\n#ifndef LT_DEBUG_FDB\n#define LT_DEBUG_FDB 0\n#endif\n\n#ifndef LT_DEBUG_MDNS\n#define LT_DEBUG_MDNS LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_LWIP\n#define LT_DEBUG_LWIP 0\n#endif\n\n#ifndef LT_DEBUG_LWIP_ASSERT\n#define LT_DEBUG_LWIP_ASSERT 0\n#endif\n</code></pre>"},{"location":"ltapi/lt__logger_8c/","title":"File lt_logger.c","text":"<p>FileList &gt; base &gt; lt_logger.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_logger.h\"</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__logger_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const char levels   = = {'V', 'D', 'I', 'W', 'E', 'F'}   uint32_t uart_port   = = 0"},{"location":"ltapi/lt__logger_8c/#public-functions","title":"Public Functions","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void lt_log_set_port (uint8_t port) Change log output port."},{"location":"ltapi/lt__logger_8c/#macros","title":"Macros","text":"Type Name     define COLOR_BLACK  0x00   define COLOR_BLUE  0x04   define COLOR_BRIGHT_BLACK  0x10   define COLOR_BRIGHT_BLUE  0x14   define COLOR_BRIGHT_CYAN  0x16   define COLOR_BRIGHT_GREEN  0x12   define COLOR_BRIGHT_MAGENTA  0x15   define COLOR_BRIGHT_RED  0x11   define COLOR_BRIGHT_WHITE  0x17   define COLOR_BRIGHT_YELLOW  0x13   define COLOR_CYAN  0x06   define COLOR_FMT  \"e[0;30m\"   define COLOR_GREEN  0x02   define COLOR_MAGENTA  0x05   define COLOR_RED  0x01   define COLOR_WHITE  0x07   define COLOR_YELLOW  0x03"},{"location":"ltapi/lt__logger_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/lt__logger_8c/#variable-levels","title":"variable levels","text":"<pre><code>const char levels[];\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#variable-uart_port","title":"variable uart_port","text":"<pre><code>uint32_t uart_port;\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__logger_8c/#function-lt_log","title":"function lt_log","text":"<pre><code>void lt_log (\n    const uint8_t level,\n    const char * format,\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8c/#function-lt_log_disable","title":"function lt_log_disable","text":"<pre><code>void lt_log_disable () \n</code></pre>"},{"location":"ltapi/lt__logger_8c/#function-lt_log_set_port","title":"function lt_log_set_port","text":"<p>Change log output port. <pre><code>void lt_log_set_port (\n    uint8_t port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>port</code> UART port index - can be 0, 1 or 2 </li> </ul>"},{"location":"ltapi/lt__logger_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__logger_8c/#define-color_black","title":"define COLOR_BLACK","text":"<pre><code>#define COLOR_BLACK 0x00\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_blue","title":"define COLOR_BLUE","text":"<pre><code>#define COLOR_BLUE 0x04\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_black","title":"define COLOR_BRIGHT_BLACK","text":"<pre><code>#define COLOR_BRIGHT_BLACK 0x10\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_blue","title":"define COLOR_BRIGHT_BLUE","text":"<pre><code>#define COLOR_BRIGHT_BLUE 0x14\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_cyan","title":"define COLOR_BRIGHT_CYAN","text":"<pre><code>#define COLOR_BRIGHT_CYAN 0x16\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_green","title":"define COLOR_BRIGHT_GREEN","text":"<pre><code>#define COLOR_BRIGHT_GREEN 0x12\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_magenta","title":"define COLOR_BRIGHT_MAGENTA","text":"<pre><code>#define COLOR_BRIGHT_MAGENTA 0x15\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_red","title":"define COLOR_BRIGHT_RED","text":"<pre><code>#define COLOR_BRIGHT_RED 0x11\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_white","title":"define COLOR_BRIGHT_WHITE","text":"<pre><code>#define COLOR_BRIGHT_WHITE 0x17\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_yellow","title":"define COLOR_BRIGHT_YELLOW","text":"<pre><code>#define COLOR_BRIGHT_YELLOW 0x13\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_cyan","title":"define COLOR_CYAN","text":"<pre><code>#define COLOR_CYAN 0x06\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_fmt","title":"define COLOR_FMT","text":"<pre><code>#define COLOR_FMT \"\\e[0;30m\"\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_green","title":"define COLOR_GREEN","text":"<pre><code>#define COLOR_GREEN 0x02\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_magenta","title":"define COLOR_MAGENTA","text":"<pre><code>#define COLOR_MAGENTA 0x05\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_red","title":"define COLOR_RED","text":"<pre><code>#define COLOR_RED 0x01\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_white","title":"define COLOR_WHITE","text":"<pre><code>#define COLOR_WHITE 0x07\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_yellow","title":"define COLOR_YELLOW","text":"<pre><code>#define COLOR_YELLOW 0x03\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_logger.c</code></p>"},{"location":"ltapi/lt__logger_8c_source/","title":"File lt_logger.c","text":"<p>File List &gt; base &gt; lt_logger.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#include \"lt_logger.h\"\n\n#if __has_include(&lt;sdk_private.h&gt;)\n#include &lt;sdk_private.h&gt;\n#endif\n\n#if LT_HAS_PRINTF\n#include &lt;printf/printf.h&gt;\n#include &lt;printf_port.h&gt;\n#else\n#include &lt;stdio.h&gt;\n#endif\n\n#if (LT_LOGGER_TIMESTAMP || LT_LOGGER_TASK) &amp;&amp; LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n#endif\n\n#define COLOR_FMT            \"\\e[0;30m\"\n#define COLOR_BLACK          0x00\n#define COLOR_RED            0x01\n#define COLOR_GREEN          0x02\n#define COLOR_YELLOW         0x03\n#define COLOR_BLUE           0x04\n#define COLOR_MAGENTA        0x05\n#define COLOR_CYAN           0x06\n#define COLOR_WHITE          0x07\n#define COLOR_BRIGHT_BLACK   0x10\n#define COLOR_BRIGHT_RED     0x11\n#define COLOR_BRIGHT_GREEN   0x12\n#define COLOR_BRIGHT_YELLOW  0x13\n#define COLOR_BRIGHT_BLUE    0x14\n#define COLOR_BRIGHT_MAGENTA 0x15\n#define COLOR_BRIGHT_CYAN    0x16\n#define COLOR_BRIGHT_WHITE   0x17\n\n#ifdef LT_UART_DEFAULT_PORT\nstatic uint32_t uart_port = LT_UART_DEFAULT_LOGGER;\n#else\nstatic uint32_t uart_port = 0;\n#endif\nstatic const char levels[] = {'V', 'D', 'I', 'W', 'E', 'F'};\n\n#if LT_LOGGER_COLOR\nstatic const uint8_t colors[] = {\n    COLOR_BRIGHT_CYAN,\n    COLOR_BRIGHT_BLUE,\n    COLOR_BRIGHT_GREEN,\n    COLOR_BRIGHT_YELLOW,\n    COLOR_BRIGHT_RED,\n    COLOR_BRIGHT_MAGENTA,\n};\n#endif\n\n#if LIBRETINY_ARDUINO\nunsigned long millis(void);\n#endif\n\n#if LT_LOGGER_CALLER\nvoid lt_log(const uint8_t level, const char *caller, const unsigned short line, const char *format, ...) {\n#else\nvoid lt_log(const uint8_t level, const char *format, ...) {\n#endif\n\n    if (uart_port == 0xFF)\n        return;\n\n#if LT_LOGGER_TIMESTAMP\n#if LIBRETINY_ARDUINO\n    float seconds = millis() / 1000.0f;\n#elif LT_HAS_FREERTOS\n    float seconds = xTaskGetTickCount() * portTICK_PERIOD_MS / 1000.0f;\n#else\n    float seconds = 0;\n#endif\n#if LT_PRINTF_BROKEN\n    char zero[4] = \"\\x00\\x30\\x30\";\n    if (seconds == 0.0f)\n        zero[0] = '0';\n#endif\n#endif\n\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n    char task_colon   = ':';\n    TaskHandle_t task = xTaskGetCurrentTaskHandle();\n    char *task_name   = pcTaskGetTaskName(task);\n    if (!task) {\n        task_name  = \"\";\n        task_colon = '-';\n    }\n#endif\n\n#if LT_LOGGER_COLOR\n    char c_bright = '0' + (colors[level] &gt;&gt; 4);\n    char c_value  = '0' + (colors[level] &amp; 0x7);\n#endif\n\n#if LT_HAS_PRINTF\n    fctprintf(\n        (void (*)(char, void *))putchar_p,\n        (void *)uart_port,\n#else\n    printf(\n#endif\n    // format:\n#if LT_LOGGER_COLOR\n        \"\\e[%c;3%cm\"\n#endif\n        \"%c \"\n#if LT_LOGGER_TIMESTAMP\n#if LT_PRINTF_BROKEN\n        \"[%11.3f%s] \"\n#else\n        \"[%11.3f] \"\n#endif\n#endif\n#if LT_LOGGER_COLOR\n        \"\\e[0m\"\n#endif\n#if LT_LOGGER_CALLER\n        \"%s():%hu: \"\n#endif\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n        \"%s%c \"\n#endif\n        ,\n    // arguments:\n#if LT_LOGGER_COLOR\n        c_bright, // whether text is bright\n        c_value,  // text color\n#endif\n        levels[level]\n#if LT_LOGGER_TIMESTAMP\n        ,\n        seconds // float\n#if LT_PRINTF_BROKEN\n        ,\n        zero // append missing zeroes if printf \"%11.3f\" prints \"0.\"\n#endif\n#endif\n#if LT_LOGGER_CALLER\n        ,\n        caller,\n        line\n#endif\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n        ,\n        task_name,\n        task_colon // printing outside of tasks\n#endif\n    );\n\n#if LT_HAS_PRINTF\n    va_list va_args;\n    va_start(va_args, format);\n    vfctprintf((void (*)(char, void *))putchar_p, (void *)uart_port, format, va_args);\n    va_end(va_args);\n    putchar_p('\\r', uart_port);\n    putchar_p('\\n', uart_port);\n#else\n    va_list va_args;\n    va_start(va_args, format);\n    vprintf(format, va_args);\n    va_end(va_args);\n    putchar('\\r');\n    putchar('\\n');\n#endif\n}\n\nvoid lt_log_set_port(uint8_t port) {\n    uart_port = port;\n}\n\nvoid lt_log_disable() {\n    uart_port = 0xFF;\n}\n</code></pre>"},{"location":"ltapi/lt__logger_8h/","title":"File lt_logger.h","text":"<p>FileList &gt; base &gt; lt_logger.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__logger_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void void lt_log_set_port (uint8_t port) Change log output port."},{"location":"ltapi/lt__logger_8h/#macros","title":"Macros","text":"Type Name     define ESP_EARLY_LOGD (tag, ...) LT_D(__VA_ARGS__)   define ESP_EARLY_LOGE (tag, ...) LT_E(__VA_ARGS__)   define ESP_EARLY_LOGI (tag, ...) LT_I(__VA_ARGS__)   define ESP_EARLY_LOGV (tag, ...) LT_V(__VA_ARGS__)   define ESP_EARLY_LOGW (tag, ...) LT_W(__VA_ARGS__)   define ESP_LOGD (tag, ...) LT_D(__VA_ARGS__)   define ESP_LOGE (tag, ...) LT_E(__VA_ARGS__)   define ESP_LOGI (tag, ...) LT_I(__VA_ARGS__)   define ESP_LOGV (tag, ...) LT_V(__VA_ARGS__)   define ESP_LOGW (tag, ...) LT_W(__VA_ARGS__)   define ETS_PRINTF (...) LT_I(__VA_ARGS__)   define LT_D (...) LT_LOG(LT_LEVEL_DEBUG, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_DM (module, ...) LT_LOGM(LT_LEVEL_DEBUG, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_E (...) LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_EM (module, ...) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_ERRNO ()    define LT_ERRNO_LEZ (ret)    define LT_ERRNO_LZ (ret)    define LT_ERRNO_NZ (ret)    define LT_F (...) LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_FM (module, ...) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_HEAP_I ()    define LT_I (...) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_IM (module, ...) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_LOG (level, caller, line, ...) lt_log(level, __VA_ARGS__)   define LT_LOGM (level, module, caller, line, ...)    define LT_RET (ret)    define LT_RET_LEZ (ret)    define LT_RET_LZ (ret)    define LT_RET_NZ (ret)    define LT_T (...) LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_TM (module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_V (...) LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_VM (module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_W (...) LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_WM (module, ...) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define ets_printf (...) LT_I(__VA_ARGS__)   define isr_log_d (...) LT_D(__VA_ARGS__)   define isr_log_e (...) LT_E(__VA_ARGS__)   define isr_log_i (...) LT_I(__VA_ARGS__)   define isr_log_n (...) LT_E(__VA_ARGS__)   define isr_log_v (...) LT_V(__VA_ARGS__)   define isr_log_w (...) LT_W(__VA_ARGS__)   define log_d (...) LT_D(__VA_ARGS__)   define log_e (...) LT_E(__VA_ARGS__)   define log_i (...) LT_I(__VA_ARGS__)   define log_n (...) LT_E(__VA_ARGS__)   define log_printf (...) LT_I(__VA_ARGS__)   define log_v (...) LT_V(__VA_ARGS__)   define log_w (...) LT_W(__VA_ARGS__)"},{"location":"ltapi/lt__logger_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__logger_8h/#function-lt_log","title":"function lt_log","text":"<pre><code>void lt_log (\n    const uint8_t level,\n    const char * format,\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#function-lt_log_disable","title":"function lt_log_disable","text":"<pre><code>void lt_log_disable () \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#function-lt_log_set_port","title":"function lt_log_set_port","text":"<p>Change log output port. <pre><code>void void lt_log_set_port (\n    uint8_t port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>port</code> UART port index - can be 0, 1 or 2 </li> </ul>"},{"location":"ltapi/lt__logger_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__logger_8h/#define-esp_early_logd","title":"define ESP_EARLY_LOGD","text":"<pre><code>#define ESP_EARLY_LOGD (\n    tag,\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_loge","title":"define ESP_EARLY_LOGE","text":"<pre><code>#define ESP_EARLY_LOGE (\n    tag,\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logi","title":"define ESP_EARLY_LOGI","text":"<pre><code>#define ESP_EARLY_LOGI (\n    tag,\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logv","title":"define ESP_EARLY_LOGV","text":"<pre><code>#define ESP_EARLY_LOGV (\n    tag,\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logw","title":"define ESP_EARLY_LOGW","text":"<pre><code>#define ESP_EARLY_LOGW (\n    tag,\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logd","title":"define ESP_LOGD","text":"<pre><code>#define ESP_LOGD (\n    tag,\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_loge","title":"define ESP_LOGE","text":"<pre><code>#define ESP_LOGE (\n    tag,\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logi","title":"define ESP_LOGI","text":"<pre><code>#define ESP_LOGI (\n    tag,\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logv","title":"define ESP_LOGV","text":"<pre><code>#define ESP_LOGV (\n    tag,\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logw","title":"define ESP_LOGW","text":"<pre><code>#define ESP_LOGW (\n    tag,\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-ets_printf","title":"define ETS_PRINTF","text":"<pre><code>#define ETS_PRINTF (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_d","title":"define LT_D","text":"<pre><code>#define LT_D (\n    ...\n) LT_LOG(LT_LEVEL_DEBUG, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_dm","title":"define LT_DM","text":"<pre><code>#define LT_DM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_DEBUG, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_e","title":"define LT_E","text":"<pre><code>#define LT_E (\n    ...\n) LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_em","title":"define LT_EM","text":"<pre><code>#define LT_EM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno","title":"define LT_ERRNO","text":"<pre><code>#define LT_ERRNO (\n\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_lez","title":"define LT_ERRNO_LEZ","text":"<pre><code>#define LT_ERRNO_LEZ (\n    ret\n) if (ret &lt;= 0) {                           \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_lz","title":"define LT_ERRNO_LZ","text":"<pre><code>#define LT_ERRNO_LZ (\n    ret\n) if (ret &lt; 0) {                            \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_nz","title":"define LT_ERRNO_NZ","text":"<pre><code>#define LT_ERRNO_NZ (\n    ret\n) if (ret) {                                \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_f","title":"define LT_F","text":"<pre><code>#define LT_F (\n    ...\n) LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_fm","title":"define LT_FM","text":"<pre><code>#define LT_FM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_heap_i","title":"define LT_HEAP_I","text":"<pre><code>#define LT_HEAP_I (\n\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_i","title":"define LT_I","text":"<pre><code>#define LT_I (\n    ...\n) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_im","title":"define LT_IM","text":"<pre><code>#define LT_IM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_log","title":"define LT_LOG","text":"<pre><code>#define LT_LOG (\n    level,\n    caller,\n    line,\n    ...\n) lt_log(level, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_logm","title":"define LT_LOGM","text":"<pre><code>#define LT_LOGM (\n    level,\n    module,\n    caller,\n    line,\n    ...\n) do {                                             \\\n        if (LT_DEBUG_##module) {                     \\\n            lt_log(level, #module \": \" __VA_ARGS__); \\\n        }                                            \\\n    } while (0)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret","title":"define LT_RET","text":"<pre><code>#define LT_RET (\n    ret\n) LT_E(\"ret=%d\", ret); \\\n    return ret;\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_lez","title":"define LT_RET_LEZ","text":"<pre><code>#define LT_RET_LEZ (\n    ret\n) if (ret &lt;= 0) {          \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_lz","title":"define LT_RET_LZ","text":"<pre><code>#define LT_RET_LZ (\n    ret\n) if (ret &lt; 0) {           \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_nz","title":"define LT_RET_NZ","text":"<pre><code>#define LT_RET_NZ (\n    ret\n) if (ret) {               \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_t","title":"define LT_T","text":"<pre><code>#define LT_T (\n    ...\n) LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_tm","title":"define LT_TM","text":"<pre><code>#define LT_TM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_v","title":"define LT_V","text":"<pre><code>#define LT_V (\n    ...\n) LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_vm","title":"define LT_VM","text":"<pre><code>#define LT_VM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_w","title":"define LT_W","text":"<pre><code>#define LT_W (\n    ...\n) LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_wm","title":"define LT_WM","text":"<pre><code>#define LT_WM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-ets_printf_1","title":"define ets_printf","text":"<pre><code>#define ets_printf (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_d","title":"define isr_log_d","text":"<pre><code>#define isr_log_d (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_e","title":"define isr_log_e","text":"<pre><code>#define isr_log_e (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_i","title":"define isr_log_i","text":"<pre><code>#define isr_log_i (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_n","title":"define isr_log_n","text":"<pre><code>#define isr_log_n (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_v","title":"define isr_log_v","text":"<pre><code>#define isr_log_v (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_w","title":"define isr_log_w","text":"<pre><code>#define isr_log_w (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_d","title":"define log_d","text":"<pre><code>#define log_d (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_e","title":"define log_e","text":"<pre><code>#define log_e (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_i","title":"define log_i","text":"<pre><code>#define log_i (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_n","title":"define log_n","text":"<pre><code>#define log_n (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_printf","title":"define log_printf","text":"<pre><code>#define log_printf (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_v","title":"define log_v","text":"<pre><code>#define log_v (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_w","title":"define log_w","text":"<pre><code>#define log_w (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_logger.h</code></p>"},{"location":"ltapi/lt__logger_8h_source/","title":"File lt_logger.h","text":"<p>File List &gt; base &gt; lt_logger.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n#include &lt;libretiny.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#if LT_LOGGER_CALLER\n#define LT_LOG(level, caller, line, ...) lt_log(level, caller, line, __VA_ARGS__)\n#define LT_LOGM(level, module, caller, line, ...)                  \\\n    do {                                                           \\\n        if (LT_DEBUG_##module) {                                   \\\n            lt_log(level, caller, line, #module \": \" __VA_ARGS__); \\\n        }                                                          \\\n    } while (0)\nvoid lt_log(const uint8_t level, const char *caller, const unsigned short line, const char *format, ...)\n    __attribute__((format(printf, 4, 5)));\n#else\n#define LT_LOG(level, caller, line, ...) lt_log(level, __VA_ARGS__)\n#define LT_LOGM(level, module, caller, line, ...)    \\\n    do {                                             \\\n        if (LT_DEBUG_##module) {                     \\\n            lt_log(level, #module \": \" __VA_ARGS__); \\\n        }                                            \\\n    } while (0)\nvoid lt_log(const uint8_t level, const char *format, ...) __attribute__((format(printf, 2, 3)));\n#endif\n\nvoid lt_log_set_port(uint8_t port);\n\nvoid lt_log_disable();\n\n#if LT_LEVEL_TRACE &gt;= LT_LOGLEVEL\n#define LT_T(...)          LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_V(...)          LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_TM(module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_VM(module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_T(...)\n#define LT_V(...)\n#define LT_TM(...)\n#define LT_VM(...)\n#endif\n\n#if LT_LEVEL_DEBUG &gt;= LT_LOGLEVEL\n#define LT_D(...)          LT_LOG(LT_LEVEL_DEBUG, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_DM(module, ...) LT_LOGM(LT_LEVEL_DEBUG, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_D(...)\n#define LT_DM(...)\n#endif\n\n#if LT_LEVEL_INFO &gt;= LT_LOGLEVEL\n#define LT_I(...)          LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_IM(module, ...) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_I(...)\n#define LT_IM(...)\n#endif\n\n#if LT_LEVEL_WARN &gt;= LT_LOGLEVEL\n#define LT_W(...)          LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_WM(module, ...) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_W(...)\n#define LT_WM(...)\n#endif\n\n#if LT_LEVEL_ERROR &gt;= LT_LOGLEVEL\n#define LT_E(...)          LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_EM(module, ...) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_E(...)\n#define LT_EM(...)\n#endif\n\n#if LT_LEVEL_FATAL &gt;= LT_LOGLEVEL\n#define LT_F(...)          LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_FM(module, ...) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_F(...)\n#define LT_FM(...)\n#endif\n\n#if LT_LOG_HEAP &amp;&amp; LT_HAS_FREERTOS\n#define LT_HEAP_I() LT_I(\"Free heap: %u\", LT_HEAP_FUNC());\n#else\n#define LT_HEAP_I()\n#endif\n\n// ESP32 compat\n#define log_printf(...)          LT_I(__VA_ARGS__)\n#define log_v(...)               LT_V(__VA_ARGS__)\n#define log_d(...)               LT_D(__VA_ARGS__)\n#define log_i(...)               LT_I(__VA_ARGS__)\n#define log_w(...)               LT_W(__VA_ARGS__)\n#define log_e(...)               LT_E(__VA_ARGS__)\n#define log_n(...)               LT_E(__VA_ARGS__)\n#define isr_log_v(...)           LT_V(__VA_ARGS__)\n#define isr_log_d(...)           LT_D(__VA_ARGS__)\n#define isr_log_i(...)           LT_I(__VA_ARGS__)\n#define isr_log_w(...)           LT_W(__VA_ARGS__)\n#define isr_log_e(...)           LT_E(__VA_ARGS__)\n#define isr_log_n(...)           LT_E(__VA_ARGS__)\n#define ESP_LOGV(tag, ...)       LT_V(__VA_ARGS__)\n#define ESP_LOGD(tag, ...)       LT_D(__VA_ARGS__)\n#define ESP_LOGI(tag, ...)       LT_I(__VA_ARGS__)\n#define ESP_LOGW(tag, ...)       LT_W(__VA_ARGS__)\n#define ESP_LOGE(tag, ...)       LT_E(__VA_ARGS__)\n#define ESP_EARLY_LOGV(tag, ...) LT_V(__VA_ARGS__)\n#define ESP_EARLY_LOGD(tag, ...) LT_D(__VA_ARGS__)\n#define ESP_EARLY_LOGI(tag, ...) LT_I(__VA_ARGS__)\n#define ESP_EARLY_LOGW(tag, ...) LT_W(__VA_ARGS__)\n#define ESP_EARLY_LOGE(tag, ...) LT_E(__VA_ARGS__)\n#define ets_printf(...)          LT_I(__VA_ARGS__)\n#define ETS_PRINTF(...)          LT_I(__VA_ARGS__)\n\n#define LT_RET(ret)      \\\n    LT_E(\"ret=%d\", ret); \\\n    return ret;\n\n#define LT_RET_NZ(ret)       \\\n    if (ret) {               \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n#define LT_RET_LZ(ret)       \\\n    if (ret &lt; 0) {           \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n#define LT_RET_LEZ(ret)      \\\n    if (ret &lt;= 0) {          \\\n        LT_E(\"ret=%d\", ret); \\\n        return ret;          \\\n    }\n\n#define LT_ERRNO_NZ(ret)                      \\\n    if (ret) {                                \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n#define LT_ERRNO_LZ(ret)                      \\\n    if (ret &lt; 0) {                            \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n#define LT_ERRNO_LEZ(ret)                     \\\n    if (ret &lt;= 0) {                           \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret); \\\n        return ret;                           \\\n    }\n\n#if LT_LOG_ERRNO\n#define LT_ERRNO()               \\\n    if (errno) {                 \\\n        LT_E(\"errno=%d\", errno); \\\n        errno = 0;               \\\n    }\n#else\n#define LT_ERRNO()\n#endif\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/lt__main_8c/","title":"File lt_main.c","text":"<p>FileList &gt; base &gt; lt_main.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;libretiny.h&gt;</code></li> <li><code>#include &lt;fal.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__main_8c/#public-attributes","title":"Public Attributes","text":"Type Name     fal_partition_t fal_root_part   = = NULL\"Root\" partition entry, representing the entire flash. Declared and initialized in lt_main.c."},{"location":"ltapi/lt__main_8c/#public-functions","title":"Public Functions","text":"Type Name     void __libc_init_array (void)    int lt_main (void)    int main (void)"},{"location":"ltapi/lt__main_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/lt__main_8c/#variable-fal_root_part","title":"variable fal_root_part","text":"<pre><code>fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/lt__main_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__main_8c/#function-__libc_init_array","title":"function __libc_init_array","text":"<pre><code>void __libc_init_array (\n    void\n) \n</code></pre>"},{"location":"ltapi/lt__main_8c/#function-lt_main","title":"function lt_main","text":"<pre><code>int lt_main (\n    void\n) \n</code></pre>"},{"location":"ltapi/lt__main_8c/#function-main","title":"function main","text":"<pre><code>int main (\n    void\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_main.c</code></p>"},{"location":"ltapi/lt__main_8c_source/","title":"File lt_main.c","text":"<p>File List &gt; base &gt; lt_main.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#include &lt;libretiny.h&gt;\n\n#include &lt;fal.h&gt;\n\nfal_partition_t fal_root_part = NULL;\n\n// Initialize C library\nvoid __libc_init_array(void);\n// Main app entrypoint\nint main(void);\n\nint lt_main(void) {\n    // early initialize the family and variant\n    lt_init_family();\n    lt_init_variant();\n    // print a startup banner\n    LT_BANNER();\n    // initialize C library\n    __libc_init_array();\n    // inform about the reset reason\n    LT_I(\"Reset reason: %s\", lt_get_reboot_reason_name(0));\n    // initialize FAL\n    fal_init();\n    // provide root partition\n    fal_root_part = (fal_partition_t)fal_partition_find(\"root\");\n\n    // run the application\n    return main();\n}\n</code></pre>"},{"location":"ltapi/lt__pins_8h/","title":"File lt_pins.h","text":"<p>FileList &gt; base &gt; lt_pins.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/lt__pins_8h/#macros","title":"Macros","text":"Type Name     define LT_HW_I2C0  HAS_WIRE0   define LT_HW_I2C1  HAS_WIRE1   define LT_HW_I2C2  HAS_WIRE2   define LT_HW_SPI0  HAS_SPI0   define LT_HW_SPI1  HAS_SPI1   define LT_HW_SPI2  HAS_SPI2   define LT_HW_UART0  HAS_SERIAL0   define LT_HW_UART1  HAS_SERIAL1   define LT_HW_UART2  HAS_SERIAL2   define PIN_INVALID  255"},{"location":"ltapi/lt__pins_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__pins_8h/#define-lt_hw_i2c0","title":"define LT_HW_I2C0","text":"<pre><code>#define LT_HW_I2C0 HAS_WIRE0\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_i2c1","title":"define LT_HW_I2C1","text":"<pre><code>#define LT_HW_I2C1 HAS_WIRE1\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_i2c2","title":"define LT_HW_I2C2","text":"<pre><code>#define LT_HW_I2C2 HAS_WIRE2\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_spi0","title":"define LT_HW_SPI0","text":"<pre><code>#define LT_HW_SPI0 HAS_SPI0\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_spi1","title":"define LT_HW_SPI1","text":"<pre><code>#define LT_HW_SPI1 HAS_SPI1\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_spi2","title":"define LT_HW_SPI2","text":"<pre><code>#define LT_HW_SPI2 HAS_SPI2\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_uart0","title":"define LT_HW_UART0","text":"<pre><code>#define LT_HW_UART0 HAS_SERIAL0\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_uart1","title":"define LT_HW_UART1","text":"<pre><code>#define LT_HW_UART1 HAS_SERIAL1\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-lt_hw_uart2","title":"define LT_HW_UART2","text":"<pre><code>#define LT_HW_UART2 HAS_SERIAL2\n</code></pre>"},{"location":"ltapi/lt__pins_8h/#define-pin_invalid","title":"define PIN_INVALID","text":"<pre><code>#define PIN_INVALID 255\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_pins.h</code></p>"},{"location":"ltapi/lt__pins_8h_source/","title":"File lt_pins.h","text":"<p>File List &gt; base &gt; lt_pins.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2023-06-21. */\n\n#include LT_VARIANT_H\n\n#define PIN_INVALID 255\n\n#define LT_HW_UART0 HAS_SERIAL0\n#define LT_HW_UART1 HAS_SERIAL1\n#define LT_HW_UART2 HAS_SERIAL2\n#define LT_HW_I2C0  HAS_WIRE0\n#define LT_HW_I2C1  HAS_WIRE1\n#define LT_HW_I2C2  HAS_WIRE2\n#define LT_HW_SPI0  HAS_SPI0\n#define LT_HW_SPI1  HAS_SPI1\n#define LT_HW_SPI2  HAS_SPI2\n\n#if LT_HW_UART0\n#ifndef PIN_SERIAL0_RX\n#define PIN_SERIAL0_RX PIN_INVALID\n#endif\n#ifndef PIN_SERIAL0_TX\n#define PIN_SERIAL0_TX PIN_INVALID\n#endif\n#endif\n\n#if LT_HW_UART1\n#ifndef PIN_SERIAL1_RX\n#define PIN_SERIAL1_RX PIN_INVALID\n#endif\n#ifndef PIN_SERIAL1_TX\n#define PIN_SERIAL1_TX PIN_INVALID\n#endif\n#endif\n\n#if LT_HW_UART2\n#ifndef PIN_SERIAL2_RX\n#define PIN_SERIAL2_RX PIN_INVALID\n#endif\n#ifndef PIN_SERIAL2_TX\n#define PIN_SERIAL2_TX PIN_INVALID\n#endif\n#endif\n\n#if LT_HW_I2C0\n#ifndef PIN_WIRE0_SDA\n#define PIN_WIRE0_SDA PIN_INVALID\n#endif\n#ifndef PIN_WIRE0_SCL\n#define PIN_WIRE0_SCL PIN_INVALID\n#endif\n#endif\n\n#if LT_HW_I2C1\n#ifndef PIN_WIRE1_SDA\n#define PIN_WIRE1_SDA PIN_INVALID\n#endif\n#ifndef PIN_WIRE1_SCL\n#define PIN_WIRE1_SCL PIN_INVALID\n#endif\n#endif\n\n#if LT_HW_I2C2\n#ifndef PIN_WIRE2_SDA\n#define PIN_WIRE2_SDA PIN_INVALID\n#endif\n#ifndef PIN_WIRE2_SCL\n#define PIN_WIRE2_SCL PIN_INVALID\n#endif\n#endif\n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/","title":"File lt_posix_api.h","text":"<p>FileList &gt; base &gt; lt_posix_api.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;sys/time.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__posix__api_8h/#public-functions","title":"Public Functions","text":"Type Name     int strcasecmp (const char * s1, const char * s2)    char * strdup (const char *)    int strncasecmp (const char * s1, const char * s2, size_t n)    char * strptime (const char * buf, const char * fmt, struct tm * tm)"},{"location":"ltapi/lt__posix__api_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__posix__api_8h/#function-strcasecmp","title":"function strcasecmp","text":"<pre><code>int strcasecmp (\n    const char * s1,\n    const char * s2\n) \n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/#function-strdup","title":"function strdup","text":"<pre><code>char * strdup (\n    const char *\n) \n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/#function-strncasecmp","title":"function strncasecmp","text":"<pre><code>int strncasecmp (\n    const char * s1,\n    const char * s2,\n    size_t n\n) \n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/#function-strptime","title":"function strptime","text":"<pre><code>char * strptime (\n    const char * buf,\n    const char * fmt,\n    struct tm * tm\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_posix_api.h</code></p>"},{"location":"ltapi/lt__posix__api_8h_source/","title":"File lt_posix_api.h","text":"<p>File List &gt; base &gt; lt_posix_api.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-16. */\n\n#include &lt;sys/time.h&gt;\n#include &lt;time.h&gt;\n\nextern char *strdup(const char *);\nextern int strcasecmp(const char *s1, const char *s2);\nextern int strncasecmp(const char *s1, const char *s2, size_t n);\nextern char *strptime(const char *buf, const char *fmt, struct tm *tm);\n</code></pre>"},{"location":"ltapi/lt__types_8h/","title":"File lt_types.h","text":"<p>FileList &gt; base &gt; lt_types.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__types_8h/#public-types","title":"Public Types","text":"Type Name     enum lt_cpu_family_t    enum lt_cpu_model_t"},{"location":"ltapi/lt__types_8h/#macros","title":"Macros","text":"Type Name     define CPU_MODEL (family, chip_id) (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)   define CPU_MODEL_ENUM (family, chip_id) (lt_cpu_model_t) CPU_MODEL(family, chip_id)"},{"location":"ltapi/lt__types_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/lt__types_8h/#enum-lt_cpu_family_t","title":"enum lt_cpu_family_t","text":"<pre><code>enum lt_cpu_family_t {\n    F_RTL8710A = 0x9FFFD543,\n    F_RTL8710B = 0x22E0D6FC,\n    F_RTL8720C = 0xE08F7564,\n    F_RTL8720D = 0x3379CFE2,\n    F_BK7231Q = 0xAFE81D49,\n    F_BK7231T = 0x675A40B0,\n    F_BK7231N = 0x7B3EF230,\n    F_BK7251 = 0x6A82CC42,\n    F_BL60X = 0xDE1270B7,\n    F_LN882H = 0xA38090A8\n};\n</code></pre>"},{"location":"ltapi/lt__types_8h/#enum-lt_cpu_model_t","title":"enum lt_cpu_model_t","text":"<pre><code>enum lt_cpu_model_t {\n    RTL8710BL = CPU_MODEL(F_RTL8710B, 0xE0),\n    RTL8710BN = CPU_MODEL(F_RTL8710B, 0xFF),\n    RTL8710BU = CPU_MODEL(F_RTL8710B, 0xFE),\n    RTL8710BX = CPU_MODEL(F_RTL8710B, 0xF6),\n    RTL8710L0 = CPU_MODEL(F_RTL8710B, 0xFB),\n    RTL8711BN = CPU_MODEL(F_RTL8710B, 0xFD),\n    RTL8711BU = CPU_MODEL(F_RTL8710B, 0xFC),\n    MX1290 = RTL8710BN,\n    MX1290V2 = RTL8710BX,\n    W302 = RTL8710BN,\n    RTL8720CM = CPU_MODEL(F_RTL8720C, 0xEC),\n    RTL8720CF = CPU_MODEL(F_RTL8720C, 0xED),\n    RTL8720CX = RTL8720CM,\n    BK7231Q = CPU_MODEL(F_BK7231Q, 0x31),\n    BK7231T = CPU_MODEL(F_BK7231T, 0x1A),\n    BK7231N = CPU_MODEL(F_BK7231N, 0x1C),\n    BK7252 = CPU_MODEL(F_BK7251, 0x00),\n    BL2028N = BK7231N,\n    BK7231S = BK7231T,\n    BK7231U = BK7231T,\n    LN882HF = CPU_MODEL(F_LN882H, 0x00),\n    LN882HK = CPU_MODEL(F_LN882H, 0x00),\n    LN882HC = CPU_MODEL(F_LN882H, 0x00)\n};\n</code></pre>"},{"location":"ltapi/lt__types_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__types_8h/#define-cpu_model","title":"define CPU_MODEL","text":"<pre><code>#define CPU_MODEL (\n    family,\n    chip_id\n) (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)\n</code></pre>"},{"location":"ltapi/lt__types_8h/#define-cpu_model_enum","title":"define CPU_MODEL_ENUM","text":"<pre><code>#define CPU_MODEL_ENUM (\n    family,\n    chip_id\n) (lt_cpu_model_t) CPU_MODEL(family, chip_id)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>cores/common/base/lt_types.h</code></p>"},{"location":"ltapi/lt__types_8h_source/","title":"File lt_types.h","text":"<p>File List &gt; base &gt; lt_types.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-28. */\n\n#pragma once\n\n#include &lt;stdint.h&gt;\n\n#define CPU_MODEL(family, chip_id)      (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)\n#define CPU_MODEL_ENUM(family, chip_id) (lt_cpu_model_t) CPU_MODEL(family, chip_id)\n\ntypedef enum {\n    F_RTL8710A = 0x9FFFD543, // Realtek Ameba1\n    F_RTL8710B = 0x22E0D6FC, // Realtek AmebaZ (realtek-ambz)\n    F_RTL8720C = 0xE08F7564, // Realtek AmebaZ2\n    F_RTL8720D = 0x3379CFE2, // Realtek AmebaD\n    F_BK7231Q  = 0xAFE81D49, // Beken 7231Q\n    F_BK7231T  = 0x675A40B0, // Beken 7231T\n    F_BK7231N  = 0x7B3EF230, // Beken 7231N\n    F_BK7251   = 0x6A82CC42, // Beken 7251/7252\n    F_BL60X    = 0xDE1270B7, // Boufallo 602\n    F_LN882H   = 0xA38090A8, // Lightning LN882H\n} lt_cpu_family_t;\n\ntypedef enum {\n    // Realtek AmebaZ\n    // IDs copied from rtl8710b_efuse.h\n    RTL8710BL = CPU_MODEL(F_RTL8710B, 0xE0), // ???\n    RTL8710BN = CPU_MODEL(F_RTL8710B, 0xFF), // CHIPID_8710BN / QFN32\n    RTL8710BU = CPU_MODEL(F_RTL8710B, 0xFE), // CHIPID_8710BU / QFN48\n    RTL8710BX = CPU_MODEL(F_RTL8710B, 0xF6), // found on an actual RTL8710BX\n    RTL8710L0 = CPU_MODEL(F_RTL8710B, 0xFB), // CHIPID_8710BN_L0 / QFN32\n    RTL8711BN = CPU_MODEL(F_RTL8710B, 0xFD), // CHIPID_8711BN / QFN48\n    RTL8711BU = CPU_MODEL(F_RTL8710B, 0xFC), // CHIPID_8711BG / QFN68\n    MX1290    = RTL8710BN,\n    MX1290V2  = RTL8710BX,\n    W302      = RTL8710BN,\n    // Realtek AmebaZ2 (chip_id &lt;&lt; 2 | flash_mode)\n    RTL8720CM = CPU_MODEL(F_RTL8720C, 0xEC), // 0xFB &lt;&lt; 2 | 0\n    RTL8720CF = CPU_MODEL(F_RTL8720C, 0xED), // 0xFB &lt;&lt; 2 | 1\n    RTL8720CX = RTL8720CM,\n    // Beken 72XX\n    BK7231Q = CPU_MODEL(F_BK7231Q, 0x31), // *SCTRL_CHIP_ID = 0x7231\n    BK7231T = CPU_MODEL(F_BK7231T, 0x1A), // *SCTRL_CHIP_ID = 0x7231a\n    BK7231N = CPU_MODEL(F_BK7231N, 0x1C), // *SCTRL_CHIP_ID = 0x7231c\n    BK7252  = CPU_MODEL(F_BK7251, 0x00),  // TODO\n    BL2028N = BK7231N,\n    BK7231S = BK7231T,\n    BK7231U = BK7231T,\n    // Lightning LN882x\n    LN882HF = CPU_MODEL(F_LN882H, 0x00), // TODO / QFN24\n    LN882HK = CPU_MODEL(F_LN882H, 0x00), // TODO / QFN32\n    LN882HC = CPU_MODEL(F_LN882H, 0x00), // TODO / QFN40\n} lt_cpu_model_t;\n</code></pre>"},{"location":"ltapi/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace arduino </li> <li>namespace fs </li> <li>namespace mime </li> </ul>"},{"location":"ltapi/classes/","title":"Class Index","text":""},{"location":"ltapi/classes/#a","title":"a","text":"<ul> <li>arduino_event_t</li> </ul>"},{"location":"ltapi/classes/#b","title":"b","text":"<ul> <li>base64</li> <li>base64_decodestate</li> <li>base64_encodestate</li> </ul>"},{"location":"ltapi/classes/#c","title":"c","text":"<ul> <li>cbuf</li> <li>Cookie</li> </ul>"},{"location":"ltapi/classes/#e","title":"e","text":"<ul> <li>EspClass</li> <li>EventHandler_s</li> <li>esp_ip4_addr</li> <li>esp_ip6_addr</li> <li>esp_netif_ip6_info_t</li> <li>esp_netif_ip_info_t</li> <li>Entry (mime)</li> </ul>"},{"location":"ltapi/classes/#f","title":"f","text":"<ul> <li>FlashClass</li> <li>FunctionRequestHandler</li> <li>FS (fs)</li> <li>FSImpl (fs)</li> <li>File (fs)</li> <li>FileImpl (fs)</li> </ul>"},{"location":"ltapi/classes/#h","title":"h","text":"<ul> <li>HTTPClient</li> <li>HardwareI2C</li> <li>HTTPUpload</li> </ul>"},{"location":"ltapi/classes/#i","title":"i","text":"<ul> <li>IPreferences</li> <li>IWiFiClient</li> <li>IWiFiClientSecure</li> <li>IWiFiServer</li> <li>IWiFiUDP</li> <li>IPv6Address (arduino)</li> <li>ip_event_ap_staipassigned_t</li> <li>ip_event_got_ip6_t</li> <li>ip_event_got_ip_t</li> </ul>"},{"location":"ltapi/classes/#l","title":"l","text":"<ul> <li>LibreTiny</li> <li>LibreTinyOTA</li> <li>LibreTinyWDT</li> <li>LwIPClient</li> <li>LwIPRxBuffer</li> <li>LwIPServer</li> <li>LwIPUDP</li> <li>lt_flash_id_t</li> <li>lt_ota_ctx_t</li> </ul>"},{"location":"ltapi/classes/#m","title":"m","text":"<ul> <li>MbedTLSClient</li> <li>mDNS</li> <li>MD5Context</li> <li>mbedtls_md5_context</li> </ul>"},{"location":"ltapi/classes/#p","title":"p","text":"<ul> <li>PinInfo</li> </ul>"},{"location":"ltapi/classes/#r","title":"r","text":"<ul> <li>RequestHandler</li> <li>RequestArgument (HTTPClient)</li> <li>RequestArgument (WebServer)</li> </ul>"},{"location":"ltapi/classes/#s","title":"s","text":"<ul> <li>SerialClass</li> <li>SoftwareSerial</li> <li>StaticRequestHandler</li> <li>StreamString</li> <li>SoftData</li> <li>SoftSerial</li> </ul>"},{"location":"ltapi/classes/#u","title":"u","text":"<ul> <li>UpdateClass</li> <li>Uri</li> <li>UriBraces</li> <li>UriGlob</li> <li>UriRegex</li> </ul>"},{"location":"ltapi/classes/#w","title":"w","text":"<ul> <li>WebServer</li> <li>WiFiClass</li> <li>WiFiMulti</li> <li>WiFiMacAddr</li> <li>WiFiNetworkInfo</li> <li>WiFiScanAP</li> <li>WiFiScanData</li> <li>WifiAPlist_t</li> <li>wifi_event_action_tx_status_t</li> <li>wifi_event_ap_probe_req_rx_t</li> <li>wifi_event_ap_staconnected_t</li> <li>wifi_event_ap_stadisconnected_t</li> <li>wifi_event_ftm_report_t</li> <li>wifi_event_roc_done_t</li> <li>wifi_event_sta_authmode_change_t</li> <li>wifi_event_sta_connected_t</li> <li>wifi_event_sta_disconnected_t</li> <li>wifi_event_sta_scan_done_t</li> <li>wifi_event_sta_wps_er_pin_t</li> <li>wifi_event_sta_wps_er_success_t</li> <li>wifi_ftm_report_entry_t</li> </ul>"},{"location":"ltapi/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class EspClass ESP Arduino Core compatibility class. </li> <li>class FlashClass </li> <li>class RequestHandler </li> <li>class FunctionRequestHandler </li> <li>class StaticRequestHandler </li> <li>class HTTPClient </li> <li>class IPreferences </li> <li>class IWiFiClientSecure </li> <li>class MbedTLSClient </li> <li>class LibreTiny Main LibreTiny API class.</li> <li>class LibreTinyOTA Over-the-Air updates helper class. </li> <li>class LibreTinyWDT Watchdog control class. </li> <li>class LwIPRxBuffer </li> <li>class UpdateClass </li> <li>class Uri </li> <li>class UriBraces </li> <li>class UriGlob </li> <li>class UriRegex </li> <li>class WebServer </li> <li>class WiFiClass </li> <li>class WiFiMulti </li> <li>class base64 </li> <li>class cbuf </li> <li>class fs::FS </li> <li>class fs::FSImpl </li> <li>class fs::FileImpl </li> <li>class mDNS </li> <li>struct Cookie </li> <li>struct EventHandler_s </li> <li>struct HTTPClient::RequestArgument </li> <li>struct HTTPUpload </li> <li>struct MD5Context </li> <li>struct PinInfo </li> <li>struct SoftData </li> <li>struct SoftSerial </li> <li>struct WebServer::RequestArgument </li> <li>struct WiFiMacAddr </li> <li>struct WiFiNetworkInfo </li> <li>struct WiFiScanAP </li> <li>struct WiFiScanData </li> <li>struct WifiAPlist_t </li> <li>struct arduino_event_t </li> <li>struct base64_decodestate </li> <li>struct base64_encodestate </li> <li>struct esp_ip4_addr </li> <li>struct esp_ip6_addr </li> <li>struct esp_netif_ip6_info_t IPV6 IP address information. </li> <li>struct esp_netif_ip_info_t </li> <li>struct ip_event_ap_staipassigned_t </li> <li>struct ip_event_got_ip6_t </li> <li>struct ip_event_got_ip_t </li> <li>struct lt_flash_id_t Flash chip ID structure. </li> <li>struct lt_ota_ctx_t OTA update process context. </li> <li>struct mbedtls_md5_context </li> <li>struct mime::Entry </li> <li>struct wifi_event_action_tx_status_t </li> <li>struct wifi_event_ap_probe_req_rx_t </li> <li>struct wifi_event_ap_staconnected_t </li> <li>struct wifi_event_ap_stadisconnected_t </li> <li>struct wifi_event_ftm_report_t </li> <li>struct wifi_event_roc_done_t </li> <li>struct wifi_event_sta_authmode_change_t </li> <li>struct wifi_event_sta_connected_t </li> <li>struct wifi_event_sta_disconnected_t </li> <li>struct wifi_event_sta_scan_done_t </li> <li>struct wifi_event_sta_wps_er_pin_t </li> <li>struct wifi_event_sta_wps_er_success_t </li> <li>struct wifi_ftm_report_entry_t </li> <li>class Stream </li> <li>class HardwareI2C </li> <li>class StreamString </li> <li>class fs::File </li> <li>class Client </li> <li>class IWiFiClient <ul> <li>class LwIPClient </li> <li>class MbedTLSClient </li> </ul> </li> <li>class IWiFiClient <ul> <li>class LwIPClient </li> <li>class MbedTLSClient </li> </ul> </li> <li>class IWiFiClient <ul> <li>class LwIPClient </li> <li>class MbedTLSClient </li> </ul> </li> <li>class Print </li> <li>class IWiFiServer </li> <li>class IWiFiServer </li> <li>class UDP </li> <li>class IWiFiUDP <ul> <li>class LwIPUDP </li> </ul> </li> <li>class IWiFiUDP <ul> <li>class LwIPUDP </li> </ul> </li> <li>class HardwareSerial </li> <li>class SerialClass </li> <li>class SoftwareSerial </li> <li>class String </li> <li>class StreamString </li> <li>class Printable </li> <li>class arduino::IPv6Address </li> </ul>"},{"location":"ltapi/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"ltapi/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"ltapi/class_members/","title":"Class Members","text":""},{"location":"ltapi/class_members/#a","title":"a","text":"<ul> <li>addHeader (HTTPClient)</li> <li>available (HardwareI2C, IWiFiServer, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File)</li> <li>accept (IWiFiServer, LwIPServer)</li> <li>abort (UpdateClass)</li> <li>addHandler (WebServer)</li> <li>arg (WebServer)</li> <li>argName (WebServer)</li> <li>args (WebServer)</li> <li>authenticate (WebServer)</li> <li>allLocalIPv6 (WiFiClass)</li> <li>addr (WiFiMacAddr, esp_ip4_addr, esp_ip6_addr)</li> <li>APlist (WiFiMulti)</li> <li>addAP (WiFiMulti)</li> <li>auth (WiFiNetworkInfo, WiFiScanAP)</li> <li>ap (WiFiScanData)</li> <li>addService (mDNS)</li> <li>addServiceImpl (mDNS)</li> <li>addServiceTxt (mDNS)</li> <li>addServiceTxtImpl (mDNS)</li> <li>aid (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> <li>authmode (wifi_event_sta_connected_t)</li> <li>ap_cred (wifi_event_sta_wps_er_success_t)</li> <li>ap_cred_cnt (wifi_event_sta_wps_er_success_t)</li> </ul>"},{"location":"ltapi/class_members/#b","title":"b","text":"<ul> <li>begin (HTTPClient, HardwareI2C, IPreferences, IWiFiServer, IWiFiUDP, LwIPServer, LwIPUDP, SerialClass, SoftwareSerial, UpdateClass, WebServer, WiFiClass, mDNS)</li> <li>beginInternal (HTTPClient)</li> <li>buf (HTTPUpload, MD5Context, SerialClass, SoftData, lt_ota_ctx_t)</li> <li>beginTransmission (HardwareI2C)</li> <li>beginMulticast (IWiFiUDP, LwIPUDP)</li> <li>beginMulticastPacket (IWiFiUDP, LwIPUDP)</li> <li>beginPacket (IWiFiUDP, LwIPUDP)</li> <li>bits (MD5Context)</li> <li>baudrate (SerialClass)</li> <li>byte (SoftData)</li> <li>BSSID (WiFiClass)</li> <li>BSSIDstr (WiFiClass)</li> <li>broadcastIP (WiFiClass)</li> <li>bssid (WiFiNetworkInfo, WiFiScanAP, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>bytes (arduino::IPv6Address)</li> <li>buf_pos (lt_ota_ctx_t)</li> <li>bytes_total (lt_ota_ctx_t)</li> <li>bytes_written (lt_ota_ctx_t)</li> <li>buffer (mbedtls_md5_context)</li> </ul>"},{"location":"ltapi/class_members/#c","title":"c","text":"<ul> <li>cb (EventHandler_s)</li> <li>canHandle (FunctionRequestHandler, RequestHandler, StaticRequestHandler, Uri, UriBraces, UriGlob, UriRegex)</li> <li>canUpload (FunctionRequestHandler, RequestHandler)</li> <li>clear (HTTPClient, IPreferences)</li> <li>clearAllCookies (HTTPClient)</li> <li>collectHeaders (HTTPClient, WebServer)</li> <li>connect (HTTPClient, IWiFiClient, IWiFiClientSecure, LwIPClient, MbedTLSClient)</li> <li>connected (HTTPClient, LwIPClient)</li> <li>currentSize (HTTPUpload)</li> <li>close (IWiFiServer, WebServer, fs::File, fs::FileImpl)</li> <li>canRollback (LibreTinyOTA)</li> <li>config (SerialClass, WiFiClass)</li> <li>configure (SerialClass)</li> <li>callback (UpdateClass, lt_ota_ctx_t)</li> <li>canRollBack (UpdateClass)</li> <li>cleanup (UpdateClass, mDNS)</li> <li>clearError (UpdateClass)</li> <li>ctx (UpdateClass)</li> <li>clone (Uri, UriBraces, UriGlob, UriRegex)</li> <li>client (WebServer)</li> <li>calculateBroadcast (WiFiClass)</li> <li>calculateNetworkID (WiFiClass)</li> <li>calculateSubnetCIDR (WiFiClass)</li> <li>channel (WiFiClass, WiFiNetworkInfo, WiFiScanAP, wifi_event_sta_connected_t)</li> <li>count (WiFiScanData)</li> <li>cbuf (cbuf)</li> <li>chip_id (lt_flash_id_t)</li> <li>chip_size_id (lt_flash_id_t)</li> <li>callback_param (lt_ota_ctx_t)</li> <li>context (wifi_event_action_tx_status_t, wifi_event_roc_done_t)</li> </ul>"},{"location":"ltapi/class_members/#d","title":"d","text":"<ul> <li>date (Cookie)</li> <li>domain (Cookie)</li> <li>duration (Cookie)</li> <li>disconnect (HTTPClient, WiFiClass)</li> <li>disable (LibreTinyWDT)</li> <li>data (PinInfo, SerialClass, SoftwareSerial, WiFiClass)</li> <li>dataFree (WiFiClass)</li> <li>dataInitialize (WiFiClass)</li> <li>dnsIP (WiFiClass)</li> <li>dns1 (WiFiNetworkInfo)</li> <li>dns2 (WiFiNetworkInfo)</li> <li>dword (arduino::IPv6Address)</li> <li>da (wifi_event_action_tx_status_t)</li> <li>dist_est (wifi_event_ftm_report_t)</li> <li>dlog_token (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#e","title":"e","text":"<ul> <li>expires (Cookie)</li> <li>EventHandler_s (EventHandler_s)</li> <li>eventId (EventHandler_s)</li> <li>eraseSector (FlashClass)</li> <li>end (HTTPClient, HardwareI2C, IPreferences, IWiFiServer, LwIPServer, SerialClass, SoftwareSerial, UpdateClass, mDNS)</li> <li>errorToString (HTTPClient)</li> <li>endTransmission (HardwareI2C)</li> <li>endPacket (IWiFiUDP, LwIPUDP)</li> <li>enable (LibreTinyWDT)</li> <li>enabled (PinInfo)</li> <li>endTx (SoftwareSerial)</li> <li>errArd (UpdateClass)</li> <li>errUf2 (UpdateClass)</li> <li>errorString (UpdateClass)</li> <li>enableCORS (WebServer)</li> <li>enableCrossOrigin (WebServer)</li> <li>enableDelay (WebServer)</li> <li>enableAP (WiFiClass)</li> <li>enableIpV6 (WiFiClass)</li> <li>enableSTA (WiFiClass)</li> <li>encryptionType (WiFiClass)</li> <li>event_id (arduino_event_t)</li> <li>event_info (arduino_event_t)</li> <li>encode (base64)</li> <li>empty (cbuf)</li> <li>exists (fs::FS, fs::FSImpl)</li> <li>esp_netif (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>error (lt_ota_ctx_t)</li> <li>endsWith (mime::Entry)</li> </ul>"},{"location":"ltapi/class_members/#f","title":"f","text":"<ul> <li>flashEraseSector (EspClass)</li> <li>flashRead (EspClass)</li> <li>flashWrite (EspClass)</li> <li>fcb (EventHandler_s)</li> <li>FunctionRequestHandler (FunctionRequestHandler)</li> <li>filename (HTTPUpload)</li> <li>flush (HardwareI2C, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>freeEntries (IPreferences)</li> <li>fd (IWiFiClient, LwIPClient)</li> <li>feed (LibreTinyWDT)</li> <li>failed (LwIPRxBuffer)</li> <li>fillBuffer (LwIPRxBuffer)</li> <li>fromString (arduino::IPv6Address)</li> <li>full (cbuf)</li> <li>FS (fs::FS)</li> <li>FSImpl (fs::FSImpl)</li> <li>File (fs::File)</li> <li>ftm_report_data (wifi_event_ftm_report_t)</li> <li>ftm_report_num_entries (wifi_event_ftm_report_t)</li> </ul>"},{"location":"ltapi/class_members/#g","title":"g","text":"<ul> <li>getBootMode (EspClass)</li> <li>getBootVersion (EspClass)</li> <li>getChipId (EspClass, FlashClass, LibreTiny)</li> <li>getCoreVersion (EspClass)</li> <li>getCpuFreqMHz (EspClass, LibreTiny)</li> <li>getCycleCount (EspClass, LibreTiny)</li> <li>getFlashChipId (EspClass, LibreTiny)</li> <li>getFlashChipMode (EspClass)</li> <li>getFlashChipRealSize (EspClass)</li> <li>getFlashChipSize (EspClass, LibreTiny)</li> <li>getFlashChipSizeByChipId (EspClass)</li> <li>getFlashChipVendorId (EspClass)</li> <li>getFreeHeap (EspClass, LibreTiny)</li> <li>getFullVersion (EspClass)</li> <li>getMaxFreeBlockSize (EspClass, LibreTiny)</li> <li>getResetInfo (EspClass)</li> <li>getResetReason (EspClass, LibreTiny)</li> <li>getSdkVersion (EspClass)</li> <li>getVcc (EspClass)</li> <li>getSize (FlashClass, HTTPClient)</li> <li>GET (HTTPClient)</li> <li>generateCookieString (HTTPClient)</li> <li>getLocation (HTTPClient)</li> <li>getStream (HTTPClient)</li> <li>getStreamPtr (HTTPClient)</li> <li>getClock (HardwareI2C)</li> <li>getBool (IPreferences)</li> <li>getBytes (IPreferences)</li> <li>getBytesLength (IPreferences)</li> <li>getChar (IPreferences)</li> <li>getDouble (IPreferences)</li> <li>getFloat (IPreferences)</li> <li>getInt (IPreferences)</li> <li>getLong (IPreferences)</li> <li>getLong64 (IPreferences)</li> <li>getShort (IPreferences)</li> <li>getString (IPreferences)</li> <li>getType (IPreferences, LibreTinyOTA)</li> <li>getUChar (IPreferences)</li> <li>getUInt (IPreferences)</li> <li>getULong (IPreferences)</li> <li>getULong64 (IPreferences)</li> <li>getUShort (IPreferences)</li> <li>getFingerprintSHA256 (IWiFiClientSecure, MbedTLSClient)</li> <li>getNoDelay (IWiFiServer, LwIPServer)</li> <li>getBoard (LibreTiny)</li> <li>getChipCoreType (LibreTiny)</li> <li>getChipCores (LibreTiny)</li> <li>getChipFamily (LibreTiny)</li> <li>getChipFamilyName (LibreTiny)</li> <li>getChipModel (LibreTiny)</li> <li>getChipType (LibreTiny)</li> <li>getCpuFreq (LibreTiny)</li> <li>getDeviceName (LibreTiny)</li> <li>getHeapSize (LibreTiny)</li> <li>getMaxAllocHeap (LibreTiny)</li> <li>getMinFreeHeap (LibreTiny)</li> <li>getRamSize (LibreTiny)</li> <li>getResetReasonName (LibreTiny)</li> <li>getVersion (LibreTiny)</li> <li>gpioRecover (LibreTiny)</li> <li>getCurrentIndex (LibreTinyOTA)</li> <li>getStoredIndex (LibreTinyOTA)</li> <li>getUF2Scheme (LibreTinyOTA)</li> <li>gpio (PinInfo)</li> <li>getContentType (StaticRequestHandler)</li> <li>getBoardName (UpdateClass)</li> <li>getError (UpdateClass)</li> <li>getErrorCode (UpdateClass)</li> <li>getFirmwareName (UpdateClass)</li> <li>getFirmwareVersion (UpdateClass)</li> <li>getLibreTinyVersion (UpdateClass)</li> <li>getUF2Error (UpdateClass)</li> <li>gatewayIP (WiFiClass)</li> <li>getAutoReconnect (WiFiClass)</li> <li>getEncryption (WiFiClass)</li> <li>getHostname (WiFiClass)</li> <li>getMode (WiFiClass)</li> <li>getNetworkInfo (WiFiClass)</li> <li>getSleep (WiFiClass)</li> <li>getTxPower (WiFiClass)</li> <li>gateway (WiFiNetworkInfo)</li> <li>gw (esp_netif_ip_info_t)</li> <li>getLastWrite (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_members/#h","title":"h","text":"<ul> <li>host (Cookie)</li> <li>http_only (Cookie)</li> <li>handle (FunctionRequestHandler, RequestHandler, StaticRequestHandler)</li> <li>HTTPClient (HTTPClient)</li> <li>handleHeaderResponse (HTTPClient)</li> <li>hasHeader (HTTPClient, WebServer)</li> <li>header (HTTPClient, WebServer)</li> <li>headerName (HTTPClient, WebServer)</li> <li>headers (HTTPClient, WebServer)</li> <li>hasClient (IWiFiServer, LwIPServer)</li> <li>hasError (UpdateClass)</li> <li>handleClient (WebServer)</li> <li>hasArg (WebServer)</li> <li>hostHeader (WebServer)</li> <li>handlers (WiFiClass)</li> <li>hostByName (WiFiClass)</li> <li>hostname (WiFiClass, mDNS)</li> <li>hasTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#i","title":"i","text":"<ul> <li>id (EventHandler_s)</li> <li>IPreferences (IPreferences)</li> <li>isKey (IPreferences)</li> <li>IWiFiClient (IWiFiClient)</li> <li>IWiFiServer (IWiFiServer)</li> <li>IWiFiUDP (IWiFiUDP)</li> <li>isValid (LibreTinyOTA)</li> <li>in (MD5Context)</li> <li>init (MbedTLSClient)</li> <li>invert (SoftSerial)</li> <li>isFinished (UpdateClass)</li> <li>isRunning (UpdateClass)</li> <li>initPathArgs (Uri, UriBraces, UriRegex)</li> <li>isConnected (WiFiClass)</li> <li>IPv6Address (arduino::IPv6Address)</li> <li>ip (esp_netif_ip6_info_t, esp_netif_ip_info_t, ip_event_ap_staipassigned_t)</li> <li>isDirectory (fs::File, fs::FileImpl)</li> <li>if_index (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>ip6_info (ip_event_got_ip6_t)</li> <li>ip_index (ip_event_got_ip6_t)</li> <li>ip_changed (ip_event_got_ip_t)</li> <li>ip_info (ip_event_got_ip_t)</li> <li>info (lt_ota_ctx_t)</li> <li>IP (mDNS)</li> <li>IPv6 (mDNS)</li> <li>instanceName (mDNS)</li> <li>ifx (wifi_event_action_tx_status_t)</li> <li>is_mesh_child (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_members/#k","title":"k","text":"<ul> <li>key (HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_members/#l","title":"l","text":"<ul> <li>lastId (EventHandler_s)</li> <li>localIP (IWiFiClient, LwIPClient, WiFiClass, WiFiNetworkInfo)</li> <li>localPort (IWiFiClient, LwIPClient)</li> <li>lastError (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>loadPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>listenOnLocalhost (IWiFiServer)</li> <li>LwIPClient (LwIPClient)</li> <li>LwIPRxBuffer (LwIPRxBuffer)</li> <li>LwIPServer (LwIPServer)</li> <li>LwIPUDP (LwIPUDP)</li> <li>localIPv6 (WiFiClass)</li> </ul>"},{"location":"ltapi/class_members/#m","title":"m","text":"<ul> <li>max_age (Cookie)</li> <li>multicast_ip (LwIPUDP)</li> <li>MbedTLSClient (MbedTLSClient)</li> <li>md5 (UpdateClass)</li> <li>md5Ctx (UpdateClass)</li> <li>md5Digest (UpdateClass)</li> <li>md5Expected (UpdateClass)</li> <li>md5String (UpdateClass)</li> <li>method (WebServer)</li> <li>macAddress (WiFiClass)</li> <li>macToString (WiFiClass)</li> <li>mode (WiFiClass)</li> <li>modePriv (WiFiClass)</li> <li>mkdir (fs::FS, fs::FSImpl)</li> <li>manufacturer_id (lt_flash_id_t)</li> <li>mDNS (mDNS)</li> <li>mimeType (mime::Entry)</li> <li>mac (wifi_event_ap_probe_req_rx_t, wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_members/#n","title":"n","text":"<ul> <li>name (Cookie, HTTPUpload, fs::File, fs::FileImpl)</li> <li>next (RequestHandler, cbuf)</li> <li>networkID (WiFiClass)</li> <li>netmask (esp_netif_ip_info_t)</li> <li>numTxt (mDNS)</li> <li>new_mode (wifi_event_sta_authmode_change_t)</li> <li>number (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_members/#o","title":"o","text":"<ul> <li>onReceive (HardwareI2C)</li> <li>onReceiveCallback (HardwareI2C)</li> <li>onRequest (HardwareI2C)</li> <li>onRequestCallback (HardwareI2C)</li> <li>operator bool (IWiFiClient, IWiFiServer, LwIPServer, SerialClass, SoftwareSerial, fs::File, fs::FileImpl)</li> <li>operator!= (IWiFiClient)</li> <li>operator== (IWiFiClient, arduino::IPv6Address)</li> <li>operator= (LwIPClient, arduino::IPv6Address)</li> <li>onProgress (UpdateClass)</li> <li>on (WebServer)</li> <li>onFileUpload (WebServer)</li> <li>onNotFound (WebServer)</li> <li>onEvent (WiFiClass)</li> <li>operator const uint32_t * (arduino::IPv6Address)</li> <li>operator const uint8_t * (arduino::IPv6Address)</li> <li>operator[] (arduino::IPv6Address)</li> <li>open (fs::FS, fs::FSImpl)</li> <li>openNextFile (fs::File, fs::FileImpl)</li> <li>old_mode (wifi_event_sta_authmode_change_t)</li> </ul>"},{"location":"ltapi/class_members/#p","title":"p","text":"<ul> <li>path (Cookie, fs::File, fs::FileImpl)</li> <li>PATCH (HTTPClient)</li> <li>POST (HTTPClient)</li> <li>PUT (HTTPClient)</li> <li>peek (HardwareI2C, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File)</li> <li>putBool (IPreferences)</li> <li>putBytes (IPreferences)</li> <li>putChar (IPreferences)</li> <li>putDouble (IPreferences)</li> <li>putFloat (IPreferences)</li> <li>putInt (IPreferences)</li> <li>putLong (IPreferences)</li> <li>putLong64 (IPreferences)</li> <li>putShort (IPreferences)</li> <li>putString (IPreferences)</li> <li>putUChar (IPreferences)</li> <li>putUInt (IPreferences)</li> <li>putULong (IPreferences)</li> <li>putULong64 (IPreferences)</li> <li>putUShort (IPreferences)</li> <li>parsePacket (IWiFiUDP, LwIPUDP)</li> <li>pathArg (RequestHandler, WebServer)</li> <li>pathArgs (RequestHandler)</li> <li>port (SerialClass, mDNS)</li> <li>param (SoftData, SoftSerial, SoftwareSerial)</li> <li>pin (SoftData)</li> <li>printError (UpdateClass)</li> <li>printErrorContext (UpdateClass)</li> <li>progress (UpdateClass)</li> <li>progressHandler (UpdateClass)</li> <li>postEvent (WiFiClass)</li> <li>printDiag (WiFiClass)</li> <li>psk (WiFiClass)</li> <li>password (WiFiNetworkInfo)</li> <li>passphrase (WifiAPlist_t, wifi_event_sta_wps_er_success_t)</li> <li>printTo (arduino::IPv6Address)</li> <li>plainchar (base64_decodestate)</li> <li>position (fs::File, fs::FileImpl)</li> <li>peer_mac (wifi_event_ftm_report_t)</li> <li>pin_code (wifi_event_sta_wps_er_pin_t)</li> </ul>"},{"location":"ltapi/class_members/#q","title":"q","text":"<ul> <li>queryHost (mDNS)</li> <li>queryService (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#r","title":"r","text":"<ul> <li>random (EspClass)</li> <li>rebootIntoUartDownloadMode (EspClass)</li> <li>reset (EspClass)</li> <li>restart (EspClass, LibreTiny)</li> <li>readBlock (FlashClass)</li> <li>resetCookieJar (HTTPClient)</li> <li>returnError (HTTPClient)</li> <li>read (HardwareI2C, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>requestFrom (HardwareI2C)</li> <li>remove (IPreferences, cbuf, fs::FS, fs::FSImpl)</li> <li>remoteIP (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>remotePort (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>restartDownloadMode (LibreTiny)</li> <li>r_available (LwIPRxBuffer)</li> <li>remote_ip (LwIPUDP)</li> <li>remote_port (LwIPUDP)</li> <li>rx_buffer (LwIPUDP)</li> <li>rx (SerialClass, SoftSerial)</li> <li>remaining (UpdateClass)</li> <li>rollBack (UpdateClass)</li> <li>requestAuthentication (WebServer)</li> <li>RSSI (WiFiClass)</li> <li>reconnect (WiFiClass)</li> <li>removeEvent (WiFiClass)</li> <li>resetNetworkInfo (WiFiClass)</li> <li>restoreAPConfig (WiFiClass)</li> <li>restoreSTAConfig (WiFiClass)</li> <li>run (WiFiMulti)</li> <li>rssi (WiFiScanAP, wifi_event_ap_probe_req_rx_t, wifi_ftm_report_entry_t)</li> <li>running (WiFiScanData, lt_ota_ctx_t)</li> <li>raw_address (arduino::IPv6Address)</li> <li>result (base64_encodestate)</li> <li>resize (cbuf)</li> <li>resizeAdd (cbuf)</li> <li>room (cbuf)</li> <li>rename (fs::FS, fs::FSImpl)</li> <li>rmdir (fs::FS, fs::FSImpl)</li> <li>readBytes (fs::File)</li> <li>rewindDirectory (fs::File, fs::FileImpl)</li> <li>rtt_est (wifi_event_ftm_report_t)</li> <li>rtt_raw (wifi_event_ftm_report_t)</li> <li>reason (wifi_event_sta_disconnected_t)</li> <li>rtt (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#s","title":"s","text":"<ul> <li>secure (Cookie)</li> <li>scb (EventHandler_s)</li> <li>sendHeader (HTTPClient, WebServer)</li> <li>sendRequest (HTTPClient)</li> <li>setAuthorization (HTTPClient)</li> <li>setAuthorizationType (HTTPClient)</li> <li>setConnectTimeout (HTTPClient)</li> <li>setCookie (HTTPClient)</li> <li>setCookieJar (HTTPClient)</li> <li>setFollowRedirects (HTTPClient)</li> <li>setRedirectLimit (HTTPClient)</li> <li>setReuse (HTTPClient)</li> <li>setTimeout (HTTPClient, IWiFiClient, IWiFiServer, LwIPClient, LwIPServer)</li> <li>setURL (HTTPClient)</li> <li>setUserAgent (HTTPClient)</li> <li>status (HTTPUpload, WiFiClass, wifi_event_action_tx_status_t, wifi_event_ftm_report_t, wifi_event_sta_scan_done_t)</li> <li>setClock (HardwareI2C)</li> <li>setPins (HardwareI2C)</li> <li>socket (IWiFiClient, LwIPClient)</li> <li>setAlpnProtocols (IWiFiClientSecure, MbedTLSClient)</li> <li>setCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>setCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>setHandshakeTimeout (IWiFiClientSecure, MbedTLSClient)</li> <li>setInsecure (IWiFiClientSecure, MbedTLSClient)</li> <li>setPreSharedKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setNoDelay (IWiFiServer, LwIPServer)</li> <li>stop (IWiFiServer, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, WebServer)</li> <li>stopAll (IWiFiServer, LwIPServer)</li> <li>switchImage (LibreTinyOTA)</li> <li>server_port (LwIPUDP)</li> <li>supported (PinInfo)</li> <li>SerialClass (SerialClass)</li> <li>state (SoftData, mbedtls_md5_context)</li> <li>SoftwareSerial (SoftwareSerial)</li> <li>startTx (SoftwareSerial)</li> <li>StaticRequestHandler (StaticRequestHandler)</li> <li>setMD5 (UpdateClass)</li> <li>size (UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>send (WebServer)</li> <li>sendContent (WebServer)</li> <li>sendContent_P (WebServer)</li> <li>send_P (WebServer)</li> <li>serveStatic (WebServer)</li> <li>setContentLength (WebServer)</li> <li>streamFile (WebServer)</li> <li>SSID (WiFiClass)</li> <li>scan (WiFiClass)</li> <li>scanAlloc (WiFiClass)</li> <li>scanComplete (WiFiClass)</li> <li>scanDelete (WiFiClass)</li> <li>scanInit (WiFiClass)</li> <li>scanNetworks (WiFiClass)</li> <li>setAutoReconnect (WiFiClass)</li> <li>setHostname (WiFiClass)</li> <li>setMacAddress (WiFiClass)</li> <li>setSleep (WiFiClass)</li> <li>setTxPower (WiFiClass)</li> <li>softAP (WiFiClass)</li> <li>softAPBroadcastIP (WiFiClass)</li> <li>softAPConfig (WiFiClass)</li> <li>softAPIP (WiFiClass)</li> <li>softAPIPv6 (WiFiClass)</li> <li>softAPNetworkID (WiFiClass)</li> <li>softAPSSID (WiFiClass)</li> <li>softAPSubnetCIDR (WiFiClass)</li> <li>softAPSubnetMask (WiFiClass)</li> <li>softAPdisconnect (WiFiClass)</li> <li>softAPenableIpV6 (WiFiClass)</li> <li>softAPgetHostname (WiFiClass)</li> <li>softAPgetStationNum (WiFiClass)</li> <li>softAPmacAddress (WiFiClass)</li> <li>softAPsetHostname (WiFiClass)</li> <li>subnetCIDR (WiFiClass)</li> <li>subnetMask (WiFiClass)</li> <li>ssid (WiFiNetworkInfo, WiFiScanAP, WifiAPlist_t, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t, wifi_event_sta_wps_er_success_t)</li> <li>ssidHidden (WiFiNetworkInfo)</li> <li>subnet (WiFiNetworkInfo)</li> <li>step (base64_decodestate, base64_encodestate)</li> <li>stepcount (base64_encodestate)</li> <li>seek (fs::File, fs::FileImpl)</li> <li>setBufferSize (fs::File, fs::FileImpl)</li> <li>setInstanceName (mDNS)</li> <li>ssid_len (wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>scan_id (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_members/#t","title":"t","text":"<ul> <li>totalSize (HTTPUpload)</li> <li>type (HTTPUpload)</li> <li>tx_buffer (LwIPUDP)</li> <li>tx_buffer_len (LwIPUDP)</li> <li>tx (SerialClass, SoftSerial)</li> <li>THandlerFunction_Progress (UpdateClass)</li> <li>THandlerFunction (WebServer)</li> <li>timeout (WiFiScanData)</li> <li>toString (arduino::IPv6Address)</li> <li>txt (mDNS)</li> <li>txtKey (mDNS)</li> <li>total (mbedtls_md5_context)</li> <li>t1 (wifi_ftm_report_entry_t)</li> <li>t2 (wifi_ftm_report_entry_t)</li> <li>t3 (wifi_ftm_report_entry_t)</li> <li>t4 (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#u","title":"u","text":"<ul> <li>upload (FunctionRequestHandler, RequestHandler, WebServer)</li> <li>useHTTP10 (HTTPClient)</li> <li>udp_server (LwIPUDP)</li> <li>Uri (Uri)</li> <li>UriBraces (UriBraces)</li> <li>UriGlob (UriGlob)</li> <li>UriRegex (UriRegex)</li> <li>uri (WebServer)</li> <li>urlDecode (WebServer)</li> <li>uf2 (lt_ota_ctx_t)</li> </ul>"},{"location":"ltapi/class_members/#v","title":"v","text":"<ul> <li>valid (Cookie)</li> <li>value (Cookie, HTTPClient::RequestArgument, WebServer::RequestArgument)</li> <li>verify (IWiFiClientSecure, MbedTLSClient)</li> <li>validate (WiFiClass)</li> </ul>"},{"location":"ltapi/class_members/#w","title":"w","text":"<ul> <li>wdtDisable (EspClass)</li> <li>wdtEnable (EspClass)</li> <li>wdtFeed (EspClass)</li> <li>writeBlock (FlashClass)</li> <li>writeToStream (HTTPClient)</li> <li>writeToStreamDataBlock (HTTPClient)</li> <li>write (HardwareI2C, IWiFiClient, IWiFiServer, IWiFiUDP, LwIPClient, LwIPServer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>write_P (IWiFiClient)</li> <li>writeStream (UpdateClass)</li> <li>WebServer (WebServer)</li> <li>WiFiClass (WiFiClass)</li> <li>waitForConnectResult (WiFiClass)</li> <li>WiFiMulti (WiFiMulti)</li> <li>wrap_if_bufend (cbuf)</li> </ul>"},{"location":"ltapi/class_members/#z","title":"z","text":"<ul> <li>zone (esp_ip6_addr)</li> </ul>"},{"location":"ltapi/class_members/#_1","title":"~","text":"<ul> <li>~FunctionRequestHandler (FunctionRequestHandler)</li> <li>~HTTPClient (HTTPClient)</li> <li>~IPreferences (IPreferences)</li> <li>~IWiFiClient (IWiFiClient)</li> <li>~IWiFiServer (IWiFiServer)</li> <li>~IWiFiUDP (IWiFiUDP)</li> <li>~LwIPClient (LwIPClient)</li> <li>~LwIPRxBuffer (LwIPRxBuffer)</li> <li>~LwIPUDP (LwIPUDP)</li> <li>~MbedTLSClient (MbedTLSClient)</li> <li>~RequestHandler (RequestHandler)</li> <li>~Uri (Uri)</li> <li>~WebServer (WebServer)</li> <li>~WiFiClass (WiFiClass)</li> <li>~WiFiMulti (WiFiMulti)</li> <li>~IPv6Address (arduino::IPv6Address)</li> <li>~cbuf (cbuf)</li> <li>~FSImpl (fs::FSImpl)</li> <li>~FileImpl (fs::FileImpl)</li> <li>~mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#_","title":"_","text":"<ul> <li>_fn (FunctionRequestHandler)</li> <li>_method (FunctionRequestHandler)</li> <li>_ufn (FunctionRequestHandler)</li> <li>_uri (FunctionRequestHandler, HTTPClient, StaticRequestHandler, Uri)</li> <li>_authorizationType (HTTPClient)</li> <li>_base64Authorization (HTTPClient)</li> <li>_canReuse (HTTPClient)</li> <li>_client (HTTPClient)</li> <li>_connectTimeout (HTTPClient)</li> <li>_cookieJar (HTTPClient)</li> <li>_currentHeaders (HTTPClient, WebServer)</li> <li>_followRedirects (HTTPClient)</li> <li>_headerKeysCount (HTTPClient, WebServer)</li> <li>_headers (HTTPClient)</li> <li>_host (HTTPClient)</li> <li>_location (HTTPClient)</li> <li>_port (HTTPClient, LwIPServer)</li> <li>_protocol (HTTPClient)</li> <li>_redirectLimit (HTTPClient)</li> <li>_returnCode (HTTPClient)</li> <li>_reuse (HTTPClient)</li> <li>_secure (HTTPClient)</li> <li>_size (HTTPClient, LwIPRxBuffer, cbuf)</li> <li>_tcpDeprecated (HTTPClient)</li> <li>_tcpTimeout (HTTPClient)</li> <li>_transferEncoding (HTTPClient)</li> <li>_transportTraits (HTTPClient)</li> <li>_useHTTP10 (HTTPClient)</li> <li>_userAgent (HTTPClient)</li> <li>_freq (HardwareI2C)</li> <li>_scl (HardwareI2C)</li> <li>_sda (HardwareI2C)</li> <li>_connected (LwIPClient)</li> <li>_rxBuffer (LwIPClient)</li> <li>_sock (LwIPClient, LwIPRxBuffer, LwIPServer)</li> <li>_buffer (LwIPRxBuffer)</li> <li>_failed (LwIPRxBuffer)</li> <li>_fill (LwIPRxBuffer)</li> <li>_pos (LwIPRxBuffer)</li> <li>_active (LwIPServer)</li> <li>_addr (LwIPServer)</li> <li>_maxClients (LwIPServer)</li> <li>_noDelay (LwIPServer)</li> <li>_sockAccepted (LwIPServer)</li> <li>_alpnProtocols (MbedTLSClient)</li> <li>_caCert (MbedTLSClient)</li> <li>_caCertStr (MbedTLSClient)</li> <li>_clientCert (MbedTLSClient)</li> <li>_clientCertStr (MbedTLSClient)</li> <li>_clientKey (MbedTLSClient)</li> <li>_clientKeyStr (MbedTLSClient)</li> <li>_handshakeTimeout (MbedTLSClient)</li> <li>_insecure (MbedTLSClient)</li> <li>_peeked (MbedTLSClient)</li> <li>_pskIdentStr (MbedTLSClient)</li> <li>_pskStr (MbedTLSClient)</li> <li>_sockTls (MbedTLSClient)</li> <li>_sslCfg (MbedTLSClient)</li> <li>_sslCtx (MbedTLSClient)</li> <li>_useRootCA (MbedTLSClient)</li> <li>_next (RequestHandler)</li> <li>_baseUriLength (StaticRequestHandler)</li> <li>_cache_header (StaticRequestHandler)</li> <li>_fs (StaticRequestHandler)</li> <li>_isFile (StaticRequestHandler)</li> <li>_path (StaticRequestHandler)</li> <li>_addRequestHandler (WebServer)</li> <li>_chunked (WebServer)</li> <li>_collectHeader (WebServer)</li> <li>_contentLength (WebServer)</li> <li>_corsEnabled (WebServer)</li> <li>_currentArgCount (WebServer)</li> <li>_currentArgs (WebServer)</li> <li>_currentClient (WebServer)</li> <li>_currentClientWrite (WebServer)</li> <li>_currentClientWrite_P (WebServer)</li> <li>_currentHandler (WebServer)</li> <li>_currentMethod (WebServer)</li> <li>_currentStatus (WebServer)</li> <li>_currentUpload (WebServer)</li> <li>_currentUri (WebServer)</li> <li>_currentVersion (WebServer)</li> <li>_extractParam (WebServer)</li> <li>_fileUploadHandler (WebServer)</li> <li>_finalizeResponse (WebServer)</li> <li>_firstHandler (WebServer)</li> <li>_getRandomHexString (WebServer)</li> <li>_handleRequest (WebServer)</li> <li>_hostHeader (WebServer)</li> <li>_lastHandler (WebServer)</li> <li>_notFoundHandler (WebServer)</li> <li>_nullDelay (WebServer)</li> <li>_parseArguments (WebServer)</li> <li>_parseForm (WebServer)</li> <li>_parseFormUploadAborted (WebServer)</li> <li>_parseRequest (WebServer)</li> <li>_postArgs (WebServer)</li> <li>_postArgsLen (WebServer)</li> <li>_prepareHeader (WebServer)</li> <li>_responseCodeToString (WebServer)</li> <li>_responseHeaders (WebServer)</li> <li>_server (WebServer)</li> <li>_snonce (WebServer)</li> <li>_sopaque (WebServer)</li> <li>_srealm (WebServer)</li> <li>_statusChange (WebServer)</li> <li>_streamFileCore (WebServer)</li> <li>_uploadReadByte (WebServer)</li> <li>_uploadWriteByte (WebServer)</li> <li>_address (arduino::IPv6Address)</li> <li>_begin (cbuf)</li> <li>_buf (cbuf)</li> <li>_bufend (cbuf)</li> <li>_end (cbuf)</li> <li>_impl (fs::FS)</li> <li>_p (fs::File)</li> </ul>"},{"location":"ltapi/class_member_functions/","title":"Class Member Functions","text":""},{"location":"ltapi/class_member_functions/#a","title":"a","text":"<ul> <li>addHeader (HTTPClient)</li> <li>available (HardwareI2C, IWiFiServer, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File)</li> <li>accept (IWiFiServer, LwIPServer)</li> <li>abort (UpdateClass)</li> <li>addHandler (WebServer)</li> <li>arg (WebServer)</li> <li>argName (WebServer)</li> <li>args (WebServer)</li> <li>authenticate (WebServer)</li> <li>allLocalIPv6 (WiFiClass)</li> <li>addAP (WiFiMulti)</li> <li>addService (mDNS)</li> <li>addServiceImpl (mDNS)</li> <li>addServiceTxt (mDNS)</li> <li>addServiceTxtImpl (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#b","title":"b","text":"<ul> <li>begin (HTTPClient, HardwareI2C, IPreferences, IWiFiServer, IWiFiUDP, LwIPServer, LwIPUDP, SerialClass, SoftwareSerial, UpdateClass, WebServer, WiFiClass, mDNS)</li> <li>beginInternal (HTTPClient)</li> <li>beginTransmission (HardwareI2C)</li> <li>beginMulticast (IWiFiUDP, LwIPUDP)</li> <li>beginMulticastPacket (IWiFiUDP, LwIPUDP)</li> <li>beginPacket (IWiFiUDP, LwIPUDP)</li> <li>BSSID (WiFiClass)</li> <li>BSSIDstr (WiFiClass)</li> <li>broadcastIP (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#c","title":"c","text":"<ul> <li>canHandle (FunctionRequestHandler, RequestHandler, StaticRequestHandler, Uri, UriBraces, UriGlob, UriRegex)</li> <li>canUpload (FunctionRequestHandler, RequestHandler)</li> <li>clear (HTTPClient, IPreferences)</li> <li>clearAllCookies (HTTPClient)</li> <li>collectHeaders (HTTPClient, WebServer)</li> <li>connect (HTTPClient, IWiFiClient, IWiFiClientSecure, LwIPClient, MbedTLSClient)</li> <li>connected (HTTPClient, LwIPClient)</li> <li>close (IWiFiServer, WebServer, fs::File, fs::FileImpl)</li> <li>canRollback (LibreTinyOTA)</li> <li>configure (SerialClass)</li> <li>canRollBack (UpdateClass)</li> <li>cleanup (UpdateClass, mDNS)</li> <li>clearError (UpdateClass)</li> <li>clone (Uri, UriBraces, UriGlob, UriRegex)</li> <li>client (WebServer)</li> <li>calculateBroadcast (WiFiClass)</li> <li>calculateNetworkID (WiFiClass)</li> <li>calculateSubnetCIDR (WiFiClass)</li> <li>channel (WiFiClass)</li> <li>config (WiFiClass)</li> <li>cbuf (cbuf)</li> </ul>"},{"location":"ltapi/class_member_functions/#d","title":"d","text":"<ul> <li>disconnect (HTTPClient, WiFiClass)</li> <li>disable (LibreTinyWDT)</li> <li>dataFree (WiFiClass)</li> <li>dataInitialize (WiFiClass)</li> <li>dnsIP (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#e","title":"e","text":"<ul> <li>EventHandler_s (EventHandler_s)</li> <li>eraseSector (FlashClass)</li> <li>end (HTTPClient, HardwareI2C, IPreferences, IWiFiServer, LwIPServer, SerialClass, SoftwareSerial, UpdateClass, mDNS)</li> <li>errorToString (HTTPClient)</li> <li>endTransmission (HardwareI2C)</li> <li>endPacket (IWiFiUDP, LwIPUDP)</li> <li>enable (LibreTinyWDT)</li> <li>endTx (SoftwareSerial)</li> <li>errorString (UpdateClass)</li> <li>enableCORS (WebServer)</li> <li>enableCrossOrigin (WebServer)</li> <li>enableDelay (WebServer)</li> <li>enableAP (WiFiClass)</li> <li>enableIpV6 (WiFiClass)</li> <li>enableSTA (WiFiClass)</li> <li>encryptionType (WiFiClass)</li> <li>encode (base64)</li> <li>empty (cbuf)</li> <li>exists (fs::FS, fs::FSImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#f","title":"f","text":"<ul> <li>flashEraseSector (EspClass)</li> <li>flashRead (EspClass)</li> <li>flashWrite (EspClass)</li> <li>FunctionRequestHandler (FunctionRequestHandler)</li> <li>flush (HardwareI2C, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>freeEntries (IPreferences)</li> <li>fd (IWiFiClient, LwIPClient)</li> <li>feed (LibreTinyWDT)</li> <li>failed (LwIPRxBuffer)</li> <li>fillBuffer (LwIPRxBuffer)</li> <li>fromString (arduino::IPv6Address)</li> <li>full (cbuf)</li> <li>FS (fs::FS)</li> <li>FSImpl (fs::FSImpl)</li> <li>File (fs::File)</li> </ul>"},{"location":"ltapi/class_member_functions/#g","title":"g","text":"<ul> <li>getBootMode (EspClass)</li> <li>getBootVersion (EspClass)</li> <li>getChipId (EspClass, FlashClass, LibreTiny)</li> <li>getCoreVersion (EspClass)</li> <li>getCpuFreqMHz (EspClass, LibreTiny)</li> <li>getCycleCount (EspClass, LibreTiny)</li> <li>getFlashChipId (EspClass, LibreTiny)</li> <li>getFlashChipMode (EspClass)</li> <li>getFlashChipRealSize (EspClass)</li> <li>getFlashChipSize (EspClass, LibreTiny)</li> <li>getFlashChipSizeByChipId (EspClass)</li> <li>getFlashChipVendorId (EspClass)</li> <li>getFreeHeap (EspClass, LibreTiny)</li> <li>getFullVersion (EspClass)</li> <li>getMaxFreeBlockSize (EspClass, LibreTiny)</li> <li>getResetInfo (EspClass)</li> <li>getResetReason (EspClass, LibreTiny)</li> <li>getSdkVersion (EspClass)</li> <li>getVcc (EspClass)</li> <li>getSize (FlashClass, HTTPClient)</li> <li>GET (HTTPClient)</li> <li>generateCookieString (HTTPClient)</li> <li>getLocation (HTTPClient)</li> <li>getStream (HTTPClient)</li> <li>getStreamPtr (HTTPClient)</li> <li>getClock (HardwareI2C)</li> <li>getBool (IPreferences)</li> <li>getBytes (IPreferences)</li> <li>getBytesLength (IPreferences)</li> <li>getChar (IPreferences)</li> <li>getDouble (IPreferences)</li> <li>getFloat (IPreferences)</li> <li>getInt (IPreferences)</li> <li>getLong (IPreferences)</li> <li>getLong64 (IPreferences)</li> <li>getShort (IPreferences)</li> <li>getString (IPreferences)</li> <li>getType (IPreferences, LibreTinyOTA)</li> <li>getUChar (IPreferences)</li> <li>getUInt (IPreferences)</li> <li>getULong (IPreferences)</li> <li>getULong64 (IPreferences)</li> <li>getUShort (IPreferences)</li> <li>getFingerprintSHA256 (IWiFiClientSecure, MbedTLSClient)</li> <li>getNoDelay (IWiFiServer, LwIPServer)</li> <li>getBoard (LibreTiny)</li> <li>getChipCoreType (LibreTiny)</li> <li>getChipCores (LibreTiny)</li> <li>getChipFamily (LibreTiny)</li> <li>getChipFamilyName (LibreTiny)</li> <li>getChipModel (LibreTiny)</li> <li>getChipType (LibreTiny)</li> <li>getCpuFreq (LibreTiny)</li> <li>getDeviceName (LibreTiny)</li> <li>getHeapSize (LibreTiny)</li> <li>getMaxAllocHeap (LibreTiny)</li> <li>getMinFreeHeap (LibreTiny)</li> <li>getRamSize (LibreTiny)</li> <li>getResetReasonName (LibreTiny)</li> <li>getVersion (LibreTiny)</li> <li>gpioRecover (LibreTiny)</li> <li>getCurrentIndex (LibreTinyOTA)</li> <li>getStoredIndex (LibreTinyOTA)</li> <li>getUF2Scheme (LibreTinyOTA)</li> <li>getContentType (StaticRequestHandler)</li> <li>getBoardName (UpdateClass)</li> <li>getError (UpdateClass)</li> <li>getErrorCode (UpdateClass)</li> <li>getFirmwareName (UpdateClass)</li> <li>getFirmwareVersion (UpdateClass)</li> <li>getLibreTinyVersion (UpdateClass)</li> <li>getUF2Error (UpdateClass)</li> <li>gatewayIP (WiFiClass)</li> <li>getAutoReconnect (WiFiClass)</li> <li>getEncryption (WiFiClass)</li> <li>getHostname (WiFiClass)</li> <li>getMode (WiFiClass)</li> <li>getNetworkInfo (WiFiClass)</li> <li>getSleep (WiFiClass)</li> <li>getTxPower (WiFiClass)</li> <li>getLastWrite (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#h","title":"h","text":"<ul> <li>handle (FunctionRequestHandler, RequestHandler, StaticRequestHandler)</li> <li>HTTPClient (HTTPClient)</li> <li>handleHeaderResponse (HTTPClient)</li> <li>hasHeader (HTTPClient, WebServer)</li> <li>header (HTTPClient, WebServer)</li> <li>headerName (HTTPClient, WebServer)</li> <li>headers (HTTPClient, WebServer)</li> <li>hasClient (IWiFiServer, LwIPServer)</li> <li>hasError (UpdateClass)</li> <li>handleClient (WebServer)</li> <li>hasArg (WebServer)</li> <li>hostHeader (WebServer)</li> <li>hostByName (WiFiClass)</li> <li>hostname (WiFiClass, mDNS)</li> <li>hasTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#i","title":"i","text":"<ul> <li>IPreferences (IPreferences)</li> <li>isKey (IPreferences)</li> <li>IWiFiClient (IWiFiClient)</li> <li>IWiFiServer (IWiFiServer)</li> <li>IWiFiUDP (IWiFiUDP)</li> <li>isValid (LibreTinyOTA)</li> <li>init (MbedTLSClient)</li> <li>isFinished (UpdateClass)</li> <li>isRunning (UpdateClass)</li> <li>initPathArgs (Uri, UriBraces, UriRegex)</li> <li>isConnected (WiFiClass)</li> <li>IPv6Address (arduino::IPv6Address)</li> <li>isDirectory (fs::File, fs::FileImpl)</li> <li>IP (mDNS)</li> <li>IPv6 (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#l","title":"l","text":"<ul> <li>localIP (IWiFiClient, LwIPClient, WiFiClass)</li> <li>localPort (IWiFiClient, LwIPClient)</li> <li>lastError (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>loadPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>listenOnLocalhost (IWiFiServer)</li> <li>LwIPClient (LwIPClient)</li> <li>LwIPRxBuffer (LwIPRxBuffer)</li> <li>LwIPServer (LwIPServer)</li> <li>LwIPUDP (LwIPUDP)</li> <li>localIPv6 (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#m","title":"m","text":"<ul> <li>MbedTLSClient (MbedTLSClient)</li> <li>md5 (UpdateClass)</li> <li>md5String (UpdateClass)</li> <li>method (WebServer)</li> <li>macAddress (WiFiClass)</li> <li>macToString (WiFiClass)</li> <li>mode (WiFiClass)</li> <li>modePriv (WiFiClass)</li> <li>mkdir (fs::FS, fs::FSImpl)</li> <li>mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#n","title":"n","text":"<ul> <li>next (RequestHandler)</li> <li>networkID (WiFiClass)</li> <li>name (fs::File, fs::FileImpl)</li> <li>numTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#o","title":"o","text":"<ul> <li>onReceive (HardwareI2C)</li> <li>onRequest (HardwareI2C)</li> <li>operator bool (IWiFiClient, IWiFiServer, LwIPServer, SerialClass, SoftwareSerial, fs::File, fs::FileImpl)</li> <li>operator!= (IWiFiClient)</li> <li>operator== (IWiFiClient, arduino::IPv6Address)</li> <li>operator= (LwIPClient, arduino::IPv6Address)</li> <li>onProgress (UpdateClass)</li> <li>on (WebServer)</li> <li>onFileUpload (WebServer)</li> <li>onNotFound (WebServer)</li> <li>onEvent (WiFiClass)</li> <li>operator const uint32_t * (arduino::IPv6Address)</li> <li>operator const uint8_t * (arduino::IPv6Address)</li> <li>operator[] (arduino::IPv6Address)</li> <li>open (fs::FS, fs::FSImpl)</li> <li>openNextFile (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#p","title":"p","text":"<ul> <li>PATCH (HTTPClient)</li> <li>POST (HTTPClient)</li> <li>PUT (HTTPClient)</li> <li>peek (HardwareI2C, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File)</li> <li>putBool (IPreferences)</li> <li>putBytes (IPreferences)</li> <li>putChar (IPreferences)</li> <li>putDouble (IPreferences)</li> <li>putFloat (IPreferences)</li> <li>putInt (IPreferences)</li> <li>putLong (IPreferences)</li> <li>putLong64 (IPreferences)</li> <li>putShort (IPreferences)</li> <li>putString (IPreferences)</li> <li>putUChar (IPreferences)</li> <li>putUInt (IPreferences)</li> <li>putULong (IPreferences)</li> <li>putULong64 (IPreferences)</li> <li>putUShort (IPreferences)</li> <li>parsePacket (IWiFiUDP, LwIPUDP)</li> <li>pathArg (RequestHandler, WebServer)</li> <li>printError (UpdateClass)</li> <li>printErrorContext (UpdateClass)</li> <li>progress (UpdateClass)</li> <li>progressHandler (UpdateClass)</li> <li>postEvent (WiFiClass)</li> <li>printDiag (WiFiClass)</li> <li>psk (WiFiClass)</li> <li>printTo (arduino::IPv6Address)</li> <li>path (fs::File, fs::FileImpl)</li> <li>position (fs::File, fs::FileImpl)</li> <li>port (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#q","title":"q","text":"<ul> <li>queryHost (mDNS)</li> <li>queryService (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#r","title":"r","text":"<ul> <li>random (EspClass)</li> <li>rebootIntoUartDownloadMode (EspClass)</li> <li>reset (EspClass)</li> <li>restart (EspClass, LibreTiny)</li> <li>readBlock (FlashClass)</li> <li>resetCookieJar (HTTPClient)</li> <li>returnError (HTTPClient)</li> <li>read (HardwareI2C, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>requestFrom (HardwareI2C)</li> <li>remove (IPreferences, cbuf, fs::FS, fs::FSImpl)</li> <li>remoteIP (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>remotePort (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>restartDownloadMode (LibreTiny)</li> <li>r_available (LwIPRxBuffer)</li> <li>remaining (UpdateClass)</li> <li>rollBack (UpdateClass)</li> <li>requestAuthentication (WebServer)</li> <li>RSSI (WiFiClass)</li> <li>reconnect (WiFiClass)</li> <li>removeEvent (WiFiClass)</li> <li>resetNetworkInfo (WiFiClass)</li> <li>restoreAPConfig (WiFiClass)</li> <li>restoreSTAConfig (WiFiClass)</li> <li>run (WiFiMulti)</li> <li>raw_address (arduino::IPv6Address)</li> <li>resize (cbuf)</li> <li>resizeAdd (cbuf)</li> <li>room (cbuf)</li> <li>rename (fs::FS, fs::FSImpl)</li> <li>rmdir (fs::FS, fs::FSImpl)</li> <li>readBytes (fs::File)</li> <li>rewindDirectory (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#s","title":"s","text":"<ul> <li>sendHeader (HTTPClient, WebServer)</li> <li>sendRequest (HTTPClient)</li> <li>setAuthorization (HTTPClient)</li> <li>setAuthorizationType (HTTPClient)</li> <li>setConnectTimeout (HTTPClient)</li> <li>setCookie (HTTPClient)</li> <li>setCookieJar (HTTPClient)</li> <li>setFollowRedirects (HTTPClient)</li> <li>setRedirectLimit (HTTPClient)</li> <li>setReuse (HTTPClient)</li> <li>setTimeout (HTTPClient, IWiFiClient, IWiFiServer, LwIPClient, LwIPServer)</li> <li>setURL (HTTPClient)</li> <li>setUserAgent (HTTPClient)</li> <li>setClock (HardwareI2C)</li> <li>setPins (HardwareI2C)</li> <li>socket (IWiFiClient, LwIPClient)</li> <li>setAlpnProtocols (IWiFiClientSecure, MbedTLSClient)</li> <li>setCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>setCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>setHandshakeTimeout (IWiFiClientSecure, MbedTLSClient)</li> <li>setInsecure (IWiFiClientSecure, MbedTLSClient)</li> <li>setPreSharedKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setNoDelay (IWiFiServer, LwIPServer)</li> <li>stop (IWiFiServer, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, WebServer)</li> <li>stopAll (IWiFiServer, LwIPServer)</li> <li>switchImage (LibreTinyOTA)</li> <li>SerialClass (SerialClass)</li> <li>SoftwareSerial (SoftwareSerial)</li> <li>startTx (SoftwareSerial)</li> <li>StaticRequestHandler (StaticRequestHandler)</li> <li>setMD5 (UpdateClass)</li> <li>size (UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>send (WebServer)</li> <li>sendContent (WebServer)</li> <li>sendContent_P (WebServer)</li> <li>send_P (WebServer)</li> <li>serveStatic (WebServer)</li> <li>setContentLength (WebServer)</li> <li>streamFile (WebServer)</li> <li>SSID (WiFiClass)</li> <li>scanAlloc (WiFiClass)</li> <li>scanComplete (WiFiClass)</li> <li>scanDelete (WiFiClass)</li> <li>scanInit (WiFiClass)</li> <li>scanNetworks (WiFiClass)</li> <li>setAutoReconnect (WiFiClass)</li> <li>setHostname (WiFiClass)</li> <li>setMacAddress (WiFiClass)</li> <li>setSleep (WiFiClass)</li> <li>setTxPower (WiFiClass)</li> <li>softAP (WiFiClass)</li> <li>softAPBroadcastIP (WiFiClass)</li> <li>softAPConfig (WiFiClass)</li> <li>softAPIP (WiFiClass)</li> <li>softAPIPv6 (WiFiClass)</li> <li>softAPNetworkID (WiFiClass)</li> <li>softAPSSID (WiFiClass)</li> <li>softAPSubnetCIDR (WiFiClass)</li> <li>softAPSubnetMask (WiFiClass)</li> <li>softAPdisconnect (WiFiClass)</li> <li>softAPenableIpV6 (WiFiClass)</li> <li>softAPgetHostname (WiFiClass)</li> <li>softAPgetStationNum (WiFiClass)</li> <li>softAPmacAddress (WiFiClass)</li> <li>softAPsetHostname (WiFiClass)</li> <li>status (WiFiClass)</li> <li>subnetCIDR (WiFiClass)</li> <li>subnetMask (WiFiClass)</li> <li>seek (fs::File, fs::FileImpl)</li> <li>setBufferSize (fs::File, fs::FileImpl)</li> <li>setInstanceName (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#t","title":"t","text":"<ul> <li>toString (arduino::IPv6Address)</li> <li>txt (mDNS)</li> <li>txtKey (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#u","title":"u","text":"<ul> <li>upload (FunctionRequestHandler, RequestHandler, WebServer)</li> <li>useHTTP10 (HTTPClient)</li> <li>Uri (Uri)</li> <li>UriBraces (UriBraces)</li> <li>UriGlob (UriGlob)</li> <li>UriRegex (UriRegex)</li> <li>uri (WebServer)</li> <li>urlDecode (WebServer)</li> </ul>"},{"location":"ltapi/class_member_functions/#v","title":"v","text":"<ul> <li>verify (IWiFiClientSecure, MbedTLSClient)</li> <li>validate (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#w","title":"w","text":"<ul> <li>wdtDisable (EspClass)</li> <li>wdtEnable (EspClass)</li> <li>wdtFeed (EspClass)</li> <li>writeBlock (FlashClass)</li> <li>writeToStream (HTTPClient)</li> <li>writeToStreamDataBlock (HTTPClient)</li> <li>write (HardwareI2C, IWiFiClient, IWiFiServer, IWiFiUDP, LwIPClient, LwIPServer, LwIPUDP, MbedTLSClient, SerialClass, SoftwareSerial, StreamString, UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>write_P (IWiFiClient)</li> <li>writeStream (UpdateClass)</li> <li>WebServer (WebServer)</li> <li>WiFiClass (WiFiClass)</li> <li>waitForConnectResult (WiFiClass)</li> <li>WiFiMulti (WiFiMulti)</li> <li>wrap_if_bufend (cbuf)</li> </ul>"},{"location":"ltapi/class_member_functions/#_1","title":"~","text":"<ul> <li>~FunctionRequestHandler (FunctionRequestHandler)</li> <li>~HTTPClient (HTTPClient)</li> <li>~IPreferences (IPreferences)</li> <li>~IWiFiClient (IWiFiClient)</li> <li>~IWiFiServer (IWiFiServer)</li> <li>~IWiFiUDP (IWiFiUDP)</li> <li>~LwIPClient (LwIPClient)</li> <li>~LwIPRxBuffer (LwIPRxBuffer)</li> <li>~LwIPUDP (LwIPUDP)</li> <li>~MbedTLSClient (MbedTLSClient)</li> <li>~RequestHandler (RequestHandler)</li> <li>~Uri (Uri)</li> <li>~WebServer (WebServer)</li> <li>~WiFiClass (WiFiClass)</li> <li>~WiFiMulti (WiFiMulti)</li> <li>~IPv6Address (arduino::IPv6Address)</li> <li>~cbuf (cbuf)</li> <li>~FSImpl (fs::FSImpl)</li> <li>~FileImpl (fs::FileImpl)</li> <li>~mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#_","title":"_","text":"<ul> <li>_addRequestHandler (WebServer)</li> <li>_collectHeader (WebServer)</li> <li>_currentClientWrite (WebServer)</li> <li>_currentClientWrite_P (WebServer)</li> <li>_extractParam (WebServer)</li> <li>_finalizeResponse (WebServer)</li> <li>_getRandomHexString (WebServer)</li> <li>_handleRequest (WebServer)</li> <li>_parseArguments (WebServer)</li> <li>_parseForm (WebServer)</li> <li>_parseFormUploadAborted (WebServer)</li> <li>_parseRequest (WebServer)</li> <li>_prepareHeader (WebServer)</li> <li>_responseCodeToString (WebServer)</li> <li>_streamFileCore (WebServer)</li> <li>_uploadReadByte (WebServer)</li> <li>_uploadWriteByte (WebServer)</li> </ul>"},{"location":"ltapi/class_member_variables/","title":"Class Member Variables","text":""},{"location":"ltapi/class_member_variables/#a","title":"a","text":"<ul> <li>addr (WiFiMacAddr, esp_ip4_addr, esp_ip6_addr)</li> <li>APlist (WiFiMulti)</li> <li>auth (WiFiNetworkInfo, WiFiScanAP)</li> <li>ap (WiFiScanData)</li> <li>aid (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> <li>authmode (wifi_event_sta_connected_t)</li> <li>ap_cred (wifi_event_sta_wps_er_success_t)</li> <li>ap_cred_cnt (wifi_event_sta_wps_er_success_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#b","title":"b","text":"<ul> <li>buf (HTTPUpload, MD5Context, SerialClass, SoftData, lt_ota_ctx_t)</li> <li>bits (MD5Context)</li> <li>baudrate (SerialClass)</li> <li>byte (SoftData)</li> <li>bssid (WiFiNetworkInfo, WiFiScanAP, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>bytes (arduino::IPv6Address)</li> <li>buf_pos (lt_ota_ctx_t)</li> <li>bytes_total (lt_ota_ctx_t)</li> <li>bytes_written (lt_ota_ctx_t)</li> <li>buffer (mbedtls_md5_context)</li> </ul>"},{"location":"ltapi/class_member_variables/#c","title":"c","text":"<ul> <li>cb (EventHandler_s)</li> <li>currentSize (HTTPUpload)</li> <li>config (SerialClass)</li> <li>callback (UpdateClass, lt_ota_ctx_t)</li> <li>ctx (UpdateClass)</li> <li>channel (WiFiNetworkInfo, WiFiScanAP, wifi_event_sta_connected_t)</li> <li>count (WiFiScanData)</li> <li>chip_id (lt_flash_id_t)</li> <li>chip_size_id (lt_flash_id_t)</li> <li>callback_param (lt_ota_ctx_t)</li> <li>context (wifi_event_action_tx_status_t, wifi_event_roc_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#d","title":"d","text":"<ul> <li>date (Cookie)</li> <li>domain (Cookie)</li> <li>duration (Cookie)</li> <li>data (PinInfo, SerialClass, SoftwareSerial, WiFiClass)</li> <li>dns1 (WiFiNetworkInfo)</li> <li>dns2 (WiFiNetworkInfo)</li> <li>dword (arduino::IPv6Address)</li> <li>da (wifi_event_action_tx_status_t)</li> <li>dist_est (wifi_event_ftm_report_t)</li> <li>dlog_token (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#e","title":"e","text":"<ul> <li>expires (Cookie)</li> <li>eventId (EventHandler_s)</li> <li>enabled (PinInfo)</li> <li>errArd (UpdateClass)</li> <li>errUf2 (UpdateClass)</li> <li>event_id (arduino_event_t)</li> <li>event_info (arduino_event_t)</li> <li>esp_netif (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>error (lt_ota_ctx_t)</li> <li>endsWith (mime::Entry)</li> </ul>"},{"location":"ltapi/class_member_variables/#f","title":"f","text":"<ul> <li>fcb (EventHandler_s)</li> <li>filename (HTTPUpload)</li> <li>ftm_report_data (wifi_event_ftm_report_t)</li> <li>ftm_report_num_entries (wifi_event_ftm_report_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (PinInfo)</li> <li>gateway (WiFiNetworkInfo)</li> <li>gw (esp_netif_ip_info_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#h","title":"h","text":"<ul> <li>host (Cookie)</li> <li>http_only (Cookie)</li> <li>handlers (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_variables/#i","title":"i","text":"<ul> <li>id (EventHandler_s)</li> <li>in (MD5Context)</li> <li>invert (SoftSerial)</li> <li>ip (esp_netif_ip6_info_t, esp_netif_ip_info_t, ip_event_ap_staipassigned_t)</li> <li>if_index (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>ip6_info (ip_event_got_ip6_t)</li> <li>ip_index (ip_event_got_ip6_t)</li> <li>ip_changed (ip_event_got_ip_t)</li> <li>ip_info (ip_event_got_ip_t)</li> <li>info (lt_ota_ctx_t)</li> <li>instanceName (mDNS)</li> <li>ifx (wifi_event_action_tx_status_t)</li> <li>is_mesh_child (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#k","title":"k","text":"<ul> <li>key (HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_member_variables/#l","title":"l","text":"<ul> <li>lastId (EventHandler_s)</li> <li>localIP (WiFiNetworkInfo)</li> </ul>"},{"location":"ltapi/class_member_variables/#m","title":"m","text":"<ul> <li>max_age (Cookie)</li> <li>multicast_ip (LwIPUDP)</li> <li>md5Ctx (UpdateClass)</li> <li>md5Digest (UpdateClass)</li> <li>md5Expected (UpdateClass)</li> <li>manufacturer_id (lt_flash_id_t)</li> <li>mimeType (mime::Entry)</li> <li>mac (wifi_event_ap_probe_req_rx_t, wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#n","title":"n","text":"<ul> <li>name (Cookie, HTTPUpload)</li> <li>next (cbuf)</li> <li>netmask (esp_netif_ip_info_t)</li> <li>new_mode (wifi_event_sta_authmode_change_t)</li> <li>number (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#o","title":"o","text":"<ul> <li>onReceiveCallback (HardwareI2C)</li> <li>onRequestCallback (HardwareI2C)</li> <li>old_mode (wifi_event_sta_authmode_change_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#p","title":"p","text":"<ul> <li>path (Cookie)</li> <li>pathArgs (RequestHandler)</li> <li>port (SerialClass)</li> <li>param (SoftData, SoftSerial, SoftwareSerial)</li> <li>pin (SoftData)</li> <li>password (WiFiNetworkInfo)</li> <li>passphrase (WifiAPlist_t, wifi_event_sta_wps_er_success_t)</li> <li>plainchar (base64_decodestate)</li> <li>peer_mac (wifi_event_ftm_report_t)</li> <li>pin_code (wifi_event_sta_wps_er_pin_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#r","title":"r","text":"<ul> <li>remote_ip (LwIPUDP)</li> <li>remote_port (LwIPUDP)</li> <li>rx_buffer (LwIPUDP)</li> <li>rx (SerialClass, SoftSerial)</li> <li>rssi (WiFiScanAP, wifi_event_ap_probe_req_rx_t, wifi_ftm_report_entry_t)</li> <li>running (WiFiScanData, lt_ota_ctx_t)</li> <li>result (base64_encodestate)</li> <li>rtt_est (wifi_event_ftm_report_t)</li> <li>rtt_raw (wifi_event_ftm_report_t)</li> <li>reason (wifi_event_sta_disconnected_t)</li> <li>rtt (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#s","title":"s","text":"<ul> <li>secure (Cookie)</li> <li>scb (EventHandler_s)</li> <li>status (HTTPUpload, wifi_event_action_tx_status_t, wifi_event_ftm_report_t, wifi_event_sta_scan_done_t)</li> <li>server_port (LwIPUDP)</li> <li>supported (PinInfo)</li> <li>state (SoftData, mbedtls_md5_context)</li> <li>scan (WiFiClass)</li> <li>ssid (WiFiNetworkInfo, WiFiScanAP, WifiAPlist_t, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t, wifi_event_sta_wps_er_success_t)</li> <li>ssidHidden (WiFiNetworkInfo)</li> <li>subnet (WiFiNetworkInfo)</li> <li>step (base64_decodestate, base64_encodestate)</li> <li>stepcount (base64_encodestate)</li> <li>ssid_len (wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>scan_id (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#t","title":"t","text":"<ul> <li>totalSize (HTTPUpload)</li> <li>type (HTTPUpload)</li> <li>tx_buffer (LwIPUDP)</li> <li>tx_buffer_len (LwIPUDP)</li> <li>tx (SerialClass, SoftSerial)</li> <li>timeout (WiFiScanData)</li> <li>total (mbedtls_md5_context)</li> <li>t1 (wifi_ftm_report_entry_t)</li> <li>t2 (wifi_ftm_report_entry_t)</li> <li>t3 (wifi_ftm_report_entry_t)</li> <li>t4 (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#u","title":"u","text":"<ul> <li>udp_server (LwIPUDP)</li> <li>uf2 (lt_ota_ctx_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#v","title":"v","text":"<ul> <li>valid (Cookie)</li> <li>value (Cookie, HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_member_variables/#z","title":"z","text":"<ul> <li>zone (esp_ip6_addr)</li> </ul>"},{"location":"ltapi/class_member_variables/#_","title":"_","text":"<ul> <li>_fn (FunctionRequestHandler)</li> <li>_method (FunctionRequestHandler)</li> <li>_ufn (FunctionRequestHandler)</li> <li>_uri (FunctionRequestHandler, HTTPClient, StaticRequestHandler, Uri)</li> <li>_authorizationType (HTTPClient)</li> <li>_base64Authorization (HTTPClient)</li> <li>_canReuse (HTTPClient)</li> <li>_client (HTTPClient)</li> <li>_connectTimeout (HTTPClient)</li> <li>_cookieJar (HTTPClient)</li> <li>_currentHeaders (HTTPClient, WebServer)</li> <li>_followRedirects (HTTPClient)</li> <li>_headerKeysCount (HTTPClient, WebServer)</li> <li>_headers (HTTPClient)</li> <li>_host (HTTPClient)</li> <li>_location (HTTPClient)</li> <li>_port (HTTPClient, LwIPServer)</li> <li>_protocol (HTTPClient)</li> <li>_redirectLimit (HTTPClient)</li> <li>_returnCode (HTTPClient)</li> <li>_reuse (HTTPClient)</li> <li>_secure (HTTPClient)</li> <li>_size (HTTPClient, LwIPRxBuffer, cbuf)</li> <li>_tcpDeprecated (HTTPClient)</li> <li>_tcpTimeout (HTTPClient)</li> <li>_transferEncoding (HTTPClient)</li> <li>_transportTraits (HTTPClient)</li> <li>_useHTTP10 (HTTPClient)</li> <li>_userAgent (HTTPClient)</li> <li>_freq (HardwareI2C)</li> <li>_scl (HardwareI2C)</li> <li>_sda (HardwareI2C)</li> <li>_connected (LwIPClient)</li> <li>_rxBuffer (LwIPClient)</li> <li>_sock (LwIPClient, LwIPRxBuffer, LwIPServer)</li> <li>_buffer (LwIPRxBuffer)</li> <li>_failed (LwIPRxBuffer)</li> <li>_fill (LwIPRxBuffer)</li> <li>_pos (LwIPRxBuffer)</li> <li>_active (LwIPServer)</li> <li>_addr (LwIPServer)</li> <li>_maxClients (LwIPServer)</li> <li>_noDelay (LwIPServer)</li> <li>_sockAccepted (LwIPServer)</li> <li>_alpnProtocols (MbedTLSClient)</li> <li>_caCert (MbedTLSClient)</li> <li>_caCertStr (MbedTLSClient)</li> <li>_clientCert (MbedTLSClient)</li> <li>_clientCertStr (MbedTLSClient)</li> <li>_clientKey (MbedTLSClient)</li> <li>_clientKeyStr (MbedTLSClient)</li> <li>_handshakeTimeout (MbedTLSClient)</li> <li>_insecure (MbedTLSClient)</li> <li>_peeked (MbedTLSClient)</li> <li>_pskIdentStr (MbedTLSClient)</li> <li>_pskStr (MbedTLSClient)</li> <li>_sockTls (MbedTLSClient)</li> <li>_sslCfg (MbedTLSClient)</li> <li>_sslCtx (MbedTLSClient)</li> <li>_useRootCA (MbedTLSClient)</li> <li>_next (RequestHandler)</li> <li>_baseUriLength (StaticRequestHandler)</li> <li>_cache_header (StaticRequestHandler)</li> <li>_fs (StaticRequestHandler)</li> <li>_isFile (StaticRequestHandler)</li> <li>_path (StaticRequestHandler)</li> <li>_chunked (WebServer)</li> <li>_contentLength (WebServer)</li> <li>_corsEnabled (WebServer)</li> <li>_currentArgCount (WebServer)</li> <li>_currentArgs (WebServer)</li> <li>_currentClient (WebServer)</li> <li>_currentHandler (WebServer)</li> <li>_currentMethod (WebServer)</li> <li>_currentStatus (WebServer)</li> <li>_currentUpload (WebServer)</li> <li>_currentUri (WebServer)</li> <li>_currentVersion (WebServer)</li> <li>_fileUploadHandler (WebServer)</li> <li>_firstHandler (WebServer)</li> <li>_hostHeader (WebServer)</li> <li>_lastHandler (WebServer)</li> <li>_notFoundHandler (WebServer)</li> <li>_nullDelay (WebServer)</li> <li>_postArgs (WebServer)</li> <li>_postArgsLen (WebServer)</li> <li>_responseHeaders (WebServer)</li> <li>_server (WebServer)</li> <li>_snonce (WebServer)</li> <li>_sopaque (WebServer)</li> <li>_srealm (WebServer)</li> <li>_statusChange (WebServer)</li> <li>_address (arduino::IPv6Address)</li> <li>_begin (cbuf)</li> <li>_buf (cbuf)</li> <li>_bufend (cbuf)</li> <li>_end (cbuf)</li> <li>_impl (fs::FS)</li> <li>_p (fs::File)</li> </ul>"},{"location":"ltapi/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"ltapi/class_member_typedefs/#t","title":"t","text":"<ul> <li>THandlerFunction_Progress (UpdateClass)</li> <li>THandlerFunction (WebServer)</li> </ul>"},{"location":"ltapi/class_member_enums/","title":"Class Member Enums","text":""},{"location":"ltapi/namespace_members/","title":"Namespace Members","text":""},{"location":"ltapi/namespace_members/#f","title":"f","text":"<ul> <li>FSImplPtr (fs)</li> <li>FileImplPtr (fs)</li> </ul>"},{"location":"ltapi/namespace_members/#m","title":"m","text":"<ul> <li>mimeTable (mime)</li> </ul>"},{"location":"ltapi/namespace_members/#s","title":"s","text":"<ul> <li>SeekMode (fs)</li> </ul>"},{"location":"ltapi/namespace_members/#t","title":"t","text":"<ul> <li>type (mime)</li> </ul>"},{"location":"ltapi/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"ltapi/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"ltapi/namespace_member_variables/#m","title":"m","text":"<ul> <li>mimeTable (mime)</li> </ul>"},{"location":"ltapi/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"ltapi/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>FSImplPtr (fs)</li> <li>FileImplPtr (fs)</li> </ul>"},{"location":"ltapi/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"ltapi/namespace_member_enums/#s","title":"s","text":"<ul> <li>SeekMode (fs)</li> </ul>"},{"location":"ltapi/namespace_member_enums/#t","title":"t","text":"<ul> <li>type (mime)</li> </ul>"},{"location":"ltapi/functions/","title":"Functions","text":""},{"location":"ltapi/functions/#a","title":"a","text":"<ul> <li>analogRead (wiring_custom.c, wiring_custom.h)</li> <li>analogReadResolution (wiring_custom.c, wiring_custom.h)</li> <li>analogWriteFrequency (wiring_custom.c, wiring_custom.h)</li> <li>analogWritePeriod (wiring_custom.c, wiring_custom.h)</li> <li>analogWriteResolution (wiring_custom.c, wiring_custom.h)</li> <li>analogReadMaxVoltage (wiring_custom.h)</li> <li>analogReadVoltage (wiring_custom.h)</li> <li>attachInterrupt (wiring_irq.c)</li> </ul>"},{"location":"ltapi/functions/#b","title":"b","text":"<ul> <li>base64_decode_block (cdecode.c, cdecode.h)</li> <li>base64_decode_block_signed (cdecode.c)</li> <li>base64_decode_chars (cdecode.c, cdecode.h)</li> <li>base64_decode_chars_signed (cdecode.c)</li> <li>base64_decode_value (cdecode.c, cdecode.h)</li> <li>base64_decode_value_signed (cdecode.c)</li> <li>base64_init_decodestate (cdecode.c, cdecode.h)</li> <li>base64_encode_block (cencode.c, cencode.h)</li> <li>base64_encode_blockend (cencode.c, cencode.h)</li> <li>base64_encode_chars (cencode.c, cencode.h)</li> <li>base64_encode_value (cencode.c, cencode.h)</li> <li>base64_init_encodestate (cencode.c, cencode.h)</li> </ul>"},{"location":"ltapi/functions/#d","title":"d","text":"<ul> <li>dtostrf (dtostrf.c)</li> </ul>"},{"location":"ltapi/functions/#e","title":"e","text":"<ul> <li>ensureUnderscore (mDNS.cpp)</li> </ul>"},{"location":"ltapi/functions/#f","title":"f","text":"<ul> <li>freeIfCopied (mDNS.cpp)</li> </ul>"},{"location":"ltapi/functions/#g","title":"g","text":"<ul> <li>gettimeofday (time.c)</li> </ul>"},{"location":"ltapi/functions/#h","title":"h","text":"<ul> <li>hexdump (lt_utils.c, lt_utils.h)</li> </ul>"},{"location":"ltapi/functions/#i","title":"i","text":"<ul> <li>ipToString (wiring_compat.cpp, wiring_compat.h)</li> <li>itoa (itoa.c)</li> </ul>"},{"location":"ltapi/functions/#l","title":"l","text":"<ul> <li>lt_cpu_get_family (lt_cpu.c, lt_cpu.h)</li> <li>lt_cpu_get_family_name (lt_cpu.c, lt_cpu.h)</li> <li>lt_cpu_get_freq_mhz (lt_cpu.c, lt_cpu.h)</li> <li>lt_cpu_get_model_code (lt_cpu.c, lt_cpu.h)</li> <li>lt_cpu_get_model_name (lt_cpu.c, lt_cpu.h)</li> <li>lt_cpu_get_core_count (lt_cpu.h)</li> <li>lt_cpu_get_core_type (lt_cpu.h)</li> <li>lt_cpu_get_cycle_count (lt_cpu.h)</li> <li>lt_cpu_get_freq (lt_cpu.h)</li> <li>lt_cpu_get_mac_id (lt_cpu.h)</li> <li>lt_cpu_get_model (lt_cpu.h)</li> <li>lt_cpu_get_unique_id (lt_cpu.h)</li> <li>lt_get_board_code (lt_device.c, lt_device.h)</li> <li>lt_get_device_name (lt_device.c, lt_device.h)</li> <li>lt_get_reboot_reason_name (lt_device.c, lt_device.h)</li> <li>lt_get_version (lt_device.c, lt_device.h)</li> <li>lt_get_device_mac (lt_device.h)</li> <li>lt_get_reboot_reason (lt_device.h)</li> <li>lt_gpio_recover (lt_device.h)</li> <li>lt_reboot (lt_device.h)</li> <li>lt_reboot_download_mode (lt_device.h)</li> <li>lt_reboot_wdt (lt_device.h)</li> <li>lt_set_debug_mode (lt_device.h)</li> <li>lt_flash_erase (lt_flash.c, lt_flash.h)</li> <li>lt_flash_erase_block (lt_flash.c, lt_flash.h)</li> <li>lt_flash_read (lt_flash.c, lt_flash.h)</li> <li>lt_flash_write (lt_flash.c, lt_flash.h)</li> <li>lt_flash_get_id (lt_flash.h)</li> <li>lt_flash_get_size (lt_flash.h)</li> <li>lt_init_arduino (lt_init.h)</li> <li>lt_init_family (lt_init.h)</li> <li>lt_init_variant (lt_init.h)</li> <li>lt_heap_get_free (lt_mem.h)</li> <li>lt_heap_get_max_alloc (lt_mem.h)</li> <li>lt_heap_get_min_free (lt_mem.h)</li> <li>lt_heap_get_size (lt_mem.h)</li> <li>lt_ram_get_size (lt_mem.h)</li> <li>lt_ota_begin (lt_ota.c, lt_ota.h)</li> <li>lt_ota_buf_left (lt_ota.c)</li> <li>lt_ota_buf_size (lt_ota.c)</li> <li>lt_ota_can_rollback (lt_ota.c, lt_ota.h)</li> <li>lt_ota_end (lt_ota.c, lt_ota.h)</li> <li>lt_ota_get_uf2_scheme (lt_ota.c, lt_ota.h)</li> <li>lt_ota_write (lt_ota.c, lt_ota.h)</li> <li>lt_ota_write_block (lt_ota.c, lt_ota.h)</li> <li>lt_ota_dual_get_current (lt_ota.h)</li> <li>lt_ota_dual_get_stored (lt_ota.h)</li> <li>lt_ota_get_type (lt_ota.h)</li> <li>lt_ota_is_valid (lt_ota.h)</li> <li>lt_ota_set_write_protect (lt_ota.h)</li> <li>lt_ota_switch (lt_ota.h)</li> <li>lt_deep_sleep_config_gpio (lt_sleep.h)</li> <li>lt_deep_sleep_config_timer (lt_sleep.h)</li> <li>lt_deep_sleep_enter (lt_sleep.h)</li> <li>lt_deep_sleep_keep_floating_gpio (lt_sleep.h)</li> <li>lt_deep_sleep_unset_gpio (lt_sleep.h)</li> <li>lt_btox (lt_utils.c, lt_utils.h)</li> <li>lt_rand_bytes (lt_utils.c, lt_utils.h)</li> <li>lt_xtob (lt_utils.c, lt_utils.h)</li> <li>lt_wdt_disable (lt_wdt.h)</li> <li>lt_wdt_enable (lt_wdt.h)</li> <li>lt_wdt_feed (lt_wdt.h)</li> <li>ltoa (itoa.c)</li> <li>lt_log (lt_logger.c, lt_logger.h)</li> <li>lt_log_disable (lt_logger.c, lt_logger.h)</li> <li>lt_log_set_port (lt_logger.c, lt_logger.h)</li> <li>lt_main (lt_main.c)</li> </ul>"},{"location":"ltapi/functions/#m","title":"m","text":"<ul> <li>MD5Final (MD5.h)</li> <li>MD5Init (MD5.h)</li> <li>MD5Update (MD5.h)</li> <li>mainTask (wiring_custom.h, main.c)</li> <li>main (main.c, lt_main.c)</li> </ul>"},{"location":"ltapi/functions/#p","title":"p","text":"<ul> <li>pinByGpio (wiring_custom.c, wiring_custom.h)</li> <li>pinByIndex (wiring_custom.c, wiring_custom.h)</li> <li>pinEnabled (wiring_custom.c, wiring_custom.h)</li> <li>pinIndex (wiring_custom.c, wiring_custom.h)</li> <li>pinInfo (wiring_custom.c, wiring_custom.h)</li> <li>pinModeRemove (wiring_custom.c, wiring_custom.h)</li> <li>pinSupported (wiring_custom.c, wiring_custom.h)</li> <li>pinModeNone (wiring_custom.h)</li> <li>pinRemoveMode (wiring_custom.h)</li> <li>pinData (wiring_private.h)</li> <li>pinDisable (wiring_private.h)</li> <li>pinEnable (wiring_private.h)</li> <li>pinRemoveData (wiring_private.h)</li> <li>printf_nop (fal_cfg.h)</li> <li>putchar_p (printf_config.h)</li> </ul>"},{"location":"ltapi/functions/#r","title":"r","text":"<ul> <li>runPeriodicTasks (wiring_custom.c, wiring_custom.h)</li> <li>random (wiring_math.cpp)</li> <li>randomSeed (wiring_math.cpp)</li> </ul>"},{"location":"ltapi/functions/#s","title":"s","text":"<ul> <li>Serial_available (serial_event.cpp)</li> <li>serialEvent (serial_event.cpp)</li> <li>serialEventRun (serial_event.cpp)</li> <li>settimeofday (time.c)</li> <li>startMainTask (wiring_custom.h)</li> <li>shiftIn (wiring_shift.c)</li> <li>shiftOut (wiring_shift.c)</li> <li>strcasecmp (strcasecmp.c, lt_posix_api.h)</li> <li>strncasecmp (strcasecmp.c, lt_posix_api.h)</li> <li>strptime (strptime.c, lt_posix_api.h)</li> <li>strdup (lt_posix_api.h)</li> </ul>"},{"location":"ltapi/functions/#u","title":"u","text":"<ul> <li>ultoa (itoa.c)</li> <li>utoa (itoa.c)</li> </ul>"},{"location":"ltapi/functions/#_","title":"_","text":"<ul> <li>__attribute__ (WiFi.cpp, WiFiAP.cpp, WiFiGeneric.cpp, WiFiSTA.cpp, wiring.c, wiring_custom.c, lt_cpu.c, lt_device.c, lt_flash.c, lt_mem.c, lt_ota.c, lt_wdt.c, strdup.c)</li> <li>__cxa_deleted_virtual (abi.cpp)</li> <li>__cxa_pure_virtual (abi.cpp)</li> <li>__wrap_gettimeofday (time.c)</li> <li>__wrap_settimeofday (time.c)</li> <li>_gettimeofday (time.c)</li> <li>_settimeofday (time.c)</li> <li>__wrap_zalloc (malloc.c)</li> <li>__wrap_putchar (putchar.c)</li> <li>__wrap_puts (puts.c)</li> <li>__libc_init_array (lt_main.c)</li> </ul>"},{"location":"ltapi/macros/","title":"Macros","text":""},{"location":"ltapi/macros/#a","title":"a","text":"<ul> <li>attachInterruptArg (wiring_compat.h)</li> </ul>"},{"location":"ltapi/macros/#b","title":"b","text":"<ul> <li>base64_decode_expected_len (cdecode.h)</li> <li>base64_encode_expected_len (cencode.h)</li> </ul>"},{"location":"ltapi/macros/#c","title":"c","text":"<ul> <li>CONTENT_LENGTH_NOT_SET (WebServer.h)</li> <li>CONTENT_LENGTH_UNKNOWN (WebServer.h)</li> <li>ChipFamily (LT.h)</li> <li>ChipType (LT.h)</li> <li>CONFIG_LWIP_MAX_ACTIVE_TCP (wiring_compat.h)</li> <li>COLOR_BLACK (lt_logger.c)</li> <li>COLOR_BLUE (lt_logger.c)</li> <li>COLOR_BRIGHT_BLACK (lt_logger.c)</li> <li>COLOR_BRIGHT_BLUE (lt_logger.c)</li> <li>COLOR_BRIGHT_CYAN (lt_logger.c)</li> <li>COLOR_BRIGHT_GREEN (lt_logger.c)</li> <li>COLOR_BRIGHT_MAGENTA (lt_logger.c)</li> <li>COLOR_BRIGHT_RED (lt_logger.c)</li> <li>COLOR_BRIGHT_WHITE (lt_logger.c)</li> <li>COLOR_BRIGHT_YELLOW (lt_logger.c)</li> <li>COLOR_CYAN (lt_logger.c)</li> <li>COLOR_FMT (lt_logger.c)</li> <li>COLOR_GREEN (lt_logger.c)</li> <li>COLOR_MAGENTA (lt_logger.c)</li> <li>COLOR_RED (lt_logger.c)</li> <li>COLOR_WHITE (lt_logger.c)</li> <li>COLOR_YELLOW (lt_logger.c)</li> <li>CPU_MODEL (lt_types.h)</li> <li>CPU_MODEL_ENUM (lt_types.h)</li> </ul>"},{"location":"ltapi/macros/#d","title":"d","text":"<ul> <li>digitalPinToInterrupt (wiring_compat.h)</li> </ul>"},{"location":"ltapi/macros/#e","title":"e","text":"<ul> <li>ENCRYPTED_BLOCK_SIZE (Update.h)</li> <li>EventId (Events.h)</li> <li>EventId_t (Events.h)</li> <li>EventInfo (Events.h)</li> <li>EventInfo_t (Events.h)</li> <li>Event_t (Events.h)</li> <li>ESP_FAIL (wiring_compat.h)</li> <li>ESP_OK (wiring_compat.h)</li> <li>esp_err_t (wiring_compat.h)</li> <li>errno (errno.h)</li> <li>ESP_EARLY_LOGD (lt_logger.h)</li> <li>ESP_EARLY_LOGE (lt_logger.h)</li> <li>ESP_EARLY_LOGI (lt_logger.h)</li> <li>ESP_EARLY_LOGV (lt_logger.h)</li> <li>ESP_EARLY_LOGW (lt_logger.h)</li> <li>ESP_LOGD (lt_logger.h)</li> <li>ESP_LOGE (lt_logger.h)</li> <li>ESP_LOGI (lt_logger.h)</li> <li>ESP_LOGV (lt_logger.h)</li> <li>ESP_LOGW (lt_logger.h)</li> <li>ETS_PRINTF (lt_logger.h)</li> <li>ets_printf (lt_logger.h)</li> </ul>"},{"location":"ltapi/macros/#f","title":"f","text":"<ul> <li>FILE_APPEND (FS.h)</li> <li>FILE_READ (FS.h)</li> <li>FILE_WRITE (FS.h)</li> <li>FlashId (LT.h)</li> <li>FPSTR (wiring_compat.h)</li> <li>FAL_DEBUG (fal_cfg.h)</li> <li>FAL_DEV_NAME_MAX (fal_cfg.h)</li> <li>FAL_FLASH_DEV_NAME (fal_cfg.h)</li> <li>FAL_FLASH_DEV_TABLE (fal_cfg.h)</li> <li>FAL_PART_HAS_TABLE_CFG (fal_cfg.h)</li> <li>FAL_PART_TABLE_ITEM (fal_cfg.h)</li> <li>FAL_PRINTF (fal_cfg.h)</li> <li>FDB_PRINT (fdb_cfg.h)</li> <li>FDB_USING_FAL_MODE (fdb_cfg.h)</li> <li>FDB_USING_KVDB (fdb_cfg.h)</li> <li>FDB_WRITE_GRAN (fdb_cfg.h)</li> </ul>"},{"location":"ltapi/macros/#g","title":"g","text":"<ul> <li>GCC_VERSION_STR (libretiny.h)</li> </ul>"},{"location":"ltapi/macros/#h","title":"h","text":"<ul> <li>HAS_SERIAL_CLASS (Serial.h)</li> <li>HTTPCLIENT_1_1_COMPATIBLE (HTTPClient.h)</li> <li>HTTPCLIENT_DEFAULT_TCP_TIMEOUT (HTTPClient.h)</li> <li>HTTPC_ERROR_CONNECTION_LOST (HTTPClient.h)</li> <li>HTTPC_ERROR_CONNECTION_REFUSED (HTTPClient.h)</li> <li>HTTPC_ERROR_ENCODING (HTTPClient.h)</li> <li>HTTPC_ERROR_NOT_CONNECTED (HTTPClient.h)</li> <li>HTTPC_ERROR_NO_HTTP_SERVER (HTTPClient.h)</li> <li>HTTPC_ERROR_NO_STREAM (HTTPClient.h)</li> <li>HTTPC_ERROR_READ_TIMEOUT (HTTPClient.h)</li> <li>HTTPC_ERROR_SEND_HEADER_FAILED (HTTPClient.h)</li> <li>HTTPC_ERROR_SEND_PAYLOAD_FAILED (HTTPClient.h)</li> <li>HTTPC_ERROR_STREAM_WRITE (HTTPClient.h)</li> <li>HTTPC_ERROR_TOO_LESS_RAM (HTTPClient.h)</li> <li>HTTP_TCP_BUFFER_SIZE (HTTPClient.h)</li> <li>HTTP_ANY (HTTP_Method.h)</li> <li>HTTP_METHOD_MAP (HTTP_Method.h)</li> <li>HTTP_DOWNLOAD_UNIT_SIZE (WebServer.h)</li> <li>HTTP_MAX_CLOSE_WAIT (WebServer.h)</li> <li>HTTP_MAX_DATA_WAIT (WebServer.h)</li> <li>HTTP_MAX_POST_WAIT (WebServer.h)</li> <li>HTTP_MAX_SEND_WAIT (WebServer.h)</li> <li>HTTP_UPLOAD_BUFLEN (WebServer.h)</li> </ul>"},{"location":"ltapi/macros/#i","title":"i","text":"<ul> <li>isr_log_d (lt_logger.h)</li> <li>isr_log_e (lt_logger.h)</li> <li>isr_log_i (lt_logger.h)</li> <li>isr_log_n (lt_logger.h)</li> <li>isr_log_v (lt_logger.h)</li> <li>isr_log_w (lt_logger.h)</li> </ul>"},{"location":"ltapi/macros/#l","title":"l","text":"<ul> <li>LT_MD5_CTX_T (MD5.h, MD5HostapdImpl.h, MD5MbedTLSImpl.h)</li> <li>lwip_ntohl (udp.h)</li> <li>LWIP_MDNS_RESPONDER (lwipopts.h)</li> <li>LWIP_NETIF_HOSTNAME (lwipopts.h)</li> <li>LWIP_SO_RCVBUF (lwipopts.h)</li> <li>LWIP_TIMEVAL_PRIVATE (lwipopts.h)</li> <li>LWIP_VERSION_SIMPLE (lwipopts.h)</li> <li>LT_BANNER (libretiny.h)</li> <li>LT_BANNER_STR (libretiny.h)</li> <li>LT_BOARD (libretiny.h)</li> <li>LT_BOARD_STR (libretiny.h)</li> <li>LT_VERSION (libretiny.h)</li> <li>LT_VERSION_STR (libretiny.h)</li> <li>LT_AUTO_DOWNLOAD_REBOOT (lt_config.h)</li> <li>LT_DEBUG_ALL (lt_config.h)</li> <li>LT_DEBUG_CLIENT (lt_config.h)</li> <li>LT_DEBUG_FDB (lt_config.h)</li> <li>LT_DEBUG_LWIP (lt_config.h)</li> <li>LT_DEBUG_LWIP_ASSERT (lt_config.h)</li> <li>LT_DEBUG_MDNS (lt_config.h)</li> <li>LT_DEBUG_OTA (lt_config.h)</li> <li>LT_DEBUG_SERVER (lt_config.h)</li> <li>LT_DEBUG_SSL (lt_config.h)</li> <li>LT_DEBUG_WIFI (lt_config.h)</li> <li>LT_LEVEL_DEBUG (lt_config.h)</li> <li>LT_LEVEL_ERROR (lt_config.h)</li> <li>LT_LEVEL_FATAL (lt_config.h)</li> <li>LT_LEVEL_INFO (lt_config.h)</li> <li>LT_LEVEL_NONE (lt_config.h)</li> <li>LT_LEVEL_TRACE (lt_config.h)</li> <li>LT_LEVEL_VERBOSE (lt_config.h)</li> <li>LT_LEVEL_WARN (lt_config.h)</li> <li>LT_LOGGER (lt_config.h)</li> <li>LT_LOGGER_CALLER (lt_config.h)</li> <li>LT_LOGGER_COLOR (lt_config.h)</li> <li>LT_LOGGER_TASK (lt_config.h)</li> <li>LT_LOGGER_TIMESTAMP (lt_config.h)</li> <li>LT_LOGLEVEL (lt_config.h)</li> <li>LT_LOG_ERRNO (lt_config.h)</li> <li>LT_LOG_HEAP (lt_config.h)</li> <li>LT_MICROS_HIGH_RES (lt_config.h)</li> <li>LT_PRINTF_BROKEN (lt_config.h)</li> <li>LT_SERIAL_BUFFER_SIZE (lt_config.h)</li> <li>LT_UART_DEFAULT_LOGGER (lt_config.h)</li> <li>LT_UART_DEFAULT_SERIAL (lt_config.h)</li> <li>LT_UART_SILENT_ALL (lt_config.h)</li> <li>LT_UART_SILENT_ENABLED (lt_config.h)</li> <li>LT_USE_TIME (lt_config.h)</li> <li>LT_D (lt_logger.h)</li> <li>LT_DM (lt_logger.h)</li> <li>LT_E (lt_logger.h)</li> <li>LT_EM (lt_logger.h)</li> <li>LT_ERRNO (lt_logger.h)</li> <li>LT_ERRNO_LEZ (lt_logger.h)</li> <li>LT_ERRNO_LZ (lt_logger.h)</li> <li>LT_ERRNO_NZ (lt_logger.h)</li> <li>LT_F (lt_logger.h)</li> <li>LT_FM (lt_logger.h)</li> <li>LT_HEAP_I (lt_logger.h)</li> <li>LT_I (lt_logger.h)</li> <li>LT_IM (lt_logger.h)</li> <li>LT_LOG (lt_logger.h)</li> <li>LT_LOGM (lt_logger.h)</li> <li>LT_RET (lt_logger.h)</li> <li>LT_RET_LEZ (lt_logger.h)</li> <li>LT_RET_LZ (lt_logger.h)</li> <li>LT_RET_NZ (lt_logger.h)</li> <li>LT_T (lt_logger.h)</li> <li>LT_TM (lt_logger.h)</li> <li>LT_V (lt_logger.h)</li> <li>LT_VM (lt_logger.h)</li> <li>LT_W (lt_logger.h)</li> <li>LT_WM (lt_logger.h)</li> <li>log_d (lt_logger.h)</li> <li>log_e (lt_logger.h)</li> <li>log_i (lt_logger.h)</li> <li>log_n (lt_logger.h)</li> <li>log_printf (lt_logger.h)</li> <li>log_v (lt_logger.h)</li> <li>log_w (lt_logger.h)</li> <li>LT_HW_I2C0 (lt_pins.h)</li> <li>LT_HW_I2C1 (lt_pins.h)</li> <li>LT_HW_I2C2 (lt_pins.h)</li> <li>LT_HW_SPI0 (lt_pins.h)</li> <li>LT_HW_SPI1 (lt_pins.h)</li> <li>LT_HW_SPI2 (lt_pins.h)</li> <li>LT_HW_UART0 (lt_pins.h)</li> <li>LT_HW_UART1 (lt_pins.h)</li> <li>LT_HW_UART2 (lt_pins.h)</li> </ul>"},{"location":"ltapi/macros/#m","title":"m","text":"<ul> <li>MAX_PASSPHRASE_LEN (WiFiEvents.h)</li> <li>MAX_SSID_LEN (WiFiEvents.h)</li> <li>MAX_WPS_AP_CRED (WiFiEvents.h)</li> <li>MDNS_TCP (mDNS.h)</li> <li>MDNS_UDP (mDNS.h)</li> <li>MAX (lt_utils.h)</li> <li>MIN (lt_utils.h)</li> <li>MDNS_MAX_SERVICES (lwipopts.h)</li> </ul>"},{"location":"ltapi/macros/#o","title":"o","text":"<ul> <li>OUTPUT_OPEN_DRAIN (wiring_compat.h)</li> </ul>"},{"location":"ltapi/macros/#p","title":"p","text":"<ul> <li>PGM_VOID_P (wiring_compat.h)</li> <li>PIN_ADC (wiring_custom.h)</li> <li>PIN_DAC (wiring_custom.h)</li> <li>PIN_GPIO (wiring_custom.h)</li> <li>PIN_I2C (wiring_custom.h)</li> <li>PIN_I2S (wiring_custom.h)</li> <li>PIN_IRQ (wiring_custom.h)</li> <li>PIN_JTAG (wiring_custom.h)</li> <li>PIN_MODE_ALL (wiring_custom.h)</li> <li>PIN_NONE (wiring_custom.h)</li> <li>PIN_PWM (wiring_custom.h)</li> <li>PIN_SPI (wiring_custom.h)</li> <li>PIN_SWD (wiring_custom.h)</li> <li>PIN_UART (wiring_custom.h)</li> <li>pinCheckGetData (wiring_private.h)</li> <li>pinCheckGetInfo (wiring_private.h)</li> <li>pinIsInput (wiring_private.h)</li> <li>pinIsOutput (wiring_private.h)</li> <li>pinSetInputMode (wiring_private.h)</li> <li>pinSetOutputPull (wiring_private.h)</li> <li>PRINTF_HAS_DISABLE (printf_config.h)</li> <li>printf_ (printf_config.h)</li> <li>PIN_INVALID (lt_pins.h)</li> </ul>"},{"location":"ltapi/macros/#r","title":"r","text":"<ul> <li>ResetReason (LT.h)</li> <li>REBOOT_REASON_SLEEP (lt_device.h)</li> <li>RESET_REASON_BROWNOUT (lt_device.h)</li> <li>RESET_REASON_CRASH (lt_device.h)</li> <li>RESET_REASON_HARDWARE (lt_device.h)</li> <li>RESET_REASON_MAX (lt_device.h)</li> <li>RESET_REASON_POWER (lt_device.h)</li> <li>RESET_REASON_SLEEP (lt_device.h)</li> <li>RESET_REASON_SLEEP_GPIO (lt_device.h)</li> <li>RESET_REASON_SLEEP_RTC (lt_device.h)</li> <li>RESET_REASON_SLEEP_USB (lt_device.h)</li> <li>RESET_REASON_SOFTWARE (lt_device.h)</li> <li>RESET_REASON_UNKNOWN (lt_device.h)</li> <li>RESET_REASON_WATCHDOG (lt_device.h)</li> </ul>"},{"location":"ltapi/macros/#s","title":"s","text":"<ul> <li>SNTP_GET_SYSTEM_TIME (lwipopts.h)</li> <li>SNTP_SERVER_DNS (lwipopts.h)</li> <li>SNTP_SET_SYSTEM_TIME_US (lwipopts.h)</li> <li>snprintf_ (printf_config.h)</li> <li>sprintf_ (printf_config.h)</li> <li>STRINGIFY (libretiny.h)</li> <li>STRINGIFY_MACRO (libretiny.h)</li> </ul>"},{"location":"ltapi/macros/#u","title":"u","text":"<ul> <li>UPDATE_SIZE_UNKNOWN (Update.h)</li> <li>UPDATE_TIMEOUT_MS (Update.h)</li> </ul>"},{"location":"ltapi/macros/#v","title":"v","text":"<ul> <li>voidFuncPtrArg (wiring_compat.h)</li> <li>vsnprintf_P (wiring_compat.h)</li> <li>vprintf_ (printf_config.h)</li> <li>vsnprintf_ (printf_config.h)</li> <li>vsprintf_ (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#w","title":"w","text":"<ul> <li>WIFI_STATIS_ALL (WiFiEvents.h)</li> <li>WIFI_STATIS_BUFFER (WiFiEvents.h)</li> <li>WIFI_STATIS_DIAG (WiFiEvents.h)</li> <li>WIFI_STATIS_HW (WiFiEvents.h)</li> <li>WIFI_STATIS_PS (WiFiEvents.h)</li> <li>WIFI_STATIS_RXTX (WiFiEvents.h)</li> <li>WIFI_AP (WiFiType.h)</li> <li>WIFI_AP_STA (WiFiType.h)</li> <li>WIFI_OFF (WiFiType.h)</li> <li>WIFI_SCAN_FAILED (WiFiType.h)</li> <li>WIFI_SCAN_RUNNING (WiFiType.h)</li> <li>WIFI_STA (WiFiType.h)</li> <li>WiFiAuthMode (WiFiType.h)</li> <li>WiFiEventId_t (WiFiType.h)</li> <li>WiFiEventInfo_t (WiFiType.h)</li> <li>WiFiEvent_t (WiFiType.h)</li> <li>WiFiMode (WiFiType.h)</li> <li>WiFiMode_t (WiFiType.h)</li> <li>WiFiStatus (WiFiType.h)</li> <li>WRAP_DISABLE_CHECK (printf_config.h)</li> <li>WRAP_DISABLE_DECL (printf_config.h)</li> <li>WRAP_DISABLE_DEF (printf_config.h)</li> <li>WRAP_PRINTF (printf_config.h)</li> <li>WRAP_SNPRINTF (printf_config.h)</li> <li>WRAP_SPRINTF (printf_config.h)</li> <li>WRAP_VPRINTF (printf_config.h)</li> <li>WRAP_VSNPRINTF (printf_config.h)</li> <li>WRAP_VSPRINTF (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#x","title":"x","text":"<ul> <li>XX (HTTP_Method.h)</li> <li>xTaskCreatePinnedToCore (wiring_compat.h)</li> <li>xTaskCreateUniversal (wiring_compat.h)</li> </ul>"},{"location":"ltapi/variables/","title":"Variables","text":""},{"location":"ltapi/variables/#a","title":"a","text":"<ul> <li>arduino_event_id_t (Events.h)</li> </ul>"},{"location":"ltapi/variables/#b","title":"b","text":"<ul> <li>base64_decodestep (cdecode.h)</li> <li>base64_encodestep (cencode.h)</li> </ul>"},{"location":"ltapi/variables/#c","title":"c","text":"<ul> <li>CookieJar (HTTPClient.h)</li> <li>charmap (strcasecmp.c)</li> </ul>"},{"location":"ltapi/variables/#d","title":"d","text":"<ul> <li>device_name (lt_device.c)</li> </ul>"},{"location":"ltapi/variables/#e","title":"e","text":"<ul> <li>esp_ip4_addr_t (WiFiType.h)</li> <li>esp_ip6_addr_t (WiFiType.h)</li> <li>errorMap (Update.cpp)</li> <li>errArdText (UpdateUtil.cpp)</li> <li>errUf2Text (UpdateUtil.cpp)</li> <li>errorStr (UpdateUtil.cpp)</li> <li>ESP (Singletons.cpp, ESP.h)</li> <li>EventCb (Events.h)</li> <li>EventFuncCb (Events.h)</li> <li>EventHandler (Events.h)</li> <li>EventSysCb (Events.h)</li> <li>emptyString (wiring_compat.cpp, wiring_compat.h)</li> <li>errno (errno.h)</li> </ul>"},{"location":"ltapi/variables/#f","title":"f","text":"<ul> <li>followRedirects_t (HTTPClient.h)</li> <li>Flash (Singletons.cpp, Flash.h)</li> <li>fal_root_part (fal_cfg.h, lt_main.c)</li> <li>flash0 (fal_cfg.h)</li> </ul>"},{"location":"ltapi/variables/#h","title":"h","text":"<ul> <li>HTTPMethod (HTTP_Method.h)</li> <li>http_method (HTTP_Method.h)</li> <li>HTTPAuthMethod (WebServer.h)</li> <li>HTTPClientStatus (WebServer.h)</li> <li>HTTPUploadStatus (WebServer.h)</li> </ul>"},{"location":"ltapi/variables/#l","title":"l","text":"<ul> <li>LT (Singletons.cpp, LT.h)</li> <li>lt_arduino_pin_gpio_map (wiring_custom.h)</li> <li>lt_arduino_pin_info_list (wiring_custom.h)</li> <li>lt_debug_mode_t (lt_device.h)</li> <li>lt_reboot_reason_t (lt_device.h)</li> <li>lt_ota_type_t (lt_ota.h)</li> <li>levels (lt_logger.c)</li> <li>lt_cpu_family_t (lt_types.h)</li> <li>lt_cpu_model_t (lt_types.h)</li> </ul>"},{"location":"ltapi/variables/#m","title":"m","text":"<ul> <li>md5_context_t (MD5.h)</li> <li>MDNS (mDNS.h)</li> <li>MDNSResponder (mDNS.h)</li> </ul>"},{"location":"ltapi/variables/#o","title":"o","text":"<ul> <li>OTA (Singletons.cpp, OTA.h)</li> </ul>"},{"location":"ltapi/variables/#p","title":"p","text":"<ul> <li>pWiFi (WiFi.cpp, WiFi.h)</li> <li>PreferenceType (Preferences.h)</li> <li>periodicTasks (wiring_custom.c)</li> <li>PinData (wiring_custom.h)</li> </ul>"},{"location":"ltapi/variables/#r","title":"r","text":"<ul> <li>reset_epoch (time.c)</li> <li>reset_millis (time.c)</li> </ul>"},{"location":"ltapi/variables/#s","title":"s","text":"<ul> <li>SerialRingBuffer (Serial.h)</li> <li>SoftState (SoftwareSerial.h)</li> </ul>"},{"location":"ltapi/variables/#t","title":"t","text":"<ul> <li>TransportTraitsPtr (HTTPClient.h)</li> <li>t_http_codes (HTTPClient.h)</li> <li>transferEncoding_t (HTTPClient.h)</li> </ul>"},{"location":"ltapi/variables/#u","title":"u","text":"<ul> <li>Update (Update.cpp, Update.h)</li> <li>UpdateCommand (Update.h)</li> <li>UpdateError (Update.h)</li> <li>u_char (strcasecmp.c)</li> <li>uart_port (lt_logger.c)</li> </ul>"},{"location":"ltapi/variables/#w","title":"w","text":"<ul> <li>WiFi (WiFi.cpp, WiFi.h)</li> <li>wifi_event_sta_wps_fail_reason_t (WiFiEvents.h)</li> <li>wifi_ftm_status_t (WiFiEvents.h)</li> <li>WiFiAuthModeText (WiFiType.h)</li> <li>WiFiModeAction (WiFiType.h)</li> <li>WiFiModeText (WiFiType.h)</li> <li>WiFiStatusText (WiFiType.h)</li> <li>wifi_auth_mode_t (WiFiType.h)</li> <li>wifi_err_reason_t (WiFiType.h)</li> <li>wifi_mode_t (WiFiType.h)</li> <li>wl_status_t (WiFiType.h)</li> <li>WiFiClient (LwIPClient.h)</li> <li>WiFiClientSecure (MbedTLSClient.h)</li> <li>WiFiServer (LwIPServer.h)</li> <li>WiFiUDP (LwIPUdp.h)</li> <li>WDT (Singletons.cpp, WDT.h)</li> </ul>"},{"location":"ltapi/variables/#_","title":"_","text":"<ul> <li>_analogReadResolution (wiring_custom.c, wiring_custom.h)</li> <li>_analogWritePeriod (wiring_custom.c, wiring_custom.h)</li> <li>_analogWriteResolution (wiring_custom.c, wiring_custom.h)</li> </ul>"},{"location":"ltapi/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List<ul> <li>struct Cookie</li> <li>class EspClass</li> <li>struct EventHandler_s</li> <li>class FlashClass</li> <li>class FunctionRequestHandler</li> <li>class HTTPClient</li> <li>struct HTTPClient::RequestArgument</li> <li>struct HTTPUpload</li> <li>class HardwareI2C</li> <li>class IPreferences</li> <li>class IWiFiClient</li> <li>class IWiFiClientSecure</li> <li>class IWiFiServer</li> <li>class IWiFiUDP</li> <li>class LibreTiny</li> <li>class LibreTinyOTA</li> <li>class LibreTinyWDT</li> <li>class LwIPClient</li> <li>class LwIPRxBuffer</li> <li>class LwIPServer</li> <li>class LwIPUDP</li> <li>struct MD5Context</li> <li>class MbedTLSClient</li> <li>struct PinInfo</li> <li>class RequestHandler</li> <li>class SerialClass</li> <li>struct SoftData</li> <li>struct SoftSerial</li> <li>class SoftwareSerial</li> <li>class StaticRequestHandler</li> <li>class StreamString</li> <li>class UpdateClass</li> <li>class Uri</li> <li>class UriBraces</li> <li>class UriGlob</li> <li>class UriRegex</li> <li>class WebServer</li> <li>struct WebServer::RequestArgument</li> <li>class WiFiClass</li> <li>struct WiFiMacAddr</li> <li>class WiFiMulti</li> <li>struct WiFiNetworkInfo</li> <li>struct WiFiScanAP</li> <li>struct WiFiScanData</li> <li>struct WifiAPlist_t</li> <li>namespace arduino</li> <li>class arduino::IPv6Address</li> <li>union arduino_event_info_t</li> <li>struct arduino_event_t</li> <li>class base64</li> <li>struct base64_decodestate</li> <li>struct base64_encodestate</li> <li>class cbuf</li> <li>struct esp_ip4_addr</li> <li>struct esp_ip6_addr</li> <li>struct esp_netif_ip6_info_t</li> <li>struct esp_netif_ip_info_t</li> <li>namespace fs</li> <li>class fs::FS</li> <li>class fs::FSImpl</li> <li>class fs::File</li> <li>class fs::FileImpl</li> <li>struct ip_event_ap_staipassigned_t</li> <li>struct ip_event_got_ip6_t</li> <li>struct ip_event_got_ip_t</li> <li>struct lt_flash_id_t</li> <li>struct lt_ota_ctx_t</li> <li>class mDNS</li> <li>struct mbedtls_md5_context</li> <li>namespace mime</li> <li>struct mime::Entry</li> <li>struct wifi_event_action_tx_status_t</li> <li>struct wifi_event_ap_probe_req_rx_t</li> <li>struct wifi_event_ap_staconnected_t</li> <li>struct wifi_event_ap_stadisconnected_t</li> <li>struct wifi_event_ftm_report_t</li> <li>struct wifi_event_roc_done_t</li> <li>struct wifi_event_sta_authmode_change_t</li> <li>struct wifi_event_sta_connected_t</li> <li>struct wifi_event_sta_disconnected_t</li> <li>struct wifi_event_sta_scan_done_t</li> <li>struct wifi_event_sta_wps_er_pin_t</li> <li>struct wifi_event_sta_wps_er_success_t</li> <li>struct wifi_ftm_report_entry_t</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>cores</li> <li>cores/common<ul> <li>cores/common/arduino</li> <li>cores/common/arduino/libraries<ul> <li>cores/common/arduino/libraries/api</li> <li>cores/common/arduino/libraries/api/Serial<ul> <li>Serial.cpp</li> <li>Serial.cpp source</li> <li>Serial.h</li> <li>Serial.h source</li> </ul> </li> <li>cores/common/arduino/libraries/api/SoftwareSerial<ul> <li>SoftwareSerial.cpp</li> <li>SoftwareSerial.cpp source</li> <li>SoftwareSerial.h</li> <li>SoftwareSerial.h source</li> </ul> </li> <li>cores/common/arduino/libraries/api/WiFi<ul> <li>WiFi.cpp</li> <li>WiFi.cpp source</li> <li>WiFi.h</li> <li>WiFi.h source</li> <li>WiFiAP.cpp</li> <li>WiFiAP.cpp source</li> <li>WiFiEvents.cpp</li> <li>WiFiEvents.cpp source</li> <li>WiFiEvents.h</li> <li>WiFiEvents.h source</li> <li>WiFiGeneric.cpp</li> <li>WiFiGeneric.cpp source</li> <li>WiFiSTA.cpp</li> <li>WiFiSTA.cpp source</li> <li>WiFiScan.cpp</li> <li>WiFiScan.cpp source</li> <li>WiFiType.h</li> <li>WiFiType.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common</li> <li>cores/common/arduino/libraries/common/FS<ul> <li>FS.cpp</li> <li>FS.cpp source</li> <li>FS.h</li> <li>FS.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/IPv6Address<ul> <li>IPv6Address.cpp</li> <li>IPv6Address.cpp source</li> <li>IPv6Address.h</li> <li>IPv6Address.h source</li> <li>cores/common/arduino/libraries/common/IPv6Address/api</li> <li>IPv6Address.h</li> <li>IPv6Address.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/MD5<ul> <li>MD5.h</li> <li>MD5.h source</li> <li>MD5HostapdImpl.h</li> <li>MD5HostapdImpl.h source</li> <li>MD5MbedTLSImpl.cpp</li> <li>MD5MbedTLSImpl.cpp source</li> <li>MD5MbedTLSImpl.h</li> <li>MD5MbedTLSImpl.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/Preferences<ul> <li>Preferences.h</li> <li>Preferences.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/Update<ul> <li>Update.cpp</li> <li>Update.cpp source</li> <li>Update.h</li> <li>Update.h source</li> <li>UpdateUtil.cpp</li> <li>UpdateUtil.cpp source</li> </ul> </li> <li>cores/common/arduino/libraries/common/WiFiClient<ul> <li>LwIPClient.cpp</li> <li>LwIPClient.cpp source</li> <li>LwIPClient.h</li> <li>LwIPClient.h source</li> <li>LwIPRxBuffer.cpp</li> <li>LwIPRxBuffer.cpp source</li> <li>LwIPRxBuffer.h</li> <li>LwIPRxBuffer.h source</li> <li>MbedTLSClient.cpp</li> <li>MbedTLSClient.cpp source</li> <li>MbedTLSClient.h</li> <li>MbedTLSClient.h source</li> <li>WiFiClient.h</li> <li>WiFiClient.h source</li> <li>WiFiClientSecure.h</li> <li>WiFiClientSecure.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/WiFiServer<ul> <li>LwIPServer.cpp</li> <li>LwIPServer.cpp source</li> <li>LwIPServer.h</li> <li>LwIPServer.h source</li> <li>WiFiServer.h</li> <li>WiFiServer.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/WiFiUdp<ul> <li>LwIPUdp.cpp</li> <li>LwIPUdp.cpp source</li> <li>LwIPUdp.h</li> <li>LwIPUdp.h source</li> <li>WiFiUdp.h</li> <li>WiFiUdp.h source</li> </ul> </li> <li>cores/common/arduino/libraries/common/mDNS<ul> <li>LwIPmDNS.cpp</li> <li>LwIPmDNS.cpp source</li> <li>mDNS.cpp</li> <li>mDNS.cpp source</li> <li>mDNS.h</li> <li>mDNS.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext</li> <li>cores/common/arduino/libraries/ext/HTTPClient<ul> <li>HTTPClient.cpp</li> <li>HTTPClient.cpp source</li> <li>HTTPClient.h</li> <li>HTTPClient.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext/StreamString<ul> <li>StreamString.cpp</li> <li>StreamString.cpp source</li> <li>StreamString.h</li> <li>StreamString.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext/WebServer<ul> <li>HTTP_Method.h</li> <li>HTTP_Method.h source</li> <li>Parsing.cpp</li> <li>Parsing.cpp source</li> <li>Uri.h</li> <li>Uri.h source</li> <li>WebServer.cpp</li> <li>WebServer.cpp source</li> <li>WebServer.h</li> <li>WebServer.h source</li> <li>cores/common/arduino/libraries/ext/WebServer/detail</li> <li>RequestHandler.h</li> <li>RequestHandler.h source</li> <li>RequestHandlersImpl.h</li> <li>RequestHandlersImpl.h source</li> <li>mimetable.cpp</li> <li>mimetable.cpp source</li> <li>mimetable.h</li> <li>mimetable.h source</li> <li>cores/common/arduino/libraries/ext/WebServer/uri</li> <li>UriBraces.h</li> <li>UriBraces.h source</li> <li>UriGlob.h</li> <li>UriGlob.h source</li> <li>UriRegex.h</li> <li>UriRegex.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext/WiFiMulti<ul> <li>WiFiMulti.cpp</li> <li>WiFiMulti.cpp source</li> <li>WiFiMulti.h</li> <li>WiFiMulti.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext/base64<ul> <li>base64.cpp</li> <li>base64.cpp source</li> <li>base64.h</li> <li>base64.h source</li> <li>cores/common/arduino/libraries/ext/base64/libb64</li> <li>cdecode.c</li> <li>cdecode.c source</li> <li>cdecode.h</li> <li>cdecode.h source</li> <li>cencode.c</li> <li>cencode.c source</li> <li>cencode.h</li> <li>cencode.h source</li> </ul> </li> <li>cores/common/arduino/libraries/ext/cbuf<ul> <li>cbuf.cpp</li> <li>cbuf.cpp source</li> <li>cbuf.h</li> <li>cbuf.h source</li> </ul> </li> <li>cores/common/arduino/libraries/inline</li> <li>Singletons.cpp</li> <li>Singletons.cpp source</li> <li>cores/common/arduino/libraries/inline/ESP<ul> <li>ESP.h</li> <li>ESP.h source</li> </ul> </li> <li>cores/common/arduino/libraries/inline/Flash<ul> <li>Flash.h</li> <li>Flash.h source</li> </ul> </li> <li>cores/common/arduino/libraries/inline/LT<ul> <li>LT.h</li> <li>LT.h source</li> </ul> </li> <li>cores/common/arduino/libraries/inline/OTA<ul> <li>OTA.h</li> <li>OTA.h source</li> </ul> </li> <li>cores/common/arduino/libraries/inline/WDT<ul> <li>WDT.h</li> <li>WDT.h source</li> </ul> </li> </ul> </li> <li>cores/common/arduino/src<ul> <li>Arduino.h</li> <li>Arduino.h source</li> <li>Events.cpp</li> <li>Events.cpp source</li> <li>Events.h</li> <li>Events.h source</li> <li>HardwareI2C.h</li> <li>HardwareI2C.h source</li> <li>cores/common/arduino/src/common</li> <li>abi.cpp</li> <li>abi.cpp source</li> <li>dtostrf.c</li> <li>dtostrf.c source</li> <li>serial_event.cpp</li> <li>serial_event.cpp source</li> <li>cores/common/arduino/src/compat</li> <li>ESPmDNS.h</li> <li>ESPmDNS.h source</li> <li>FS.h</li> <li>FS.h source</li> <li>FSImpl.h</li> <li>FSImpl.h source</li> <li>WiFiAP.h</li> <li>WiFiAP.h source</li> <li>md5.h</li> <li>md5.h source</li> <li>pgmspace.h</li> <li>pgmspace.h source</li> <li>vfs_api.h</li> <li>vfs_api.h source</li> <li>cores/common/arduino/src/posix</li> <li>time.c</li> <li>time.c source</li> <li>cores/common/arduino/src/wiring</li> <li>wiring.c</li> <li>wiring.c source</li> <li>wiring_compat.cpp</li> <li>wiring_compat.cpp source</li> <li>wiring_compat.h</li> <li>wiring_compat.h source</li> <li>wiring_custom.c</li> <li>wiring_custom.c source</li> <li>wiring_custom.h</li> <li>wiring_custom.h source</li> <li>wiring_irq.c</li> <li>wiring_irq.c source</li> <li>wiring_math.cpp</li> <li>wiring_math.cpp source</li> <li>wiring_private.c</li> <li>wiring_private.c source</li> <li>wiring_private.h</li> <li>wiring_private.h source</li> <li>wiring_shift.c</li> <li>wiring_shift.c source</li> <li>main.c</li> <li>main.c source</li> </ul> </li> <li>cores/common/base</li> <li>cores/common/base/api<ul> <li>lt_cpu.c</li> <li>lt_cpu.c source</li> <li>lt_cpu.h</li> <li>lt_cpu.h source</li> <li>lt_device.c</li> <li>lt_device.c source</li> <li>lt_device.h</li> <li>lt_device.h source</li> <li>lt_flash.c</li> <li>lt_flash.c source</li> <li>lt_flash.h</li> <li>lt_flash.h source</li> <li>lt_init.h</li> <li>lt_init.h source</li> <li>lt_mem.c</li> <li>lt_mem.c source</li> <li>lt_mem.h</li> <li>lt_mem.h source</li> <li>lt_ota.c</li> <li>lt_ota.c source</li> <li>lt_ota.h</li> <li>lt_ota.h source</li> <li>lt_sleep.c</li> <li>lt_sleep.c source</li> <li>lt_sleep.h</li> <li>lt_sleep.h source</li> <li>lt_utils.c</li> <li>lt_utils.c source</li> <li>lt_utils.h</li> <li>lt_utils.h source</li> <li>lt_wdt.c</li> <li>lt_wdt.c source</li> <li>lt_wdt.h</li> <li>lt_wdt.h source</li> </ul> </li> <li>cores/common/base/compat<ul> <li>certs.h</li> <li>certs.h source</li> <li>cores/common/base/compat/lwip</li> <li>lwip_timers.h</li> <li>lwip_timers.h source</li> <li>err.h</li> <li>err.h source</li> <li>netdb.h</li> <li>netdb.h source</li> <li>netif.h</li> <li>netif.h source</li> <li>sockets.h</li> <li>sockets.h source</li> <li>sys.h</li> <li>sys.h source</li> <li>tcpip.h</li> <li>tcpip.h source</li> <li>udp.h</li> <li>udp.h source</li> </ul> </li> <li>cores/common/base/config<ul> <li>fal_cfg.h</li> <li>fal_cfg.h source</li> <li>fdb_cfg.h</li> <li>fdb_cfg.h source</li> <li>lwipopts.h</li> <li>lwipopts.h source</li> <li>printf_config.h</li> <li>printf_config.h source</li> </ul> </li> <li>cores/common/base/fixups<ul> <li>cores/common/base/fixups/lwip</li> <li>errno.h</li> <li>errno.h source</li> <li>errno.h</li> <li>errno.h source</li> <li>malloc.c</li> <li>malloc.c source</li> </ul> </li> <li>cores/common/base/posix<ul> <li>itoa.c</li> <li>itoa.c source</li> <li>strcasecmp.c</li> <li>strcasecmp.c source</li> <li>strdup.c</li> <li>strdup.c source</li> <li>strptime.c</li> <li>strptime.c source</li> </ul> </li> <li>cores/common/base/wraps<ul> <li>putchar.c</li> <li>putchar.c source</li> <li>puts.c</li> <li>puts.c source</li> </ul> </li> <li>libretiny.h</li> <li>libretiny.h source</li> <li>lt_api.h</li> <li>lt_api.h source</li> <li>lt_config.h</li> <li>lt_config.h source</li> <li>lt_logger.c</li> <li>lt_logger.c source</li> <li>lt_logger.h</li> <li>lt_logger.h source</li> <li>lt_main.c</li> <li>lt_main.c source</li> <li>lt_pins.h</li> <li>lt_pins.h source</li> <li>lt_posix_api.h</li> <li>lt_posix_api.h source</li> <li>lt_types.h</li> <li>lt_types.h source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}